"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6170],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>N});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},k=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),m=d(n),k=r,N=m["".concat(s,".").concat(k)]||m[k]||p[k]||l;return n?a.createElement(N,i(i({ref:t},u),{},{components:n})):a.createElement(N,i({ref:t},u))}));function N(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=k;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[m]="string"==typeof e?e:r,i[1]=o;for(var d=2;d<l;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}k.displayName="MDXCreateElement"},38530:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>s,default:()=>N,frontMatter:()=>o,metadata:()=>d,toc:()=>m});var a=n(87462),r=n(63366),l=(n(67294),n(3905)),i=["components"],o={id:"reference",title:"SQL-based ingestion reference",sidebar_label:"Reference"},s=void 0,d={unversionedId:"multi-stage-query/reference",id:"multi-stage-query/reference",title:"SQL-based ingestion reference",description:"\x3c!--",source:"@site/docs/32.0.0/multi-stage-query/reference.md",sourceDirName:"multi-stage-query",slug:"/multi-stage-query/reference",permalink:"/docs/32.0.0/multi-stage-query/reference",draft:!1,tags:[],version:"current",frontMatter:{id:"reference",title:"SQL-based ingestion reference",sidebar_label:"Reference"},sidebar:"docs",previous:{title:"Examples",permalink:"/docs/32.0.0/multi-stage-query/examples"},next:{title:"Known issues",permalink:"/docs/32.0.0/multi-stage-query/known-issues"}},u={},m=[{value:"SQL reference",id:"sql-reference",level:2},{value:"<code>EXTERN</code> Function",id:"extern-function",level:3},{value:"<code>EXTERN</code> as an input source",id:"extern-as-an-input-source",level:4},{value:"<code>EXTERN</code> to export to a destination",id:"extern-to-export-to-a-destination",level:4},{value:"S3 - Amazon S3",id:"s3---amazon-s3",level:5},{value:"GOOGLE - Google Cloud Storage",id:"google---google-cloud-storage",level:5},{value:"LOCAL - local file storage",id:"local---local-file-storage",level:5},{value:"<code>INSERT</code>",id:"insert",level:3},{value:"<code>REPLACE</code>",id:"replace",level:3},{value:"<code>REPLACE</code> all data",id:"replace-all-data",level:4},{value:"<code>REPLACE</code> specific time ranges",id:"replace-specific-time-ranges",level:4},{value:"<code>PARTITIONED BY</code>",id:"partitioned-by",level:3},{value:"<code>CLUSTERED BY</code>",id:"clustered-by",level:3},{value:"Context parameters",id:"context-parameters",level:2},{value:"Joins",id:"joins",level:2},{value:"Broadcast",id:"broadcast",level:3},{value:"Sort-merge",id:"sort-merge",level:3},{value:"Durable storage",id:"durable-storage",level:2},{value:"Durable storage configurations",id:"durable-storage-configurations",level:3},{value:"Durable storage cleaner configurations",id:"durable-storage-cleaner-configurations",level:3},{value:"Limits",id:"limits",level:2},{value:"Error codes",id:"error-codes",level:2}],p={toc:m},k="wrapper";function N(e){var t=e.components,n=(0,r.Z)(e,i);return(0,l.kt)(k,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("admonition",{type:"info"},(0,l.kt)("p",{parentName:"admonition"}," This page describes SQL-based batch ingestion using the ",(0,l.kt)("a",{parentName:"p",href:"/docs/32.0.0/multi-stage-query/"},(0,l.kt)("inlineCode",{parentName:"a"},"druid-multi-stage-query")),"\nextension, new in Druid 24.0. Refer to the ",(0,l.kt)("a",{parentName:"p",href:"/docs/32.0.0/ingestion/#batch"},"ingestion methods")," table to determine which\ningestion method is right for you.")),(0,l.kt)("h2",{id:"sql-reference"},"SQL reference"),(0,l.kt)("p",null,"This topic is a reference guide for the multi-stage query architecture in Apache Druid. For examples of real-world\nusage, refer to the ",(0,l.kt)("a",{parentName:"p",href:"/docs/32.0.0/multi-stage-query/examples"},"Examples")," page."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"INSERT")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"REPLACE")," load data into a Druid datasource from either an external input source, or from another\ndatasource. When loading from an external datasource, you typically must provide the kind of input source,\nthe data format, and the schema (signature) of the input file. Druid provides ",(0,l.kt)("em",{parentName:"p"},"table functions")," to allow you to\nspecify the external file. There are two kinds. ",(0,l.kt)("inlineCode",{parentName:"p"},"EXTERN")," works with the JSON-serialized specs for the three\nitems, using the same JSON you would use in native ingest. A set of other, input-source-specific functions\nuse SQL syntax to specify the format and the input schema. There is one function for each input source. The\ninput-source-specific functions allow you to use SQL query parameters to specify the set of files (or URIs),\nmaking it easy to reuse the same SQL statement for each ingest: just specify the set of files to use each time."),(0,l.kt)("h3",{id:"extern-function"},(0,l.kt)("inlineCode",{parentName:"h3"},"EXTERN")," Function"),(0,l.kt)("p",null,"Use the ",(0,l.kt)("inlineCode",{parentName:"p"},"EXTERN")," function to read external data or write to an external location."),(0,l.kt)("h4",{id:"extern-as-an-input-source"},(0,l.kt)("inlineCode",{parentName:"h4"},"EXTERN")," as an input source"),(0,l.kt)("p",null,"The function has two variations.\nFunction variation 1, with the input schema expressed as JSON:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT\n <column>\nFROM TABLE(\n  EXTERN(\n    '<Druid input source>',\n    '<Druid input format>',\n    '<row signature>'\n  )\n)\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"EXTERN")," consists of the following parts:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Any ",(0,l.kt)("a",{parentName:"li",href:"/docs/32.0.0/ingestion/input-sources"},"Druid input source")," as a JSON-encoded string."),(0,l.kt)("li",{parentName:"ol"},"Any ",(0,l.kt)("a",{parentName:"li",href:"/docs/32.0.0/ingestion/data-formats"},"Druid input format")," as a JSON-encoded string."),(0,l.kt)("li",{parentName:"ol"},"A row signature, as a JSON-encoded array of column descriptors. Each column descriptor must have a\n",(0,l.kt)("inlineCode",{parentName:"li"},"name")," and a ",(0,l.kt)("inlineCode",{parentName:"li"},"type"),". The type can be ",(0,l.kt)("inlineCode",{parentName:"li"},"string"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"long"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"double"),", or ",(0,l.kt)("inlineCode",{parentName:"li"},"float"),". This row signature is\nused to map the external data into the SQL layer.")),(0,l.kt)("p",null,"Variation 2, with the input schema expressed in SQL using an ",(0,l.kt)("inlineCode",{parentName:"p"},"EXTEND")," clause. See the next\nsection for more detail on ",(0,l.kt)("inlineCode",{parentName:"p"},"EXTEND"),". This format also uses named arguments to make the SQL easier to read:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT\n <column>\nFROM TABLE(\n  EXTERN(\n    inputSource => '<Druid input source>',\n    inputFormat => '<Druid input format>'\n  )) (<columns>)\n\n")),(0,l.kt)("p",null,"The input source and format are as above. The columns are expressed as in a SQL ",(0,l.kt)("inlineCode",{parentName:"p"},"CREATE TABLE"),".\nExample: ",(0,l.kt)("inlineCode",{parentName:"p"},"(timestamp VARCHAR, metricType VARCHAR, value BIGINT)"),". The optional ",(0,l.kt)("inlineCode",{parentName:"p"},"EXTEND")," keyword\ncan precede the column list: ",(0,l.kt)("inlineCode",{parentName:"p"},"EXTEND (timestamp VARCHAR...)"),"."),(0,l.kt)("p",null,"For more information, see ",(0,l.kt)("a",{parentName:"p",href:"/docs/32.0.0/multi-stage-query/concepts#read-external-data-with-extern"},"Read external data with EXTERN"),"."),(0,l.kt)("h4",{id:"extern-to-export-to-a-destination"},(0,l.kt)("inlineCode",{parentName:"h4"},"EXTERN")," to export to a destination"),(0,l.kt)("p",null,"You can use ",(0,l.kt)("inlineCode",{parentName:"p"},"EXTERN")," to specify a destination to export data.\nThis variation of ",(0,l.kt)("inlineCode",{parentName:"p"},"EXTERN")," accepts the details of the destination as the only argument and requires an ",(0,l.kt)("inlineCode",{parentName:"p"},"AS")," clause to specify the format of the exported rows."),(0,l.kt)("p",null,"When you export data, Druid creates metadata files in a subdirectory named ",(0,l.kt)("inlineCode",{parentName:"p"},"_symlink_format_manifest"),".\nWithin the ",(0,l.kt)("inlineCode",{parentName:"p"},"_symlink_format_manifest/manifest")," directory, the ",(0,l.kt)("inlineCode",{parentName:"p"},"manifest")," file lists absolute paths to exported files using the symlink manifest format. For example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"s3://export-bucket/export/query-6564a32f-2194-423a-912e-eead470a37c4-worker2-partition2.csv\ns3://export-bucket/export/query-6564a32f-2194-423a-912e-eead470a37c4-worker1-partition1.csv\ns3://export-bucket/export/query-6564a32f-2194-423a-912e-eead470a37c4-worker0-partition0.csv\n...\ns3://export-bucket/export/query-6564a32f-2194-423a-912e-eead470a37c4-worker0-partition24.csv\n")),(0,l.kt)("p",null,"Keep the following in mind when using EXTERN to export rows:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Only INSERT statements are supported."),(0,l.kt)("li",{parentName:"ul"},"Only ",(0,l.kt)("inlineCode",{parentName:"li"},"CSV")," format is supported as an export format."),(0,l.kt)("li",{parentName:"ul"},"Partitioning (",(0,l.kt)("inlineCode",{parentName:"li"},"PARTITIONED BY"),") and clustering (",(0,l.kt)("inlineCode",{parentName:"li"},"CLUSTERED BY"),") aren't supported with EXTERN statements."),(0,l.kt)("li",{parentName:"ul"},"You can export to Amazon S3, Google GCS, or local storage."),(0,l.kt)("li",{parentName:"ul"},"The destination provided should contain no other files or directories.")),(0,l.kt)("p",null,"When you export data, use the ",(0,l.kt)("inlineCode",{parentName:"p"},"rowsPerPage")," context parameter to restrict the size of exported files.\nWhen the number of rows in the result set exceeds the value of the parameter, Druid splits the output into multiple files."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"INSERT INTO\n  EXTERN(<destination function>)\nAS CSV\nSELECT\n  <column>\nFROM <table>\n")),(0,l.kt)("h5",{id:"s3---amazon-s3"},"S3 - Amazon S3"),(0,l.kt)("p",null,"To export results to S3, pass the ",(0,l.kt)("inlineCode",{parentName:"p"},"s3()")," function as an argument to the ",(0,l.kt)("inlineCode",{parentName:"p"},"EXTERN")," function.\nExport to S3 requires the ",(0,l.kt)("inlineCode",{parentName:"p"},"druid-s3-extensions")," extension.\nFor a list of S3 permissions the MSQ task engine requires to perform export, see ",(0,l.kt)("a",{parentName:"p",href:"/docs/32.0.0/multi-stage-query/security#s3"},"Permissions for durable storage"),"."),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"s3()")," function configures the connection to AWS.\nPass all arguments for ",(0,l.kt)("inlineCode",{parentName:"p"},"s3()")," as named parameters with their values enclosed in single quotes. For example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"INSERT INTO\n  EXTERN(\n    s3(bucket => 'your_bucket', prefix => 'prefix/to/files')\n  )\nAS CSV\nSELECT\n  <column>\nFROM <table>\n")),(0,l.kt)("p",null,"Supported arguments for the function:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"bucket")),(0,l.kt)("td",{parentName:"tr",align:null},"Yes"),(0,l.kt)("td",{parentName:"tr",align:null},"S3 bucket destination for exported files. You must add the bucket and prefix combination to the ",(0,l.kt)("inlineCode",{parentName:"td"},"druid.export.storage.s3.allowedExportPaths")," allow list."),(0,l.kt)("td",{parentName:"tr",align:null},"n/a")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"prefix")),(0,l.kt)("td",{parentName:"tr",align:null},"Yes"),(0,l.kt)("td",{parentName:"tr",align:null},"Destination path in the bucket to create exported files. The export query expects the destination path to be empty. If the location includes other files, the query will fail. You must add the bucket and prefix combination to the ",(0,l.kt)("inlineCode",{parentName:"td"},"druid.export.storage.s3.allowedExportPaths")," allow list."),(0,l.kt)("td",{parentName:"tr",align:null},"n/a")))),(0,l.kt)("p",null,"Configure the following runtime parameters to export to an S3 destination:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Runtime parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"druid.export.storage.s3.allowedExportPaths")),(0,l.kt)("td",{parentName:"tr",align:null},"Yes"),(0,l.kt)("td",{parentName:"tr",align:null},"Array of S3 prefixes allowed as export destinations. Export queries fail if the export destination does not match any of the configured prefixes. For example: ",(0,l.kt)("inlineCode",{parentName:"td"},'[\\"s3://bucket1/export/\\", \\"s3://bucket2/export/\\"]')),(0,l.kt)("td",{parentName:"tr",align:null},"n/a")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"druid.export.storage.s3.tempLocalDir")),(0,l.kt)("td",{parentName:"tr",align:null},"No"),(0,l.kt)("td",{parentName:"tr",align:null},"Directory for local storage where the worker stores temporary files before uploading the data to S3."),(0,l.kt)("td",{parentName:"tr",align:null},"n/a")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"druid.export.storage.s3.maxRetry")),(0,l.kt)("td",{parentName:"tr",align:null},"No"),(0,l.kt)("td",{parentName:"tr",align:null},"Maximum number of  attempts for S3 API calls to avoid failures due to transient errors."),(0,l.kt)("td",{parentName:"tr",align:null},"10")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"druid.export.storage.s3.chunkSize")),(0,l.kt)("td",{parentName:"tr",align:null},"No"),(0,l.kt)("td",{parentName:"tr",align:null},"Individual chunk size to store temporarily in ",(0,l.kt)("inlineCode",{parentName:"td"},"tempDir"),". Large chunk sizes reduce the number of API calls to S3, but require more disk space to store temporary chunks."),(0,l.kt)("td",{parentName:"tr",align:null},"100MiB")))),(0,l.kt)("h5",{id:"google---google-cloud-storage"},"GOOGLE - Google Cloud Storage"),(0,l.kt)("p",null,"To export query results to Google Cloud Storage (GCS), pass the ",(0,l.kt)("inlineCode",{parentName:"p"},"google()")," function as an argument to the ",(0,l.kt)("inlineCode",{parentName:"p"},"EXTERN")," function.\nExport to GCS requires the ",(0,l.kt)("inlineCode",{parentName:"p"},"druid-google-extensions")," extension."),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"google()")," function configures the connection to GCS. Pass the arguments for ",(0,l.kt)("inlineCode",{parentName:"p"},"google()")," as named parameters with their values enclosed in single quotes. For example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"INSERT INTO\n  EXTERN(\n    google(bucket => 'your_bucket', prefix => 'prefix/to/files')\n  )\nAS CSV\nSELECT\n  <column>\nFROM <table>\n")),(0,l.kt)("p",null,"Supported arguments for the function:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"bucket")),(0,l.kt)("td",{parentName:"tr",align:null},"Yes"),(0,l.kt)("td",{parentName:"tr",align:null},"GCS bucket destination for exported files. You must add the bucket and prefix combination to the ",(0,l.kt)("inlineCode",{parentName:"td"},"druid.export.storage.google.allowedExportPaths")," allow list."),(0,l.kt)("td",{parentName:"tr",align:null},"n/a")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"prefix")),(0,l.kt)("td",{parentName:"tr",align:null},"Yes"),(0,l.kt)("td",{parentName:"tr",align:null},"Destination path in the bucket to create exported files. The export query expects the destination path to be empty. If the location includes other files, the query will fail. You must add the bucket and prefix combination to the ",(0,l.kt)("inlineCode",{parentName:"td"},"druid.export.storage.google.allowedExportPaths")," allow list."),(0,l.kt)("td",{parentName:"tr",align:null},"n/a")))),(0,l.kt)("p",null,"Configure the following runtime parameters to export query results to a GCS destination:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Runtime parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"druid.export.storage.google.allowedExportPaths")),(0,l.kt)("td",{parentName:"tr",align:null},"Yes"),(0,l.kt)("td",{parentName:"tr",align:null},"Array of GCS prefixes allowed as export destinations. Export queries fail if the export destination does not match any of the configured prefixes. For example: ",(0,l.kt)("inlineCode",{parentName:"td"},'[\\"gs://bucket1/export/\\", \\"gs://bucket2/export/\\"]')),(0,l.kt)("td",{parentName:"tr",align:null},"n/a")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"druid.export.storage.google.tempLocalDir")),(0,l.kt)("td",{parentName:"tr",align:null},"No"),(0,l.kt)("td",{parentName:"tr",align:null},"Directory for local storage where the worker stores temporary files before uploading the data to GCS."),(0,l.kt)("td",{parentName:"tr",align:null},"n/a")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"druid.export.storage.google.maxRetry")),(0,l.kt)("td",{parentName:"tr",align:null},"No"),(0,l.kt)("td",{parentName:"tr",align:null},"Maximum number of attempts for GCS API calls to avoid failures due to transient errors."),(0,l.kt)("td",{parentName:"tr",align:null},"10")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"druid.export.storage.google.chunkSize")),(0,l.kt)("td",{parentName:"tr",align:null},"No"),(0,l.kt)("td",{parentName:"tr",align:null},"Individual chunk size to store temporarily in ",(0,l.kt)("inlineCode",{parentName:"td"},"tempDir"),". Large chunk sizes reduce the number of API calls to GS, but require more disk space to store temporary chunks."),(0,l.kt)("td",{parentName:"tr",align:null},"4 MiB")))),(0,l.kt)("h5",{id:"local---local-file-storage"},"LOCAL - local file storage"),(0,l.kt)("p",null,"You can export queries to local storage. This process writes the results to the filesystem on the MSQ worker.\nThis is useful in a single node setup or for testing but is not suitable for production use cases."),(0,l.kt)("p",null,"To export results to local storage, pass the ",(0,l.kt)("inlineCode",{parentName:"p"},"LOCAL()")," function as an argument to the EXTERN function.\nYou must configure the runtime property ",(0,l.kt)("inlineCode",{parentName:"p"},"druid.export.storage.baseDir")," as an absolute path on the Indexer or Middle Manager to use local storage as an export destination.\nYou can export data to paths that match this value as a prefix.\nPass all arguments to ",(0,l.kt)("inlineCode",{parentName:"p"},"LOCAL()")," as named parameters with values enclosed in single quotes. For example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"INSERT INTO\n  EXTERN(\n    local(exportPath => 'exportLocation/query1')\n  )\nAS CSV\nSELECT\n  <column>\nFROM <table>\n")),(0,l.kt)("p",null,"Supported arguments for the function:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"exportPath")),(0,l.kt)("td",{parentName:"tr",align:null},"Yes"),(0,l.kt)("td",{parentName:"tr",align:null},"Absolute path to a subdirectory of ",(0,l.kt)("inlineCode",{parentName:"td"},"druid.export.storage.baseDir")," where Druid exports the query results. The destination must be empty. If the location includes other files or directories, the query will fail."),(0,l.kt)("td",{parentName:"tr",align:null},"n/a")))),(0,l.kt)("p",null,"For more information, see ",(0,l.kt)("a",{parentName:"p",href:"/docs/32.0.0/multi-stage-query/concepts#write-to-an-external-destination-with-extern"},"Export external data with EXTERN"),"."),(0,l.kt)("h3",{id:"insert"},(0,l.kt)("inlineCode",{parentName:"h3"},"INSERT")),(0,l.kt)("p",null,"Use the ",(0,l.kt)("inlineCode",{parentName:"p"},"INSERT")," statement to insert data."),(0,l.kt)("p",null,"Unlike standard SQL, ",(0,l.kt)("inlineCode",{parentName:"p"},"INSERT")," loads data into the target table according to column name, not positionally. If necessary,\nuse ",(0,l.kt)("inlineCode",{parentName:"p"},"AS")," in your ",(0,l.kt)("inlineCode",{parentName:"p"},"SELECT")," column list to assign the correct names. Do not rely on their positions within the SELECT\nclause."),(0,l.kt)("p",null,"Statement format:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"INSERT INTO <table name>\n< SELECT query >\nPARTITIONED BY <time frame>\n[ CLUSTERED BY <column list> ]\n")),(0,l.kt)("p",null,"INSERT consists of the following parts:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Optional ",(0,l.kt)("a",{parentName:"li",href:"/docs/32.0.0/multi-stage-query/reference#context-parameters"},"context parameters"),"."),(0,l.kt)("li",{parentName:"ol"},"An ",(0,l.kt)("inlineCode",{parentName:"li"},"INSERT INTO <dataSource>")," clause at the start of your query, such as ",(0,l.kt)("inlineCode",{parentName:"li"},"INSERT INTO your-table"),"."),(0,l.kt)("li",{parentName:"ol"},"A clause for the data you want to insert, such as ",(0,l.kt)("inlineCode",{parentName:"li"},"SELECT ... FROM ..."),". You can use ",(0,l.kt)("a",{parentName:"li",href:"#extern-function"},(0,l.kt)("inlineCode",{parentName:"a"},"EXTERN")),"\nto reference external tables using ",(0,l.kt)("inlineCode",{parentName:"li"},"FROM TABLE(EXTERN(...))"),"."),(0,l.kt)("li",{parentName:"ol"},"A ",(0,l.kt)("a",{parentName:"li",href:"#partitioned-by"},"PARTITIONED BY")," clause, such as ",(0,l.kt)("inlineCode",{parentName:"li"},"PARTITIONED BY DAY"),"."),(0,l.kt)("li",{parentName:"ol"},"An optional ",(0,l.kt)("a",{parentName:"li",href:"#clustered-by"},"CLUSTERED BY")," clause.")),(0,l.kt)("p",null,"For more information, see ",(0,l.kt)("a",{parentName:"p",href:"/docs/32.0.0/multi-stage-query/concepts#load-data-with-insert"},"Load data with INSERT"),"."),(0,l.kt)("h3",{id:"replace"},(0,l.kt)("inlineCode",{parentName:"h3"},"REPLACE")),(0,l.kt)("p",null,"You can use the ",(0,l.kt)("inlineCode",{parentName:"p"},"REPLACE")," function to replace all or some of the data."),(0,l.kt)("p",null,"Unlike standard SQL, ",(0,l.kt)("inlineCode",{parentName:"p"},"REPLACE")," loads data into the target table according to column name, not positionally. If necessary,\nuse ",(0,l.kt)("inlineCode",{parentName:"p"},"AS")," in your ",(0,l.kt)("inlineCode",{parentName:"p"},"SELECT")," column list to assign the correct names. Do not rely on their positions within the SELECT\nclause."),(0,l.kt)("h4",{id:"replace-all-data"},(0,l.kt)("inlineCode",{parentName:"h4"},"REPLACE")," all data"),(0,l.kt)("p",null,"Function format to replace all data:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"REPLACE INTO <target table>\nOVERWRITE ALL\n< SELECT query >\nPARTITIONED BY <time granularity>\n[ CLUSTERED BY <column list> ]\n")),(0,l.kt)("h4",{id:"replace-specific-time-ranges"},(0,l.kt)("inlineCode",{parentName:"h4"},"REPLACE")," specific time ranges"),(0,l.kt)("p",null,"Function format to replace specific time ranges:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"REPLACE INTO <target table>\nOVERWRITE WHERE __time >= TIMESTAMP '<lower bound>' AND __time < TIMESTAMP '<upper bound>'\n< SELECT query >\nPARTITIONED BY <time granularity>\n[ CLUSTERED BY <column list> ]\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"REPLACE")," consists of the following parts:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Optional ",(0,l.kt)("a",{parentName:"li",href:"/docs/32.0.0/multi-stage-query/reference#context-parameters"},"context parameters"),"."),(0,l.kt)("li",{parentName:"ol"},"A ",(0,l.kt)("inlineCode",{parentName:"li"},"REPLACE INTO <dataSource>")," clause at the start of your query, such as ",(0,l.kt)("inlineCode",{parentName:"li"},'REPLACE INTO "your-table".')),(0,l.kt)("li",{parentName:"ol"},"An OVERWRITE clause after the datasource, either OVERWRITE ALL or OVERWRITE WHERE:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"OVERWRITE ALL replaces the entire existing datasource with the results of the query."),(0,l.kt)("li",{parentName:"ul"},"OVERWRITE WHERE drops the time segments that match the condition you set. Conditions are based on the ",(0,l.kt)("inlineCode",{parentName:"li"},"__time"),"\ncolumn and use the format ",(0,l.kt)("inlineCode",{parentName:"li"},"__time [< > = <= >=] TIMESTAMP"),". Use them with AND, OR, and NOT between them, inclusive\nof the timestamps specified. No other expressions or functions are valid in OVERWRITE."))),(0,l.kt)("li",{parentName:"ol"},"A clause for the actual data you want to use for the replacement."),(0,l.kt)("li",{parentName:"ol"},"A ",(0,l.kt)("a",{parentName:"li",href:"#partitioned-by"},"PARTITIONED BY")," clause, such as ",(0,l.kt)("inlineCode",{parentName:"li"},"PARTITIONED BY DAY"),"."),(0,l.kt)("li",{parentName:"ol"},"An optional ",(0,l.kt)("a",{parentName:"li",href:"#clustered-by"},"CLUSTERED BY")," clause.")),(0,l.kt)("p",null,"For more information, see ",(0,l.kt)("a",{parentName:"p",href:"/docs/32.0.0/multi-stage-query/concepts#replace"},"Overwrite data with REPLACE"),"."),(0,l.kt)("h3",{id:"partitioned-by"},(0,l.kt)("inlineCode",{parentName:"h3"},"PARTITIONED BY")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"PARTITIONED BY <time granularity>")," clause is required for ",(0,l.kt)("a",{parentName:"p",href:"#insert"},"INSERT")," and ",(0,l.kt)("a",{parentName:"p",href:"#replace"},"REPLACE"),". See\n",(0,l.kt)("a",{parentName:"p",href:"/docs/32.0.0/multi-stage-query/concepts#partitioning-by-time"},"Partitioning")," for details."),(0,l.kt)("p",null,"The following granularity arguments are accepted:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Time unit keywords: ",(0,l.kt)("inlineCode",{parentName:"li"},"HOUR"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"DAY"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"MONTH"),", or ",(0,l.kt)("inlineCode",{parentName:"li"},"YEAR"),". Equivalent to ",(0,l.kt)("inlineCode",{parentName:"li"},"FLOOR(__time TO TimeUnit)"),"."),(0,l.kt)("li",{parentName:"ul"},"Time units as ISO 8601 period strings: ",(0,l.kt)("inlineCode",{parentName:"li"},"'PT1H'"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"'P1D'"),", etc. (Druid 26.0 and later.)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"TIME_FLOOR(__time, 'granularity_string')"),", where granularity_string is one of the ISO 8601 periods listed below. The\nfirst argument must be ",(0,l.kt)("inlineCode",{parentName:"li"},"__time"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"FLOOR(__time TO TimeUnit)"),", where ",(0,l.kt)("inlineCode",{parentName:"li"},"TimeUnit")," is any unit supported by the ",(0,l.kt)("a",{parentName:"li",href:"/docs/32.0.0/querying/sql-scalar#date-and-time-functions"},"FLOOR function"),". The first argument must be ",(0,l.kt)("inlineCode",{parentName:"li"},"__time"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ALL")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"ALL TIME"),", which effectively disables time partitioning by placing all data in a single time chunk. To use\nLIMIT or OFFSET at the outer level of your ",(0,l.kt)("inlineCode",{parentName:"li"},"INSERT")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"REPLACE")," query, you must set ",(0,l.kt)("inlineCode",{parentName:"li"},"PARTITIONED BY")," to ",(0,l.kt)("inlineCode",{parentName:"li"},"ALL")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"ALL TIME"),".")),(0,l.kt)("p",null,"Earlier versions required the ",(0,l.kt)("inlineCode",{parentName:"p"},"TIME_FLOOR")," notation to specify a granularity other than the keywords.\nIn the current version, the string constant provides a simpler equivalent solution."),(0,l.kt)("p",null,"The following ISO 8601 periods are supported for ",(0,l.kt)("inlineCode",{parentName:"p"},"TIME_FLOOR")," and the string constant:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"PT1S"),(0,l.kt)("li",{parentName:"ul"},"PT1M"),(0,l.kt)("li",{parentName:"ul"},"PT5M"),(0,l.kt)("li",{parentName:"ul"},"PT10M"),(0,l.kt)("li",{parentName:"ul"},"PT15M"),(0,l.kt)("li",{parentName:"ul"},"PT30M"),(0,l.kt)("li",{parentName:"ul"},"PT1H"),(0,l.kt)("li",{parentName:"ul"},"PT6H"),(0,l.kt)("li",{parentName:"ul"},"P1D"),(0,l.kt)("li",{parentName:"ul"},"P1W*"),(0,l.kt)("li",{parentName:"ul"},"P1M"),(0,l.kt)("li",{parentName:"ul"},"P3M"),(0,l.kt)("li",{parentName:"ul"},"P1Y")),(0,l.kt)("p",null,"The string constant can also include any of the keywords mentioned above:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"HOUR")," - Same as ",(0,l.kt)("inlineCode",{parentName:"li"},"'PT1H'")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"DAY")," - Same as ",(0,l.kt)("inlineCode",{parentName:"li"},"'P1D'")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"MONTH")," - Same as ",(0,l.kt)("inlineCode",{parentName:"li"},"'P1M'")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"YEAR")," - Same as ",(0,l.kt)("inlineCode",{parentName:"li"},"'P1Y'")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ALL TIME")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ALL")," - Alias for ",(0,l.kt)("inlineCode",{parentName:"li"},"ALL TIME"))),(0,l.kt)("p",null,"Examples:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-SQL"},"-- Keyword\nPARTITIONED BY HOUR\n\n-- String literal\nPARTITIONED BY 'HOUR'\n\n-- ISO 8601 period\nPARTITIONED BY 'PT1H'\n\n-- TIME_FLOOR function\nPARTITIONED BY TIME_FLOOR(__time, 'PT1H')\n")),(0,l.kt)("p",null,"For more information about partitioning, see ",(0,l.kt)("a",{parentName:"p",href:"/docs/32.0.0/multi-stage-query/concepts#partitioning-by-time"},"Partitioning"),". ",(0,l.kt)("br",null),(0,l.kt)("br",null),"\n*Avoid  partitioning by week, ",(0,l.kt)("inlineCode",{parentName:"p"},"P1W"),", because weeks don't align neatly with months and years, making it difficult to partition by coarser granularities later."),(0,l.kt)("h3",{id:"clustered-by"},(0,l.kt)("inlineCode",{parentName:"h3"},"CLUSTERED BY")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"CLUSTERED BY <column list>")," clause is optional for ",(0,l.kt)("a",{parentName:"p",href:"#insert"},"INSERT")," and ",(0,l.kt)("a",{parentName:"p",href:"#replace"},"REPLACE"),". It accepts a list of\ncolumn names or expressions."),(0,l.kt)("p",null,"This column list is used for ",(0,l.kt)("a",{parentName:"p",href:"/docs/32.0.0/ingestion/partitioning#secondary-partitioning"},"secondary partitioning")," of segments\nwithin a time chunk, and ",(0,l.kt)("a",{parentName:"p",href:"/docs/32.0.0/ingestion/partitioning#sorting"},"sorting")," of rows within a segment. For sorting purposes,\nDruid implicitly prepends ",(0,l.kt)("inlineCode",{parentName:"p"},"__time")," to the ",(0,l.kt)("inlineCode",{parentName:"p"},"CLUSTERED BY")," column list, unless\n",(0,l.kt)("a",{parentName:"p",href:"#context"},(0,l.kt)("inlineCode",{parentName:"a"},"forceSegmentSortByTime"))," is set to ",(0,l.kt)("inlineCode",{parentName:"p"},"false"),"\n(an experimental feature; see ",(0,l.kt)("a",{parentName:"p",href:"/docs/32.0.0/ingestion/partitioning#sorting"},"Sorting")," for details)."),(0,l.kt)("p",null,"For more information about clustering, see ",(0,l.kt)("a",{parentName:"p",href:"/docs/32.0.0/multi-stage-query/concepts#clustering"},"Clustering"),"."),(0,l.kt)("a",{name:"context"}),(0,l.kt)("h2",{id:"context-parameters"},"Context parameters"),(0,l.kt)("p",null,"In addition to the Druid SQL ",(0,l.kt)("a",{parentName:"p",href:"/docs/32.0.0/querying/sql-query-context"},"context parameters"),", the multi-stage query task engine accepts certain context parameters that are specific to it."),(0,l.kt)("p",null,"Use context parameters alongside your queries to customize the behavior of the query. If you're using the API, include the context parameters in the query context when you submit a query:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "query": "SELECT 1 + 1",\n  "context": {\n    "<key>": "<value>",\n    "maxNumTasks": 3\n  }\n}\n')),(0,l.kt)("p",null,"If you're using the web console, you can specify the context parameters through various UI options."),(0,l.kt)("p",null,"The following table lists the context parameters for the MSQ task engine:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default value"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"maxNumTasks")),(0,l.kt)("td",{parentName:"tr",align:null},"SELECT, INSERT, REPLACE",(0,l.kt)("br",null),(0,l.kt)("br",null),"The maximum total number of tasks to launch, including the controller task. The lowest possible value for this setting is 2: one controller and one worker. All tasks must be able to launch simultaneously. If they cannot, the query returns a ",(0,l.kt)("inlineCode",{parentName:"td"},"TaskStartTimeout")," error code after approximately 10 minutes.",(0,l.kt)("br",null),(0,l.kt)("br",null),"May also be provided as ",(0,l.kt)("inlineCode",{parentName:"td"},"numTasks"),". If both are present, ",(0,l.kt)("inlineCode",{parentName:"td"},"maxNumTasks")," takes priority."),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"taskAssignment")),(0,l.kt)("td",{parentName:"tr",align:null},"SELECT, INSERT, REPLACE",(0,l.kt)("br",null),(0,l.kt)("br",null),"Determines how many tasks to use. Possible values include: ",(0,l.kt)("ul",null,(0,l.kt)("li",null,(0,l.kt)("inlineCode",{parentName:"td"},"max"),": Uses as many tasks as possible, up to ",(0,l.kt)("inlineCode",{parentName:"td"},"maxNumTasks"),"."),(0,l.kt)("li",null,(0,l.kt)("inlineCode",{parentName:"td"},"auto"),": When file sizes can be determined through directory listing (for example: local files, S3, GCS, HDFS) uses as few tasks as possible without exceeding 512 MiB or 10,000 files per task, unless exceeding these limits is necessary to stay within ",(0,l.kt)("inlineCode",{parentName:"td"},"maxNumTasks"),". When calculating the size of files, the weighted size is used, which considers the file format and compression format used if any. When file sizes cannot be determined through directory listing (for example: http), behaves the same as ",(0,l.kt)("inlineCode",{parentName:"td"},"max"),"."))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"max"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"finalizeAggregations")),(0,l.kt)("td",{parentName:"tr",align:null},"SELECT, INSERT, REPLACE",(0,l.kt)("br",null),(0,l.kt)("br",null),"Determines the type of aggregation to return. If true, Druid finalizes the results of complex aggregations that directly appear in query results. If false, Druid returns the aggregation's intermediate type rather than finalized type. This parameter is useful during ingestion, where it enables storing sketches directly in Druid tables. For more information about aggregations, see ",(0,l.kt)("a",{parentName:"td",href:"/docs/32.0.0/querying/sql-aggregations"},"SQL aggregation functions"),"."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"true"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"arrayIngestMode")),(0,l.kt)("td",{parentName:"tr",align:null},"INSERT, REPLACE",(0,l.kt)("br",null),(0,l.kt)("br",null)," Controls how ARRAY type values are stored in Druid segments. When set to ",(0,l.kt)("inlineCode",{parentName:"td"},"array")," (recommended for SQL compliance), Druid will store all ARRAY typed values in ",(0,l.kt)("a",{parentName:"td",href:"/docs/32.0.0/querying/arrays"},"ARRAY typed columns"),", and supports storing both VARCHAR and numeric typed arrays. When set to ",(0,l.kt)("inlineCode",{parentName:"td"},"mvd")," (the default, for backwards compatibility), Druid only supports VARCHAR typed arrays, and will store them as ",(0,l.kt)("a",{parentName:"td",href:"/docs/32.0.0/querying/multi-value-dimensions"},"multi-value string columns"),". See ","[",(0,l.kt)("inlineCode",{parentName:"td"},"arrayIngestMode"),"]"," in the ",(0,l.kt)("a",{parentName:"td",href:"/docs/32.0.0/querying/arrays"},"Arrays")," page for more details."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"mvd")," (for backwards compatibility, recommended to use ",(0,l.kt)("inlineCode",{parentName:"td"},"array")," for SQL compliance)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"sqlJoinAlgorithm")),(0,l.kt)("td",{parentName:"tr",align:null},"SELECT, INSERT, REPLACE",(0,l.kt)("br",null),(0,l.kt)("br",null),"Algorithm to use for JOIN. Use ",(0,l.kt)("inlineCode",{parentName:"td"},"broadcast")," (the default) for broadcast hash join or ",(0,l.kt)("inlineCode",{parentName:"td"},"sortMerge")," for sort-merge join. Affects all JOIN operations in the query. This is a hint to the MSQ engine and the actual joins in the query may proceed in a different way than specified. See ",(0,l.kt)("a",{parentName:"td",href:"#joins"},"Joins")," for more details."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"broadcast"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"rowsInMemory")),(0,l.kt)("td",{parentName:"tr",align:null},"INSERT or REPLACE",(0,l.kt)("br",null),(0,l.kt)("br",null),"Maximum number of rows to store in memory at once before flushing to disk during the segment generation process. Ignored for non-INSERT queries. In most cases, use the default value. You may need to override the default if you run into one of the ",(0,l.kt)("a",{parentName:"td",href:"/docs/32.0.0/multi-stage-query/known-issues"},"known issues")," around memory usage."),(0,l.kt)("td",{parentName:"tr",align:null},"100,000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"segmentSortOrder")),(0,l.kt)("td",{parentName:"tr",align:null},"INSERT or REPLACE",(0,l.kt)("br",null),(0,l.kt)("br",null),"Normally, Druid sorts rows in individual segments using ",(0,l.kt)("inlineCode",{parentName:"td"},"__time")," first, followed by the ",(0,l.kt)("a",{parentName:"td",href:"#clustered-by"},"CLUSTERED BY")," clause. When you set ",(0,l.kt)("inlineCode",{parentName:"td"},"segmentSortOrder"),", Druid uses the order from this context parameter instead. Provide the column list as comma-separated values or as a JSON array in string form.",(0,l.kt)("br",null),"< br/>For example, consider an INSERT query that uses ",(0,l.kt)("inlineCode",{parentName:"td"},"CLUSTERED BY country")," and has ",(0,l.kt)("inlineCode",{parentName:"td"},"segmentSortOrder")," set to ",(0,l.kt)("inlineCode",{parentName:"td"},"__time,city,country"),". Within each time chunk, Druid assigns rows to segments based on ",(0,l.kt)("inlineCode",{parentName:"td"},"country"),", and then within each of those segments, Druid sorts those rows by ",(0,l.kt)("inlineCode",{parentName:"td"},"__time")," first, then ",(0,l.kt)("inlineCode",{parentName:"td"},"city"),", then ",(0,l.kt)("inlineCode",{parentName:"td"},"country"),"."),(0,l.kt)("td",{parentName:"tr",align:null},"empty list")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"forceSegmentSortByTime")),(0,l.kt)("td",{parentName:"tr",align:null},"INSERT or REPLACE",(0,l.kt)("br",null),(0,l.kt)("br",null),"When set to ",(0,l.kt)("inlineCode",{parentName:"td"},"true")," (the default), Druid prepends ",(0,l.kt)("inlineCode",{parentName:"td"},"__time")," to ",(0,l.kt)("a",{parentName:"td",href:"#clustered-by"},"CLUSTERED BY")," when determining the sort order for individual segments. Druid also requires that ",(0,l.kt)("inlineCode",{parentName:"td"},"segmentSortOrder"),", if provided, starts with ",(0,l.kt)("inlineCode",{parentName:"td"},"__time"),".",(0,l.kt)("br",null),(0,l.kt)("br",null),"When set to ",(0,l.kt)("inlineCode",{parentName:"td"},"false"),", Druid uses the ",(0,l.kt)("a",{parentName:"td",href:"#clustered-by"},"CLUSTERED BY")," alone to determine the sort order for individual segments, and does not require that ",(0,l.kt)("inlineCode",{parentName:"td"},"segmentSortOrder")," begin with ",(0,l.kt)("inlineCode",{parentName:"td"},"__time"),". Setting this parameter to ",(0,l.kt)("inlineCode",{parentName:"td"},"false")," is an experimental feature; see ",(0,l.kt)("a",{parentName:"td",href:"../ingestion/partitioning#sorting"},"Sorting")," for details."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"true"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"maxParseExceptions")),(0,l.kt)("td",{parentName:"tr",align:null},"SELECT, INSERT, REPLACE",(0,l.kt)("br",null),(0,l.kt)("br",null),"Maximum number of parse exceptions that are ignored while executing the query before it stops with ",(0,l.kt)("inlineCode",{parentName:"td"},"TooManyWarningsFault"),". To ignore all the parse exceptions, set the value to -1."),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"rowsPerSegment")),(0,l.kt)("td",{parentName:"tr",align:null},"INSERT or REPLACE",(0,l.kt)("br",null),(0,l.kt)("br",null),"The number of rows per segment to target. The actual number of rows per segment may be somewhat higher or lower than this number. In most cases, use the default. For general information about sizing rows per segment, see ",(0,l.kt)("a",{parentName:"td",href:"/docs/32.0.0/operations/segment-optimization"},"Segment Size Optimization"),"."),(0,l.kt)("td",{parentName:"tr",align:null},"3,000,000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"indexSpec")),(0,l.kt)("td",{parentName:"tr",align:null},"INSERT or REPLACE",(0,l.kt)("br",null),(0,l.kt)("br",null),"An ",(0,l.kt)("a",{parentName:"td",href:"/docs/32.0.0/ingestion/ingestion-spec#indexspec"},(0,l.kt)("inlineCode",{parentName:"a"},"indexSpec"))," to use when generating segments. May be a JSON string or object. See ",(0,l.kt)("a",{parentName:"td",href:"/docs/32.0.0/ingestion/ingestion-spec#front-coding"},"Front coding")," for details on configuring an ",(0,l.kt)("inlineCode",{parentName:"td"},"indexSpec")," with front coding."),(0,l.kt)("td",{parentName:"tr",align:null},"See ",(0,l.kt)("a",{parentName:"td",href:"/docs/32.0.0/ingestion/ingestion-spec#indexspec"},(0,l.kt)("inlineCode",{parentName:"a"},"indexSpec")),".")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"durableShuffleStorage")),(0,l.kt)("td",{parentName:"tr",align:null},"SELECT, INSERT, REPLACE ",(0,l.kt)("br",null),(0,l.kt)("br",null),"Whether to use durable storage for shuffle mesh. To use this feature, configure the durable storage at the server level using ",(0,l.kt)("inlineCode",{parentName:"td"},"druid.msq.intermediate.storage.enable=true"),"). If these properties are not configured, any query with the context variable ",(0,l.kt)("inlineCode",{parentName:"td"},"durableShuffleStorage=true")," fails with a configuration error. ",(0,l.kt)("br",null),(0,l.kt)("br",null)),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"false"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"faultTolerance")),(0,l.kt)("td",{parentName:"tr",align:null},"SELECT, INSERT, REPLACE",(0,l.kt)("br",null),(0,l.kt)("br",null)," Whether to turn on fault tolerance mode or not. Failed workers are retried based on ",(0,l.kt)("a",{parentName:"td",href:"#limits"},"Limits"),". Cannot be used when ",(0,l.kt)("inlineCode",{parentName:"td"},"durableShuffleStorage")," is explicitly set to false."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"false"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"selectDestination")),(0,l.kt)("td",{parentName:"tr",align:null},"SELECT",(0,l.kt)("br",null),(0,l.kt)("br",null)," Controls where the final result of the select query is written. ",(0,l.kt)("br",null),"Use ",(0,l.kt)("inlineCode",{parentName:"td"},"taskReport"),"(the default) to write select results to the task report. ",(0,l.kt)("b",null," This is not scalable since task reports size explodes for large results ")," ",(0,l.kt)("br",null),"Use ",(0,l.kt)("inlineCode",{parentName:"td"},"durableStorage")," to write results to durable storage location. ",(0,l.kt)("b",null,"For large results sets, its recommended to use ",(0,l.kt)("inlineCode",{parentName:"td"},"durableStorage")," "),". To configure durable storage see ",(0,l.kt)("a",{parentName:"td",href:"#durable-storage"},(0,l.kt)("inlineCode",{parentName:"a"},"this"))," section."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"taskReport"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"waitUntilSegmentsLoad")),(0,l.kt)("td",{parentName:"tr",align:null},"INSERT, REPLACE",(0,l.kt)("br",null),(0,l.kt)("br",null)," If set, the ingest query waits for the generated segments to be loaded before exiting, else the ingest query exits without waiting. The task and live reports contain the information about the status of loading segments if this flag is set. This will ensure that any future queries made after the ingestion exits will include results from the ingestion. The drawback is that the controller task will stall till the segments are loaded."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"false"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"includeSegmentSource")),(0,l.kt)("td",{parentName:"tr",align:null},"SELECT, INSERT, REPLACE",(0,l.kt)("br",null),(0,l.kt)("br",null)," Controls the sources, which will be queried for results in addition to the segments present on deep storage. Can be ",(0,l.kt)("inlineCode",{parentName:"td"},"NONE")," or ",(0,l.kt)("inlineCode",{parentName:"td"},"REALTIME"),". If this value is ",(0,l.kt)("inlineCode",{parentName:"td"},"NONE"),", only non-realtime (published and used) segments will be downloaded from deep storage. If this value is ",(0,l.kt)("inlineCode",{parentName:"td"},"REALTIME"),", results will also be included from realtime tasks. ",(0,l.kt)("inlineCode",{parentName:"td"},"REALTIME")," cannot be used while writing data into the same datasource it is read from."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"NONE"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"rowsPerPage")),(0,l.kt)("td",{parentName:"tr",align:null},"SELECT",(0,l.kt)("br",null),(0,l.kt)("br",null),"The number of rows per page to target. The actual number of rows per page may be somewhat higher or lower than this number. In most cases, use the default.",(0,l.kt)("br",null)," This property comes into effect only when ",(0,l.kt)("inlineCode",{parentName:"td"},"selectDestination")," is set to ",(0,l.kt)("inlineCode",{parentName:"td"},"durableStorage")),(0,l.kt)("td",{parentName:"tr",align:null},"100000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"skipTypeVerification")),(0,l.kt)("td",{parentName:"tr",align:null},"INSERT or REPLACE",(0,l.kt)("br",null),(0,l.kt)("br",null),"During query validation, Druid validates that ",(0,l.kt)("a",{parentName:"td",href:"/docs/32.0.0/querying/arrays"},"string arrays")," and ",(0,l.kt)("a",{parentName:"td",href:"/docs/32.0.0/querying/multi-value-dimensions"},"multi-value dimensions")," are not mixed in the same column. If you are intentionally migrating from one to the other, use this context parameter to disable type validation.",(0,l.kt)("br",null),(0,l.kt)("br",null),"Provide the column list as comma-separated values or as a JSON array in string form."),(0,l.kt)("td",{parentName:"tr",align:null},"empty list")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"failOnEmptyInsert")),(0,l.kt)("td",{parentName:"tr",align:null},"INSERT or REPLACE",(0,l.kt)("br",null),(0,l.kt)("br",null)," When set to false (the default), an INSERT query generating no output rows will be no-op, and a REPLACE query generating no output rows will delete all data that matches the OVERWRITE clause.  When set to true, an ingest query generating no output rows will throw an ",(0,l.kt)("inlineCode",{parentName:"td"},"InsertCannotBeEmpty")," fault."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"false"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"storeCompactionState")),(0,l.kt)("td",{parentName:"tr",align:null},"REPLACE",(0,l.kt)("br",null),(0,l.kt)("br",null)," When set to true, a REPLACE query stores as part of each segment's metadata a ",(0,l.kt)("inlineCode",{parentName:"td"},"lastCompactionState")," field that captures the various specs used to create the segment. Future compaction jobs skip segments whose ",(0,l.kt)("inlineCode",{parentName:"td"},"lastCompactionState")," matches the desired compaction state. Works the same as ",(0,l.kt)("a",{parentName:"td",href:"/docs/32.0.0/ingestion/tasks#context-parameters"},(0,l.kt)("inlineCode",{parentName:"a"},"storeCompactionState"))," task context flag."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"false"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"removeNullBytes")),(0,l.kt)("td",{parentName:"tr",align:null},"SELECT, INSERT or REPLACE",(0,l.kt)("br",null),(0,l.kt)("br",null)," The MSQ engine cannot process null bytes in strings and throws ",(0,l.kt)("inlineCode",{parentName:"td"},"InvalidNullByteFault")," if it encounters them in the source data. If the parameter is set to true, The MSQ engine will remove the null bytes in string fields when reading the data."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"false"))))),(0,l.kt)("h2",{id:"joins"},"Joins"),(0,l.kt)("p",null,"Joins in multi-stage queries use one of two algorithms based on what you set the ",(0,l.kt)("a",{parentName:"p",href:"#context-parameters"},"context parameter")," ",(0,l.kt)("inlineCode",{parentName:"p"},"sqlJoinAlgorithm")," to: "),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"#broadcast"},(0,l.kt)("inlineCode",{parentName:"a"},"broadcast"))," (default) "),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"#sort-merge"},(0,l.kt)("inlineCode",{parentName:"a"},"sortMerge")),".")),(0,l.kt)("p",null,"If you omit this context parameter, the MSQ task engine uses broadcast since it's the default join algorithm. The context parameter applies to the entire SQL statement, so you can't mix different\njoin algorithms in the same query."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"sqlJoinAlgorithm")," is a hint to the planner to execute the join in the specified manner. The planner can decide to ignore\nthe hint if it deduces that the specified algorithm can be detrimental to the performance of the join beforehand. This intelligence\nis very limited as of now, and the ",(0,l.kt)("inlineCode",{parentName:"p"},"sqlJoinAlgorithm")," set would be respected in most cases, therefore the user should set it\nappropriately. See the advantages and the drawbacks for the ",(0,l.kt)("a",{parentName:"p",href:"#broadcast"},"broadcast")," and the ",(0,l.kt)("a",{parentName:"p",href:"#sort-merge"},"sort-merge")," join to\ndetermine which join to use beforehand."),(0,l.kt)("h3",{id:"broadcast"},"Broadcast"),(0,l.kt)("p",null,"The default join algorithm for multi-stage queries is a broadcast hash join, which is similar to how\n",(0,l.kt)("a",{parentName:"p",href:"/docs/32.0.0/querying/query-execution#join"},"joins are executed with native queries"),". "),(0,l.kt)("p",null,"To use broadcast joins, either omit the  ",(0,l.kt)("inlineCode",{parentName:"p"},"sqlJoinAlgorithm")," or set it to ",(0,l.kt)("inlineCode",{parentName:"p"},"broadcast"),"."),(0,l.kt)("p",null,'For a broadcast join, any adjacent joins are flattened\ninto a structure with a "base" input (the bottom-leftmost one) and other leaf inputs (the rest). Next, any subqueries\nthat are inputs the join (either base or other leafs) are planned into independent stages. Then, the non-base leaf\ninputs are all connected as broadcast inputs to the "base" stage.'),(0,l.kt)("p",null,"Together, all of these non-base leaf inputs must not exceed the ",(0,l.kt)("a",{parentName:"p",href:"#limits"},"limit on broadcast table footprint"),". There\nis no limit on the size of the base (leftmost) input."),(0,l.kt)("p",null,"Only LEFT JOIN, INNER JOIN, and CROSS JOIN are supported with ",(0,l.kt)("inlineCode",{parentName:"p"},"broadcast"),"."),(0,l.kt)("p",null,"Join conditions, if present, must be equalities. It is not necessary to include a join condition; for example,\n",(0,l.kt)("inlineCode",{parentName:"p"},"CROSS JOIN")," and comma join do not require join conditions."),(0,l.kt)("p",null,"The following example has a single join chain where ",(0,l.kt)("inlineCode",{parentName:"p"},"orders")," is the base input while ",(0,l.kt)("inlineCode",{parentName:"p"},"products")," and\n",(0,l.kt)("inlineCode",{parentName:"p"},"customers")," are non-base leaf inputs. The broadcast inputs (",(0,l.kt)("inlineCode",{parentName:"p"},"products")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"customers"),") must fall under the limit on broadcast table footprint, but the base ",(0,l.kt)("inlineCode",{parentName:"p"},"orders")," input\ncan be unlimited in size."),(0,l.kt)("p",null,"The query reads ",(0,l.kt)("inlineCode",{parentName:"p"},"products")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"customers")," and then broadcasts both to\nthe stage that reads ",(0,l.kt)("inlineCode",{parentName:"p"},"orders"),". That stage loads the broadcast inputs (",(0,l.kt)("inlineCode",{parentName:"p"},"products")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"customers"),") in memory and walks\nthrough ",(0,l.kt)("inlineCode",{parentName:"p"},"orders")," row by row. The results are aggregated and written to the table ",(0,l.kt)("inlineCode",{parentName:"p"},"orders_enriched"),". "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"REPLACE INTO orders_enriched\nOVERWRITE ALL\nSELECT\n  orders.__time,\n  products.name AS product_name,\n  customers.name AS customer_name,\n  SUM(orders.amount) AS amount\nFROM orders\nLEFT JOIN products ON orders.product_id = products.id\nLEFT JOIN customers ON orders.customer_id = customers.id\nGROUP BY 1, 2\nPARTITIONED BY HOUR\nCLUSTERED BY product_name\n")),(0,l.kt)("h3",{id:"sort-merge"},"Sort-merge"),(0,l.kt)("p",null,"You can use the sort-merge join algorithm to make queries more scalable at the cost of performance. If your goal is performance, consider ",(0,l.kt)("a",{parentName:"p",href:"#broadcast"},"broadcast joins"),".  There are various scenarios where broadcast join would return a ",(0,l.kt)("a",{parentName:"p",href:"#error-codes"},(0,l.kt)("inlineCode",{parentName:"a"},"BroadcastTablesTooLarge"))," error, but a sort-merge join would succeed."),(0,l.kt)("p",null,"To use the sort-merge join algorithm, set the context parameter ",(0,l.kt)("inlineCode",{parentName:"p"},"sqlJoinAlgorithm")," to ",(0,l.kt)("inlineCode",{parentName:"p"},"sortMerge"),"."),(0,l.kt)("p",null,"In a sort-merge join, each pairwise join is planned into its own stage with two inputs. The two inputs are partitioned and sorted using a hash partitioning on the same key. "),(0,l.kt)("p",null,"When using the sort-merge algorithm, keep the following in mind:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"There is no limit on the overall size of either input, so sort-merge is a good choice for performing a join of two large inputs or for performing a self-join of a large input with itself.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"There is a limit on the amount of data associated with each individual key. If ",(0,l.kt)("em",{parentName:"p"},"both")," sides of the join exceed this limit, the query returns a ",(0,l.kt)("a",{parentName:"p",href:"#error-codes"},(0,l.kt)("inlineCode",{parentName:"a"},"TooManyRowsWithSameKey"))," error. If only one side exceeds the limit, the query does not return this error.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Join conditions are optional but must be equalities if they are present. For example, ",(0,l.kt)("inlineCode",{parentName:"p"},"CROSS JOIN")," and comma join do not require join conditions.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"All join types are supported with ",(0,l.kt)("inlineCode",{parentName:"p"},"sortMerge"),": LEFT, RIGHT, INNER, FULL, and CROSS."))),(0,l.kt)("p",null,"The following example  runs using a single sort-merge join stage that receives ",(0,l.kt)("inlineCode",{parentName:"p"},"eventstream"),"\n(partitioned on ",(0,l.kt)("inlineCode",{parentName:"p"},"user_id"),") and ",(0,l.kt)("inlineCode",{parentName:"p"},"users")," (partitioned on ",(0,l.kt)("inlineCode",{parentName:"p"},"id"),") as inputs. There is no limit on the size of either input."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"REPLACE INTO eventstream_enriched\nOVERWRITE ALL\nSELECT\n  eventstream.__time,\n  eventstream.user_id,\n  eventstream.event_type,\n  eventstream.event_details,\n  users.signup_date AS user_signup_date\nFROM eventstream\nLEFT JOIN users ON eventstream.user_id = users.id\nPARTITIONED BY HOUR\nCLUSTERED BY user\n")),(0,l.kt)("p",null,"The context parameter that sets ",(0,l.kt)("inlineCode",{parentName:"p"},"sqlJoinAlgorithm")," to ",(0,l.kt)("inlineCode",{parentName:"p"},"sortMerge")," is not shown in the above example."),(0,l.kt)("h2",{id:"durable-storage"},"Durable storage"),(0,l.kt)("p",null,"SQL-based ingestion supports using durable storage to store intermediate files temporarily. Enabling it can improve reliability. For more information, see ",(0,l.kt)("a",{parentName:"p",href:"/docs/32.0.0/operations/durable-storage"},"Durable storage"),"."),(0,l.kt)("h3",{id:"durable-storage-configurations"},"Durable storage configurations"),(0,l.kt)("p",null,"Durable storage is supported on Amazon S3 storage, Microsoft's Azure Blob Storage and Google Cloud Storage.\nThere are common configurations that control the behavior regardless of which storage service you use. Apart from these common configurations, there are a few properties specific to S3 and to Azure."),(0,l.kt)("p",null,"Common properties to configure the behavior of durable storage"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"druid.msq.intermediate.storage.enable")),(0,l.kt)("td",{parentName:"tr",align:null},"Yes"),(0,l.kt)("td",{parentName:"tr",align:null},"Whether to enable durable storage for the cluster. Set it to true to enable durable storage. For more information about enabling durable storage, see ",(0,l.kt)("a",{parentName:"td",href:"/docs/32.0.0/operations/durable-storage"},"Durable storage"),".")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"druid.msq.intermediate.storage.type")),(0,l.kt)("td",{parentName:"tr",align:null},"Yes"),(0,l.kt)("td",{parentName:"tr",align:null},"The type of storage to use. Set it to ",(0,l.kt)("inlineCode",{parentName:"td"},"s3")," for S3, ",(0,l.kt)("inlineCode",{parentName:"td"},"azure")," for Azure and ",(0,l.kt)("inlineCode",{parentName:"td"},"google")," for Google")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"druid.msq.intermediate.storage.tempDir")),(0,l.kt)("td",{parentName:"tr",align:null},"Yes"),(0,l.kt)("td",{parentName:"tr",align:null},"Directory path on the local disk to store temporary files required while uploading and downloading the data. If the property is not configured on the indexer or middle manager, it defaults to using the task temporary directory.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"druid.msq.intermediate.storage.maxRetry")),(0,l.kt)("td",{parentName:"tr",align:null},"No"),(0,l.kt)("td",{parentName:"tr",align:null},"Defines the max number times to attempt S3 API calls to avoid failures due to transient errors.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"druid.msq.intermediate.storage.chunkSize")),(0,l.kt)("td",{parentName:"tr",align:null},"No"),(0,l.kt)("td",{parentName:"tr",align:null},"Defines the size of each chunk to temporarily store in ",(0,l.kt)("inlineCode",{parentName:"td"},"druid.msq.intermediate.storage.tempDir"),". The chunk size must be between 5 MiB and 5 GiB. A large chunk size reduces the API calls made to the durable storage, however it requires more disk space to store the temporary chunks. Druid uses a default of 100MiB if the value is not provided.")))),(0,l.kt)("p",null,"To use S3 or Google for durable storage, you also need to configure the following properties:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"druid.msq.intermediate.storage.bucket")),(0,l.kt)("td",{parentName:"tr",align:null},"Yes"),(0,l.kt)("td",{parentName:"tr",align:null},"The S3 or Google bucket where the files are uploaded to and download from"),(0,l.kt)("td",{parentName:"tr",align:null},"n/a")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"druid.msq.intermediate.storage.prefix")),(0,l.kt)("td",{parentName:"tr",align:null},"Yes"),(0,l.kt)("td",{parentName:"tr",align:null},"Path prepended to all the paths uploaded to the bucket to namespace the connector's files. Provide a unique value for the prefix and do not share the same prefix between different clusters. If the location includes other files or directories, then they might get cleaned up as well."),(0,l.kt)("td",{parentName:"tr",align:null},"n/a")))),(0,l.kt)("p",null,"To use Azure for durable storage, you also need to configure the following properties:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"druid.msq.intermediate.storage.container")),(0,l.kt)("td",{parentName:"tr",align:null},"Yes"),(0,l.kt)("td",{parentName:"tr",align:null},"The Azure container where the files are uploaded to and downloaded from."),(0,l.kt)("td",{parentName:"tr",align:null},"n/a")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"druid.msq.intermediate.storage.prefix")),(0,l.kt)("td",{parentName:"tr",align:null},"Yes"),(0,l.kt)("td",{parentName:"tr",align:null},"Path prepended to all the paths uploaded to the container to namespace the connector's files. Provide a unique value for the prefix and do not share the same prefix between different clusters. If the location includes other files or directories, then they might get cleaned up as well."),(0,l.kt)("td",{parentName:"tr",align:null},"n/a")))),(0,l.kt)("h3",{id:"durable-storage-cleaner-configurations"},"Durable storage cleaner configurations"),(0,l.kt)("p",null,"Durable storage creates files on the remote storage, and these files get cleaned up once a job no longer requires those files. However, due to failures causing abrupt exits of tasks, these files might not get cleaned up.\nYou can configure the Overlord to periodically clean up these intermediate files after a task completes and the files are no longer need. The files that get cleaned up are determined by the storage prefix you configure. Any files that match the path for the storage prefix may get cleaned up, not just intermediate files that are no longer needed."),(0,l.kt)("p",null,"Use the following configurations to control the cleaner:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"druid.msq.intermediate.storage.cleaner.enabled")),(0,l.kt)("td",{parentName:"tr",align:null},"No"),(0,l.kt)("td",{parentName:"tr",align:null},"Whether durable storage cleaner should be enabled for the cluster."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"druid.msq.intermediate.storage.cleaner.delaySeconds")),(0,l.kt)("td",{parentName:"tr",align:null},"No"),(0,l.kt)("td",{parentName:"tr",align:null},"The delay (in seconds) after the latest run post which the durable storage cleaner cleans the up files."),(0,l.kt)("td",{parentName:"tr",align:null},"86400")))),(0,l.kt)("h2",{id:"limits"},"Limits"),(0,l.kt)("p",null,"Knowing the limits for the MSQ task engine can help you troubleshoot any ",(0,l.kt)("a",{parentName:"p",href:"#error-codes"},"errors")," that you encounter. Many of the errors occur as a result of reaching a limit."),(0,l.kt)("p",null,"The following table lists query limits:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Limit"),(0,l.kt)("th",{parentName:"tr",align:null},"Value"),(0,l.kt)("th",{parentName:"tr",align:null},"Error if exceeded"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Size of an individual row written to a frame. Row size when written to a frame may differ from the original row size."),(0,l.kt)("td",{parentName:"tr",align:null},"1 MB"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{parentName:"td",href:"#error_RowTooLarge"},(0,l.kt)("inlineCode",{parentName:"a"},"RowTooLarge")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Number of segment-granular time chunks encountered during ingestion."),(0,l.kt)("td",{parentName:"tr",align:null},"5,000"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{parentName:"td",href:"#error_TooManyBuckets"},(0,l.kt)("inlineCode",{parentName:"a"},"TooManyBuckets")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Number of input files/segments per worker."),(0,l.kt)("td",{parentName:"tr",align:null},"10,000"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{parentName:"td",href:"#error_TooManyInputFiles"},(0,l.kt)("inlineCode",{parentName:"a"},"TooManyInputFiles")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Number of output partitions for any one stage. Number of segments generated during ingestion."),(0,l.kt)("td",{parentName:"tr",align:null},"25,000"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{parentName:"td",href:"#error_TooManyPartitions"},(0,l.kt)("inlineCode",{parentName:"a"},"TooManyPartitions")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Number of output columns for any one stage."),(0,l.kt)("td",{parentName:"tr",align:null},"2,000"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{parentName:"td",href:"#error_TooManyColumns"},(0,l.kt)("inlineCode",{parentName:"a"},"TooManyColumns")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Number of cluster by columns that can appear in a stage"),(0,l.kt)("td",{parentName:"tr",align:null},"1,500"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{parentName:"td",href:"#error_TooManyClusteredByColumns"},(0,l.kt)("inlineCode",{parentName:"a"},"TooManyClusteredByColumns")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Number of workers for any one stage."),(0,l.kt)("td",{parentName:"tr",align:null},"Hard limit is 1,000. Memory-dependent soft limit may be lower."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{parentName:"td",href:"#error_TooManyWorkers"},(0,l.kt)("inlineCode",{parentName:"a"},"TooManyWorkers")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Maximum memory occupied by broadcasted tables."),(0,l.kt)("td",{parentName:"tr",align:null},"30% of each ",(0,l.kt)("a",{parentName:"td",href:"/docs/32.0.0/multi-stage-query/concepts#memory-usage"},"processor memory bundle"),"."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{parentName:"td",href:"#error_BroadcastTablesTooLarge"},(0,l.kt)("inlineCode",{parentName:"a"},"BroadcastTablesTooLarge")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Maximum memory occupied by buffered data during sort-merge join. Only relevant when ",(0,l.kt)("inlineCode",{parentName:"td"},"sqlJoinAlgorithm")," is ",(0,l.kt)("inlineCode",{parentName:"td"},"sortMerge"),"."),(0,l.kt)("td",{parentName:"tr",align:null},"10 MB"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"TooManyRowsWithSameKey"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Maximum relaunch attempts per worker. Initial run is not a relaunch. The worker will be spawned 1 + ",(0,l.kt)("inlineCode",{parentName:"td"},"workerRelaunchLimit")," times before the job fails."),(0,l.kt)("td",{parentName:"tr",align:null},"2"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"TooManyAttemptsForWorker"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Maximum relaunch attempts for a job across all workers."),(0,l.kt)("td",{parentName:"tr",align:null},"100"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"TooManyAttemptsForJob"))))),(0,l.kt)("a",{name:"errors"}),(0,l.kt)("h2",{id:"error-codes"},"Error codes"),(0,l.kt)("p",null,"The following table describes error codes you may encounter in the ",(0,l.kt)("inlineCode",{parentName:"p"},"multiStageQuery.payload.status.errorReport.error.errorCode")," field:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Code"),(0,l.kt)("th",{parentName:"tr",align:null},"Meaning"),(0,l.kt)("th",{parentName:"tr",align:null},"Additional fields"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{name:"error_BroadcastTablesTooLarge"},(0,l.kt)("inlineCode",{parentName:"td"},"BroadcastTablesTooLarge"))),(0,l.kt)("td",{parentName:"tr",align:null},"The size of the broadcast tables used in the right hand side of the join exceeded the memory reserved for them in a worker task.",(0,l.kt)("br",null),(0,l.kt)("br",null),"Try increasing the peon memory or reducing the size of the broadcast tables."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"maxBroadcastTablesSize"),": Memory reserved for the broadcast tables, measured in bytes.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{name:"error_Canceled"},(0,l.kt)("inlineCode",{parentName:"td"},"Canceled"))),(0,l.kt)("td",{parentName:"tr",align:null},"The query was canceled. Common reasons for cancellation:",(0,l.kt)("br",null),(0,l.kt)("br",null),(0,l.kt)("ul",null,(0,l.kt)("li",null,"User-initiated shutdown of the controller task via the ",(0,l.kt)("inlineCode",{parentName:"td"},"/druid/indexer/v1/task/{taskId}/shutdown")," API."),(0,l.kt)("li",null,"Restart or failure of the server process that was running the controller task."))),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{name:"error_CannotParseExternalData"},(0,l.kt)("inlineCode",{parentName:"td"},"CannotParseExternalData"))),(0,l.kt)("td",{parentName:"tr",align:null},"A worker task could not parse data from an external datasource."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"errorMessage"),": More details on why parsing failed.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{name:"error_ColumnNameRestricted"},(0,l.kt)("inlineCode",{parentName:"td"},"ColumnNameRestricted"))),(0,l.kt)("td",{parentName:"tr",align:null},"The query uses a restricted column name."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"columnName"),": The restricted column name.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{name:"error_ColumnTypeNotSupported"},(0,l.kt)("inlineCode",{parentName:"td"},"ColumnTypeNotSupported"))),(0,l.kt)("td",{parentName:"tr",align:null},"The column type is not supported. This can be because:",(0,l.kt)("br",null)," ",(0,l.kt)("br",null),(0,l.kt)("ul",null,(0,l.kt)("li",null,"Support for writing or reading from a particular column type is not supported."),(0,l.kt)("li",null,"The query attempted to use a column type that is not supported by the frame format. This occurs with ARRAY types, which are not yet implemented for frames."))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"columnName"),": The column name with an unsupported type.",(0,l.kt)("br",null)," ",(0,l.kt)("br",null),(0,l.kt)("inlineCode",{parentName:"td"},"columnType"),": The unknown column type.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{name:"error_InsertCannotAllocateSegment"},(0,l.kt)("inlineCode",{parentName:"td"},"InsertCannotAllocateSegment"))),(0,l.kt)("td",{parentName:"tr",align:null},"The controller task could not allocate a new segment ID due to conflict with existing segments or pending segments. Common reasons for such conflicts:",(0,l.kt)("br",null)," ",(0,l.kt)("br",null),(0,l.kt)("ul",null,(0,l.kt)("li",null,"Attempting to mix different granularities in the same intervals of the same datasource."),(0,l.kt)("li",null,"Prior ingestions that used non-extendable shard specs."))," ",(0,l.kt)("br",null)," ",(0,l.kt)("br",null)," Use REPLACE to overwrite the existing data or if the error contains the ",(0,l.kt)("inlineCode",{parentName:"td"},"allocatedInterval")," then alternatively rerun the INSERT job with the mentioned granularity to append to existing data. Note that it might not always be possible to append to the existing data using INSERT and can only be done if ",(0,l.kt)("inlineCode",{parentName:"td"},"allocatedInterval")," is present."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"dataSource"),(0,l.kt)("br",null)," ",(0,l.kt)("br",null),(0,l.kt)("inlineCode",{parentName:"td"},"interval"),": The interval for the attempted new segment allocation. ",(0,l.kt)("br",null)," ",(0,l.kt)("br",null)," ",(0,l.kt)("inlineCode",{parentName:"td"},"allocatedInterval"),": The incorrect interval allocated by the overlord. It can be null")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{name:"error_InsertCannotBeEmpty"},(0,l.kt)("inlineCode",{parentName:"td"},"InsertCannotBeEmpty"))),(0,l.kt)("td",{parentName:"tr",align:null},"An INSERT or REPLACE query did not generate any output rows when ",(0,l.kt)("inlineCode",{parentName:"td"},"failOnEmptyInsert")," query context is set to true. ",(0,l.kt)("inlineCode",{parentName:"td"},"failOnEmptyInsert")," defaults to false, so an INSERT query generating no output rows will be no-op, and a REPLACE query generating no output rows will delete all data that matches the OVERWRITE clause."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"dataSource"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{name:"error_InsertLockPreempted"},(0,l.kt)("inlineCode",{parentName:"td"},"InsertLockPreempted"))),(0,l.kt)("td",{parentName:"tr",align:null},"An INSERT or REPLACE query was canceled by a higher-priority ingestion job, such as a real-time ingestion task."),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{name:"error_InsertTimeNull"},(0,l.kt)("inlineCode",{parentName:"td"},"InsertTimeNull"))),(0,l.kt)("td",{parentName:"tr",align:null},"An INSERT or REPLACE query encountered a null timestamp in the ",(0,l.kt)("inlineCode",{parentName:"td"},"__time")," field.",(0,l.kt)("br",null),(0,l.kt)("br",null),"This can happen due to using an expression like ",(0,l.kt)("inlineCode",{parentName:"td"},"TIME_PARSE(timestamp) AS __time")," with a timestamp that cannot be parsed. (",(0,l.kt)("a",{parentName:"td",href:"/docs/32.0.0/querying/sql-scalar#date-and-time-functions"},(0,l.kt)("inlineCode",{parentName:"a"},"TIME_PARSE"))," returns null when it cannot parse a timestamp.) In this case, try parsing your timestamps using a different function or pattern. Or, if your timestamps may genuinely be null, consider using ",(0,l.kt)("a",{parentName:"td",href:"/docs/32.0.0/querying/sql-scalar#other-scalar-functions"},(0,l.kt)("inlineCode",{parentName:"a"},"COALESCE"))," to provide a default value. One option is ",(0,l.kt)("a",{parentName:"td",href:"/docs/32.0.0/querying/sql-scalar#date-and-time-functions"},(0,l.kt)("inlineCode",{parentName:"a"},"CURRENT_TIMESTAMP")),", which represents the start time of the job."),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{name:"error_InsertTimeOutOfBounds"},(0,l.kt)("inlineCode",{parentName:"td"},"InsertTimeOutOfBounds"))),(0,l.kt)("td",{parentName:"tr",align:null},"A REPLACE query generated a timestamp outside the bounds of the TIMESTAMP parameter for your OVERWRITE WHERE clause.",(0,l.kt)("br",null)," ",(0,l.kt)("br",null),"To avoid this error, verify that the you specified is valid."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"interval"),": time chunk interval corresponding to the out-of-bounds timestamp")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{name:"error_InvalidField"},(0,l.kt)("inlineCode",{parentName:"td"},"InvalidField"))),(0,l.kt)("td",{parentName:"tr",align:null},"An error was encountered while writing a field."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"error"),": Encountered error. ",(0,l.kt)("br",null),(0,l.kt)("br",null)," ",(0,l.kt)("inlineCode",{parentName:"td"},"source"),": Source for the error. ",(0,l.kt)("br",null),(0,l.kt)("br",null)," ",(0,l.kt)("inlineCode",{parentName:"td"},"rowNumber"),": Row number (1-indexed) for the error. ",(0,l.kt)("br",null),(0,l.kt)("br",null)," ",(0,l.kt)("inlineCode",{parentName:"td"},"column"),": Column for the error.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{name:"error_InvalidNullByte"},(0,l.kt)("inlineCode",{parentName:"td"},"InvalidNullByte"))),(0,l.kt)("td",{parentName:"tr",align:null},"A string column included a null byte. Null bytes in strings are not permitted."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"source"),": The source that included the null byte ",(0,l.kt)("br",null),(0,l.kt)("br",null)," ",(0,l.kt)("inlineCode",{parentName:"td"},"rowNumber"),": The row number (1-indexed) that included the null byte ",(0,l.kt)("br",null),(0,l.kt)("br",null)," ",(0,l.kt)("inlineCode",{parentName:"td"},"column"),": The column that included the null byte ",(0,l.kt)("br",null),(0,l.kt)("br",null)," ",(0,l.kt)("inlineCode",{parentName:"td"},"value"),": Actual string containing the null byte ",(0,l.kt)("br",null),(0,l.kt)("br",null)," ",(0,l.kt)("inlineCode",{parentName:"td"},"position"),": Position (1-indexed) of occurrence of null byte")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{name:"error_QueryNotSupported"},(0,l.kt)("inlineCode",{parentName:"td"},"QueryNotSupported"))),(0,l.kt)("td",{parentName:"tr",align:null},"QueryKit could not translate the provided native query to a multi-stage query.",(0,l.kt)("br",null)," ",(0,l.kt)("br",null),"This can happen if the query uses features that aren't supported, like GROUPING SETS."),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{name:"error_QueryRuntimeError"},(0,l.kt)("inlineCode",{parentName:"td"},"QueryRuntimeError"))),(0,l.kt)("td",{parentName:"tr",align:null},"MSQ uses the native query engine to run the leaf stages. This error tells MSQ that error is in native query runtime.",(0,l.kt)("br",null)," ",(0,l.kt)("br",null)," Since this is a generic error, the user needs to look at logs for the error message and stack trace to figure out the next course of action. If the user is stuck, consider raising a ",(0,l.kt)("inlineCode",{parentName:"td"},"github")," issue for assistance."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"baseErrorMessage")," error message from the native query runtime.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{name:"error_RowTooLarge"},(0,l.kt)("inlineCode",{parentName:"td"},"RowTooLarge"))),(0,l.kt)("td",{parentName:"tr",align:null},"The query tried to process a row that was too large to write to a single frame. See the ",(0,l.kt)("a",{parentName:"td",href:"#limits"},"Limits")," table for specific limits on frame size. Note that the effective maximum row size is smaller than the maximum frame size due to alignment considerations during frame writing."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"maxFrameSize"),": The limit on the frame size.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{name:"error_TaskStartTimeout"},(0,l.kt)("inlineCode",{parentName:"td"},"TaskStartTimeout"))),(0,l.kt)("td",{parentName:"tr",align:null},"Unable to launch ",(0,l.kt)("inlineCode",{parentName:"td"},"pendingTasks")," worker out of total ",(0,l.kt)("inlineCode",{parentName:"td"},"totalTasks")," workers tasks within ",(0,l.kt)("inlineCode",{parentName:"td"},"timeout")," seconds of the last successful worker launch.",(0,l.kt)("br",null),(0,l.kt)("br",null),"There may be insufficient available slots to start all the worker tasks simultaneously. Try splitting up your query into smaller chunks using a smaller value of ",(0,l.kt)("a",{parentName:"td",href:"#context-parameters"},(0,l.kt)("inlineCode",{parentName:"a"},"maxNumTasks")),". Another option is to increase capacity."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"pendingTasks"),": Number of tasks not yet started.",(0,l.kt)("br",null),(0,l.kt)("br",null),(0,l.kt)("inlineCode",{parentName:"td"},"totalTasks"),": The number of tasks attempted to launch.",(0,l.kt)("br",null),(0,l.kt)("br",null),(0,l.kt)("inlineCode",{parentName:"td"},"timeout"),": Timeout, in milliseconds, that was exceeded.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{name:"error_TooManyAttemptsForJob"},(0,l.kt)("inlineCode",{parentName:"td"},"TooManyAttemptsForJob"))),(0,l.kt)("td",{parentName:"tr",align:null},"Total relaunch attempt count across all workers exceeded max relaunch attempt limit. See the ",(0,l.kt)("a",{parentName:"td",href:"#limits"},"Limits")," table for the specific limit."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"maxRelaunchCount"),": Max number of relaunches across all the workers defined in the ",(0,l.kt)("a",{parentName:"td",href:"#limits"},"Limits")," section. ",(0,l.kt)("br",null),(0,l.kt)("br",null)," ",(0,l.kt)("inlineCode",{parentName:"td"},"currentRelaunchCount"),": current relaunch counter for the job across all workers. ",(0,l.kt)("br",null),(0,l.kt)("br",null)," ",(0,l.kt)("inlineCode",{parentName:"td"},"taskId"),": Latest task id which failed ",(0,l.kt)("br",null)," ",(0,l.kt)("br",null)," ",(0,l.kt)("inlineCode",{parentName:"td"},"rootErrorMessage"),": Error message of the latest failed task.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{name:"error_TooManyAttemptsForWorker"},(0,l.kt)("inlineCode",{parentName:"td"},"TooManyAttemptsForWorker"))),(0,l.kt)("td",{parentName:"tr",align:null},"Worker exceeded maximum relaunch attempt count as defined in the ",(0,l.kt)("a",{parentName:"td",href:"#limits"},"Limits")," section."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"maxPerWorkerRelaunchCount"),": Max number of relaunches allowed per worker as defined in the ",(0,l.kt)("a",{parentName:"td",href:"#limits"},"Limits")," section. ",(0,l.kt)("br",null),(0,l.kt)("br",null)," ",(0,l.kt)("inlineCode",{parentName:"td"},"workerNumber"),": the worker number for which the task failed ",(0,l.kt)("br",null),(0,l.kt)("br",null)," ",(0,l.kt)("inlineCode",{parentName:"td"},"taskId"),": Latest task id which failed ",(0,l.kt)("br",null)," ",(0,l.kt)("br",null)," ",(0,l.kt)("inlineCode",{parentName:"td"},"rootErrorMessage"),": Error message of the latest failed task.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{name:"error_TooManyBuckets"},(0,l.kt)("inlineCode",{parentName:"td"},"TooManyBuckets"))),(0,l.kt)("td",{parentName:"tr",align:null},"Exceeded the maximum number of partition buckets for a stage (5,000 partition buckets).",(0,l.kt)("br",null),"< br />Partition buckets are created for each ",(0,l.kt)("a",{parentName:"td",href:"#partitioned-by"},(0,l.kt)("inlineCode",{parentName:"a"},"PARTITIONED BY"))," time chunk for INSERT and REPLACE queries. The most common reason for this error is that your ",(0,l.kt)("inlineCode",{parentName:"td"},"PARTITIONED BY")," is too narrow relative to your data."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"maxBuckets"),": The limit on partition buckets.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{name:"error_TooManyInputFiles"},(0,l.kt)("inlineCode",{parentName:"td"},"TooManyInputFiles"))),(0,l.kt)("td",{parentName:"tr",align:null},"Exceeded the maximum number of input files or segments per worker (10,000 files or segments).",(0,l.kt)("br",null),(0,l.kt)("br",null),"If you encounter this limit, consider adding more workers, or breaking up your query into smaller queries that process fewer files or segments per query."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"numInputFiles"),": The total number of input files/segments for the stage.",(0,l.kt)("br",null),(0,l.kt)("br",null),(0,l.kt)("inlineCode",{parentName:"td"},"maxInputFiles"),": The maximum number of input files/segments per worker per stage.",(0,l.kt)("br",null),(0,l.kt)("br",null),(0,l.kt)("inlineCode",{parentName:"td"},"minNumWorker"),": The minimum number of workers required for a successful run.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{name:"error_TooManyPartitions"},(0,l.kt)("inlineCode",{parentName:"td"},"TooManyPartitions"))),(0,l.kt)("td",{parentName:"tr",align:null},"Exceeded the maximum number of partitions for a stage (25,000 partitions).",(0,l.kt)("br",null),(0,l.kt)("br",null),"This can occur with INSERT or REPLACE statements that generate large numbers of segments, since each segment is associated with a partition. If you encounter this limit, consider breaking up your INSERT or REPLACE statement into smaller statements that process less data per statement."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"maxPartitions"),": The limit on partitions which was exceeded")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{name:"error_TooManyClusteredByColumns"},(0,l.kt)("inlineCode",{parentName:"td"},"TooManyClusteredByColumns"))),(0,l.kt)("td",{parentName:"tr",align:null},"Exceeded the maximum number of clustering columns for a stage (1,500 columns).",(0,l.kt)("br",null),(0,l.kt)("br",null),"This can occur with ",(0,l.kt)("inlineCode",{parentName:"td"},"CLUSTERED BY"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"ORDER BY"),", or ",(0,l.kt)("inlineCode",{parentName:"td"},"GROUP BY")," with a large number of columns."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"numColumns"),": The number of columns requested.",(0,l.kt)("br",null),(0,l.kt)("br",null),(0,l.kt)("inlineCode",{parentName:"td"},"maxColumns"),": The limit on columns which was exceeded.",(0,l.kt)("inlineCode",{parentName:"td"},"stage"),": The stage number exceeding the limit",(0,l.kt)("br",null),(0,l.kt)("br",null))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{name:"error_TooManyRowsWithSameKey"},(0,l.kt)("inlineCode",{parentName:"td"},"TooManyRowsWithSameKey"))),(0,l.kt)("td",{parentName:"tr",align:null},"The number of rows for a given key exceeded the maximum number of buffered bytes on both sides of a join. See the ",(0,l.kt)("a",{parentName:"td",href:"#limits"},"Limits")," table for the specific limit. Only occurs when join is executed via the sort-merge join algorithm."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"key"),": The key that had a large number of rows.",(0,l.kt)("br",null),(0,l.kt)("br",null),(0,l.kt)("inlineCode",{parentName:"td"},"numBytes"),": Number of bytes buffered, which may include other keys.",(0,l.kt)("br",null),(0,l.kt)("br",null),(0,l.kt)("inlineCode",{parentName:"td"},"maxBytes"),": Maximum number of bytes buffered.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{name:"error_TooManyColumns"},(0,l.kt)("inlineCode",{parentName:"td"},"TooManyColumns"))),(0,l.kt)("td",{parentName:"tr",align:null},"Exceeded the maximum number of columns for a stage (2,000 columns)."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"numColumns"),": The number of columns requested.",(0,l.kt)("br",null),(0,l.kt)("br",null),(0,l.kt)("inlineCode",{parentName:"td"},"maxColumns"),": The limit on columns which was exceeded.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{name:"error_TooManyWarnings"},(0,l.kt)("inlineCode",{parentName:"td"},"TooManyWarnings"))),(0,l.kt)("td",{parentName:"tr",align:null},"Exceeded the maximum allowed number of warnings of a particular type."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"rootErrorCode"),": The error code corresponding to the exception that exceeded the required limit. ",(0,l.kt)("br",null),(0,l.kt)("br",null),(0,l.kt)("inlineCode",{parentName:"td"},"maxWarnings"),": Maximum number of warnings that are allowed for the corresponding ",(0,l.kt)("inlineCode",{parentName:"td"},"rootErrorCode"),".")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{name:"error_TooManyWorkers"},(0,l.kt)("inlineCode",{parentName:"td"},"TooManyWorkers"))),(0,l.kt)("td",{parentName:"tr",align:null},"Exceeded the maximum number of simultaneously-running workers. See the ",(0,l.kt)("a",{parentName:"td",href:"#limits"},"Limits")," table for more details."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"workers"),": The number of simultaneously running workers that exceeded a hard or soft limit. This may be larger than the number of workers in any one stage if multiple stages are running simultaneously. ",(0,l.kt)("br",null),(0,l.kt)("br",null),(0,l.kt)("inlineCode",{parentName:"td"},"maxWorkers"),": The hard or soft limit on workers that was exceeded. If this is lower than the hard limit (1,000 workers), then you can increase the limit by adding more memory to each task.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{name:"error_NotEnoughMemory"},(0,l.kt)("inlineCode",{parentName:"td"},"NotEnoughMemory"))),(0,l.kt)("td",{parentName:"tr",align:null},"Insufficient memory to launch a stage."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"suggestedServerMemory"),": Suggested number of bytes of memory to allocate to a given process. ",(0,l.kt)("br",null),(0,l.kt)("br",null),(0,l.kt)("inlineCode",{parentName:"td"},"serverMemory"),": The number of bytes of memory available to a single process.",(0,l.kt)("br",null),(0,l.kt)("br",null),(0,l.kt)("inlineCode",{parentName:"td"},"usableMemory"),": The number of usable bytes of memory for a single process.",(0,l.kt)("br",null),(0,l.kt)("br",null),(0,l.kt)("inlineCode",{parentName:"td"},"serverWorkers"),": The number of workers running in a single process.",(0,l.kt)("br",null),(0,l.kt)("br",null),(0,l.kt)("inlineCode",{parentName:"td"},"serverThreads"),": The number of threads in a single process.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{name:"error_NotEnoughTemporaryStorage"},(0,l.kt)("inlineCode",{parentName:"td"},"NotEnoughTemporaryStorage"))),(0,l.kt)("td",{parentName:"tr",align:null},"Insufficient temporary storage configured to launch a stage. This limit is set by the property ",(0,l.kt)("inlineCode",{parentName:"td"},"druid.indexer.task.tmpStorageBytesPerTask"),". This property should be increased to the minimum suggested limit to resolve this."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"suggestedMinimumStorage"),": Suggested number of bytes of temporary storage space to allocate to a given process. ",(0,l.kt)("br",null),(0,l.kt)("br",null),(0,l.kt)("inlineCode",{parentName:"td"},"configuredTemporaryStorage"),": The number of bytes of storage currently configured.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{name:"error_WorkerFailed"},(0,l.kt)("inlineCode",{parentName:"td"},"WorkerFailed"))),(0,l.kt)("td",{parentName:"tr",align:null},"A worker task failed unexpectedly."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"errorMsg"),(0,l.kt)("br",null),(0,l.kt)("br",null),(0,l.kt)("inlineCode",{parentName:"td"},"workerTaskId"),": The ID of the worker task.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{name:"error_WorkerRpcFailed"},(0,l.kt)("inlineCode",{parentName:"td"},"WorkerRpcFailed"))),(0,l.kt)("td",{parentName:"tr",align:null},"A remote procedure call to a worker task failed and could not recover."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"workerTaskId"),": the id of the worker task")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{name:"error_UnknownError"},(0,l.kt)("inlineCode",{parentName:"td"},"UnknownError"))),(0,l.kt)("td",{parentName:"tr",align:null},"All other errors."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"message"))))))}N.isMDXComponent=!0}}]);