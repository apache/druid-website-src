"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[3502],{12160:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>u,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"comparisons/druid-vs-kudu","title":"Apache Druid vs Kudu","description":"\x3c!--","source":"@site/docs/latest/comparisons/druid-vs-kudu.md","sourceDirName":"comparisons","slug":"/comparisons/druid-vs-kudu","permalink":"/docs/latest/comparisons/druid-vs-kudu","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"druid-vs-kudu","title":"Apache Druid vs Kudu"}}');var a=s(74848),r=s(28453);const o={id:"druid-vs-kudu",title:"Apache Druid vs Kudu"},i=void 0,u={},d=[];function c(e){const t={p:"p",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"Kudu's storage format enables single row updates, whereas updates to existing Druid segments requires recreating the segment, so theoretically\nthe process for updating old values should be higher latency in Druid. However, the requirements in Kudu for maintaining extra head space to store\nupdates as well as organizing data by id instead of time has the potential to introduce some extra latency and accessing\nof data that is not needed to answer a query at query time."}),"\n",(0,a.jsx)(t.p,{children:"Druid summarizes/rollups up data at ingestion time, which in practice reduces the raw data that needs to be\nstored significantly (up to 40 times on average), and increases performance of scanning raw data significantly.\nDruid segments also contain bitmap indexes for fast filtering, which Kudu does not currently support.\nDruid's segment architecture is heavily geared towards fast aggregates and filters, and for OLAP workflows. Appends are very\nfast in Druid, whereas updates of older data are higher latency. This is by design as the data Druid is good for is typically event data,\nand does not need to be updated too frequently. Kudu supports arbitrary primary keys with uniqueness constraints, and\nefficient lookup by ranges of those keys. Kudu chooses not to include the execution engine, but supports sufficient\noperations so as to allow node-local processing from the execution engines. This means that Kudu can support multiple frameworks on the same data (e.g., MR, Spark, and SQL).\nDruid includes its own query layer that allows it to push down aggregations and computations directly to data processes for faster query processing."})]})}function p(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},28453:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>i});var n=s(96540);const a={},r=n.createContext(a);function o(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);