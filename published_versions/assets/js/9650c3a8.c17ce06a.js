"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[3800],{5939:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>t,default:()=>h,frontMatter:()=>l,metadata:()=>a,toc:()=>o});const a=JSON.parse('{"id":"querying/arrays","title":"Arrays","description":"\x3c!--","source":"@site/docs/33.0.0/querying/arrays.md","sourceDirName":"querying","slug":"/querying/arrays","permalink":"/docs/33.0.0/querying/arrays","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"arrays","title":"Arrays"},"sidebar":"docs","previous":{"title":"Multi-value dimensions","permalink":"/docs/33.0.0/querying/multi-value-dimensions"},"next":{"title":"Nested columns","permalink":"/docs/33.0.0/querying/nested-columns"}}');var i=r(74848),s=r(28453);const l={id:"arrays",title:"Arrays"},t=void 0,d={},o=[{value:"Ingesting arrays",id:"ingesting-arrays",level:2},{value:"Native batch and streaming ingestion",id:"native-batch-and-streaming-ingestion",level:3},{value:"SQL-based ingestion",id:"sql-based-ingestion",level:3},{value:"Examples",id:"examples",level:4},{value:"<code>arrayIngestMode</code>",id:"arrayingestmode",level:4},{value:"Querying arrays",id:"querying-arrays",level:2},{value:"Filtering",id:"filtering",level:3},{value:"Example: equality",id:"example-equality",level:4},{value:"Example: null",id:"example-null",level:4},{value:"Example: range",id:"example-range",level:4},{value:"Example: ARRAY_CONTAINS",id:"example-array_contains",level:4},{value:"Grouping",id:"grouping",level:3},{value:"Example: SQL grouping query with no filtering",id:"example-sql-grouping-query-with-no-filtering",level:4},{value:"Example: SQL grouping query with a filter",id:"example-sql-grouping-query-with-a-filter",level:4},{value:"Example: UNNEST",id:"example-unnest",level:4},{value:"Differences between arrays and multi-value dimensions",id:"differences-between-arrays-and-multi-value-dimensions",level:2}];function c(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Apache Druid supports SQL standard ",(0,i.jsx)(n.code,{children:"ARRAY"})," typed columns for ",(0,i.jsx)(n.code,{children:"VARCHAR"}),", ",(0,i.jsx)(n.code,{children:"BIGINT"}),", and ",(0,i.jsx)(n.code,{children:"DOUBLE"})," types (native types ",(0,i.jsx)(n.code,{children:"ARRAY<STRING>"}),", ",(0,i.jsx)(n.code,{children:"ARRAY<LONG>"}),", and ",(0,i.jsx)(n.code,{children:"ARRAY<DOUBLE>"}),"). Other more complicated ARRAY types must be stored in ",(0,i.jsx)(n.a,{href:"/docs/33.0.0/querying/nested-columns",children:"nested columns"}),". Druid ARRAY types are distinct from ",(0,i.jsx)(n.a,{href:"/docs/33.0.0/querying/multi-value-dimensions",children:"multi-value dimension"}),", which have significantly different behavior than standard arrays."]}),"\n",(0,i.jsxs)(n.p,{children:["This document describes inserting, filtering, and grouping behavior for ",(0,i.jsx)(n.code,{children:"ARRAY"})," typed columns.\nRefer to the ",(0,i.jsx)(n.a,{href:"/docs/33.0.0/querying/sql-data-types#arrays",children:"Druid SQL data type documentation"})," and ",(0,i.jsx)(n.a,{href:"/docs/33.0.0/querying/sql-array-functions",children:"SQL array function reference"})," for additional details\nabout the functions available to use with ARRAY columns and types in SQL."]}),"\n",(0,i.jsx)(n.p,{children:"The following sections describe inserting, filtering, and grouping behavior based on the following example data, which includes 3 array typed columns:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",metastring:"lines",children:'{"timestamp": "2023-01-01T00:00:00", "label": "row1", "arrayString": ["a", "b"],  "arrayLong":[1, null,3], "arrayDouble":[1.1, 2.2, null]}\n{"timestamp": "2023-01-01T00:00:00", "label": "row2", "arrayString": [null, "b"], "arrayLong":null,        "arrayDouble":[999, null, 5.5]}\n{"timestamp": "2023-01-01T00:00:00", "label": "row3", "arrayString": [],          "arrayLong":[1, 2, 3],   "arrayDouble":[null, 2.2, 1.1]} \n{"timestamp": "2023-01-01T00:00:00", "label": "row4", "arrayString": ["a", "b"],  "arrayLong":[1, 2, 3],   "arrayDouble":[]}\n{"timestamp": "2023-01-01T00:00:00", "label": "row5", "arrayString": null,        "arrayLong":[],          "arrayDouble":null}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"ingesting-arrays",children:"Ingesting arrays"}),"\n",(0,i.jsx)(n.h3,{id:"native-batch-and-streaming-ingestion",children:"Native batch and streaming ingestion"}),"\n",(0,i.jsxs)(n.p,{children:["When using native ",(0,i.jsx)(n.a,{href:"/docs/33.0.0/ingestion/native-batch",children:"batch"})," or streaming ingestion such as with ",(0,i.jsx)(n.a,{href:"/docs/33.0.0/ingestion/kafka-ingestion",children:"Apache Kafka"}),", arrays can be ingested using the ",(0,i.jsx)(n.a,{href:"/docs/33.0.0/ingestion/ingestion-spec#dimension-objects",children:(0,i.jsx)(n.code,{children:'"auto"'})})," type dimension schema which is shared with ",(0,i.jsx)(n.a,{href:"/docs/33.0.0/ingestion/schema-design#type-aware-schema-discovery",children:"type-aware schema discovery"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["When ingesting from TSV or CSV data, you can specify the array delimiters using the ",(0,i.jsx)(n.code,{children:"listDelimiter"})," field in the ",(0,i.jsx)(n.code,{children:"inputFormat"}),". JSON data must be formatted as a JSON array to be ingested as an array type. JSON data does not require ",(0,i.jsx)(n.code,{children:"inputFormat"})," configuration."]}),"\n",(0,i.jsxs)(n.p,{children:["The following shows an example ",(0,i.jsx)(n.code,{children:"dimensionsSpec"})," for native ingestion of the data used in this document:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'"dimensions": [\n  {\n    "type": "auto",\n    "name": "label"\n  },\n  {\n    "type": "auto",\n    "name": "arrayString"\n  },\n  {\n    "type": "auto",\n    "name": "arrayLong"\n  },\n  {\n    "type": "auto",\n    "name": "arrayDouble"\n  }\n],\n'})}),"\n",(0,i.jsx)(n.h3,{id:"sql-based-ingestion",children:"SQL-based ingestion"}),"\n",(0,i.jsxs)(n.p,{children:["Arrays can be inserted with ",(0,i.jsx)(n.a,{href:"/docs/33.0.0/multi-stage-query/",children:"SQL-based ingestion"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"examples",children:"Examples"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'REPLACE INTO "array_example" OVERWRITE ALL\nWITH "ext" AS (\n  SELECT *\n  FROM TABLE(\n    EXTERN(\n      \'{"type":"inline","data":"{\\"timestamp\\": \\"2023-01-01T00:00:00\\", \\"label\\": \\"row1\\", \\"arrayString\\": [\\"a\\", \\"b\\"],  \\"arrayLong\\":[1, null,3], \\"arrayDouble\\":[1.1, 2.2, null]}\\n{\\"timestamp\\": \\"2023-01-01T00:00:00\\", \\"label\\": \\"row2\\", \\"arrayString\\": [null, \\"b\\"], \\"arrayLong\\":null,        \\"arrayDouble\\":[999, null, 5.5]}\\n{\\"timestamp\\": \\"2023-01-01T00:00:00\\", \\"label\\": \\"row3\\", \\"arrayString\\": [],          \\"arrayLong\\":[1, 2, 3],   \\"arrayDouble\\":[null, 2.2, 1.1]} \\n{\\"timestamp\\": \\"2023-01-01T00:00:00\\", \\"label\\": \\"row4\\", \\"arrayString\\": [\\"a\\", \\"b\\"],  \\"arrayLong\\":[1, 2, 3],   \\"arrayDouble\\":[]}\\n{\\"timestamp\\": \\"2023-01-01T00:00:00\\", \\"label\\": \\"row5\\", \\"arrayString\\": null,        \\"arrayLong\\":[],          \\"arrayDouble\\":null}"}\',\n      \'{"type":"json"}\'\n    )\n  ) EXTEND (\n    "timestamp" VARCHAR,\n    "label" VARCHAR,\n    "arrayString" VARCHAR ARRAY,\n    "arrayLong" BIGINT ARRAY,\n    "arrayDouble" DOUBLE ARRAY\n  )\n)\nSELECT\n  TIME_PARSE("timestamp") AS "__time",\n  "label",\n  "arrayString",\n  "arrayLong",\n  "arrayDouble"\nFROM "ext"\nPARTITIONED BY DAY\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Arrays can also be used as ",(0,i.jsx)(n.code,{children:"GROUP BY"})," keys for rollup:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'REPLACE INTO "array_example_rollup" OVERWRITE ALL\nWITH "ext" AS (\n  SELECT *\n  FROM TABLE(\n    EXTERN(\n      \'{"type":"inline","data":"{\\"timestamp\\": \\"2023-01-01T00:00:00\\", \\"label\\": \\"row1\\", \\"arrayString\\": [\\"a\\", \\"b\\"],  \\"arrayLong\\":[1, null,3], \\"arrayDouble\\":[1.1, 2.2, null]}\\n{\\"timestamp\\": \\"2023-01-01T00:00:00\\", \\"label\\": \\"row2\\", \\"arrayString\\": [null, \\"b\\"], \\"arrayLong\\":null,        \\"arrayDouble\\":[999, null, 5.5]}\\n{\\"timestamp\\": \\"2023-01-01T00:00:00\\", \\"label\\": \\"row3\\", \\"arrayString\\": [],          \\"arrayLong\\":[1, 2, 3],   \\"arrayDouble\\":[null, 2.2, 1.1]} \\n{\\"timestamp\\": \\"2023-01-01T00:00:00\\", \\"label\\": \\"row4\\", \\"arrayString\\": [\\"a\\", \\"b\\"],  \\"arrayLong\\":[1, 2, 3],   \\"arrayDouble\\":[]}\\n{\\"timestamp\\": \\"2023-01-01T00:00:00\\", \\"label\\": \\"row5\\", \\"arrayString\\": null,        \\"arrayLong\\":[],          \\"arrayDouble\\":null}"}\',\n      \'{"type":"json"}\'\n    )\n  ) EXTEND (\n    "timestamp" VARCHAR,\n    "label" VARCHAR,\n    "arrayString" VARCHAR ARRAY,\n    "arrayLong" BIGINT ARRAY,\n    "arrayDouble" DOUBLE ARRAY\n  )\n)\nSELECT\n  TIME_PARSE("timestamp") AS "__time",\n  "label",\n  "arrayString",\n  "arrayLong",\n  "arrayDouble",\n  COUNT(*) as "count"\nFROM "ext"\nGROUP BY 1,2,3,4,5\nPARTITIONED BY DAY\n'})}),"\n",(0,i.jsx)(n.h4,{id:"arrayingestmode",children:(0,i.jsx)(n.code,{children:"arrayIngestMode"})}),"\n",(0,i.jsxs)(n.p,{children:["For seamless backwards compatible behavior with Druid versions older than 31, there is an ",(0,i.jsx)(n.code,{children:"arrayIngestMode"})," query context flag."]}),"\n",(0,i.jsxs)(n.p,{children:["When ",(0,i.jsx)(n.code,{children:"arrayIngestMode"})," is ",(0,i.jsx)(n.code,{children:"array"}),", SQL ARRAY types are stored using Druid array columns. This is recommended for new\ntables and the default configuration for Druid 31 and newer."]}),"\n",(0,i.jsxs)(n.p,{children:["When ",(0,i.jsx)(n.code,{children:"arrayIngestMode"})," is ",(0,i.jsx)(n.code,{children:"mvd"})," (legacy), SQL ",(0,i.jsx)(n.code,{children:"VARCHAR ARRAY"})," are implicitly wrapped in ",(0,i.jsx)(n.a,{href:"/docs/33.0.0/querying/sql-functions#array_to_mv",children:(0,i.jsx)(n.code,{children:"ARRAY_TO_MV"})}),".\nThis causes them to be stored as ",(0,i.jsx)(n.a,{href:"/docs/33.0.0/querying/multi-value-dimensions",children:"multi-value strings"}),", using the same ",(0,i.jsx)(n.code,{children:"STRING"})," column type\nas regular scalar strings. SQL ",(0,i.jsx)(n.code,{children:"BIGINT ARRAY"})," and ",(0,i.jsx)(n.code,{children:"DOUBLE ARRAY"})," cannot be loaded under ",(0,i.jsx)(n.code,{children:"arrayIngestMode: mvd"}),". This\nmode is not recommended and will be removed in a future release, but provided for backwards compatibility."]}),"\n",(0,i.jsxs)(n.p,{children:["The following table summarizes the differences in SQL ARRAY handling between ",(0,i.jsx)(n.code,{children:"arrayIngestMode: array"})," and\n",(0,i.jsx)(n.code,{children:"arrayIngestMode: mvd"}),"."]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"SQL type"}),(0,i.jsxs)(n.th,{children:["Stored type when ",(0,i.jsx)(n.code,{children:"arrayIngestMode: array"})," (default)"]}),(0,i.jsxs)(n.th,{children:["Stored type when ",(0,i.jsx)(n.code,{children:"arrayIngestMode: mvd"})]})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"VARCHAR ARRAY"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ARRAY<STRING>"})}),(0,i.jsx)(n.td,{children:(0,i.jsxs)(n.a,{href:"/docs/33.0.0/querying/multi-value-dimensions",children:["multi-value ",(0,i.jsx)(n.code,{children:"STRING"})]})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"BIGINT ARRAY"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ARRAY<LONG>"})}),(0,i.jsx)(n.td,{children:"not possible (validation error)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"DOUBLE ARRAY"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ARRAY<DOUBLE>"})}),(0,i.jsx)(n.td,{children:"not possible (validation error)"})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:["In either mode, you can explicitly wrap string arrays in ",(0,i.jsx)(n.code,{children:"ARRAY_TO_MV"})," to cause them to be stored as\n",(0,i.jsx)(n.a,{href:"/docs/33.0.0/querying/multi-value-dimensions",children:"multi-value strings"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["When validating a SQL INSERT or REPLACE statement that contains arrays, Druid checks whether the statement would lead\nto mixing string arrays and multi-value strings in the same column. If this condition is detected, the statement fails\nvalidation unless the column is named under the ",(0,i.jsx)(n.code,{children:"skipTypeVerification"})," context parameter. This parameter can be either\na comma-separated list of column names, or a JSON array in string form. This validation is done to prevent accidentally\nmixing arrays and multi-value strings in the same column."]}),"\n",(0,i.jsx)(n.h2,{id:"querying-arrays",children:"Querying arrays"}),"\n",(0,i.jsx)(n.h3,{id:"filtering",children:"Filtering"}),"\n",(0,i.jsxs)(n.p,{children:["All query types, as well as ",(0,i.jsx)(n.a,{href:"/docs/33.0.0/querying/aggregations#filtered-aggregator",children:"filtered aggregators"}),", can filter on array typed columns. Filters follow these rules for array types:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"All filters match against the entire array value for the row"}),"\n",(0,i.jsxs)(n.li,{children:["Native value filters like ",(0,i.jsx)(n.a,{href:"/docs/33.0.0/querying/filters#equality-filter",children:"equality"})," and ",(0,i.jsx)(n.a,{href:"/docs/33.0.0/querying/filters#range-filter",children:"range"})," match on entire array values, as do SQL constructs that plan into these native filters"]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.a,{href:"/docs/33.0.0/querying/filters#null-filter",children:(0,i.jsx)(n.code,{children:"IS NULL"})})," filter will match rows where the entire array value is null"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/33.0.0/querying/sql-array-functions",children:"Array specific functions"})," like ",(0,i.jsx)(n.code,{children:"ARRAY_CONTAINS"})," and ",(0,i.jsx)(n.code,{children:"ARRAY_OVERLAP"})," follow the behavior specified by those functions"]}),"\n",(0,i.jsx)(n.li,{children:"All other filters do not directly support ARRAY types and will result in a query error"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"example-equality",children:"Example: equality"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'SELECT *\nFROM "array_example"\nWHERE arrayLong = ARRAY[1,2,3]\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",metastring:"lines",children:'{"__time":"2023-01-01T00:00:00.000Z","label":"row3","arrayString":"[]","arrayLong":"[1,2,3]","arrayDouble":"[null,2.2,1.1]"}\n{"__time":"2023-01-01T00:00:00.000Z","label":"row4","arrayString":"[\\"a\\",\\"b\\"]","arrayLong":"[1,2,3]","arrayDouble":"[]"}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"example-null",children:"Example: null"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'SELECT *\nFROM "array_example"\nWHERE arrayLong IS NULL\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",metastring:"lines",children:'{"__time":"2023-01-01T00:00:00.000Z","label":"row2","arrayString":"[null,\\"b\\"]","arrayLong":null,"arrayDouble":"[999.0,null,5.5]"}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"example-range",children:"Example: range"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT *\nFROM \"array_example\"\nWHERE arrayString >= ARRAY['a','b']\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",metastring:"lines",children:'{"__time":"2023-01-01T00:00:00.000Z","label":"row1","arrayString":"[\\"a\\",\\"b\\"]","arrayLong":"[1,null,3]","arrayDouble":"[1.1,2.2,null]"}\n{"__time":"2023-01-01T00:00:00.000Z","label":"row4","arrayString":"[\\"a\\",\\"b\\"]","arrayLong":"[1,2,3]","arrayDouble":"[]"}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"example-array_contains",children:"Example: ARRAY_CONTAINS"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT *\nFROM \"array_example\"\nWHERE ARRAY_CONTAINS(arrayString, 'a')\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",metastring:"lines",children:'{"__time":"2023-01-01T00:00:00.000Z","label":"row1","arrayString":"[\\"a\\",\\"b\\"]","arrayLong":"[1,null,3]","arrayDouble":"[1.1,2.2,null]"}\n{"__time":"2023-01-01T00:00:00.000Z","label":"row4","arrayString":"[\\"a\\",\\"b\\"]","arrayLong":"[1,2,3]","arrayDouble":"[]"}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"grouping",children:"Grouping"}),"\n",(0,i.jsxs)(n.p,{children:["When grouping on an array with SQL or a native ",(0,i.jsx)(n.a,{href:"/docs/33.0.0/querying/groupbyquery",children:"groupBy query"}),", grouping follows standard SQL behavior and groups on the entire array as a single value. The ",(0,i.jsx)(n.a,{href:"/docs/33.0.0/querying/sql#unnest",children:(0,i.jsx)(n.code,{children:"UNNEST"})})," function allows grouping on the individual array elements."]}),"\n",(0,i.jsx)(n.h4,{id:"example-sql-grouping-query-with-no-filtering",children:"Example: SQL grouping query with no filtering"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'SELECT label, arrayString\nFROM "array_example"\nGROUP BY 1,2\n'})}),"\n",(0,i.jsx)(n.p,{children:"results in:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",metastring:"lines",children:'{"label":"row1","arrayString":"[\\"a\\",\\"b\\"]"}\n{"label":"row2","arrayString":"[null,\\"b\\"]"}\n{"label":"row3","arrayString":"[]"}\n{"label":"row4","arrayString":"[\\"a\\",\\"b\\"]"}\n{"label":"row5","arrayString":null}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"example-sql-grouping-query-with-a-filter",children:"Example: SQL grouping query with a filter"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'SELECT label, arrayString\nFROM "array_example"\nWHERE arrayLong = ARRAY[1,2,3]\nGROUP BY 1,2\n'})}),"\n",(0,i.jsx)(n.p,{children:"results:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",metastring:"lines",children:'{"label":"row3","arrayString":"[]"}\n{"label":"row4","arrayString":"[\\"a\\",\\"b\\"]"}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"example-unnest",children:"Example: UNNEST"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'SELECT label, strings\nFROM "array_example" CROSS JOIN UNNEST(arrayString) as u(strings)\nGROUP BY 1,2\n'})}),"\n",(0,i.jsx)(n.p,{children:"results:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",metastring:"lines",children:'{"label":"row1","strings":"a"}\n{"label":"row1","strings":"b"}\n{"label":"row2","strings":null}\n{"label":"row2","strings":"b"}\n{"label":"row4","strings":"a"}\n{"label":"row4","strings":"b"}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"differences-between-arrays-and-multi-value-dimensions",children:"Differences between arrays and multi-value dimensions"}),"\n",(0,i.jsxs)(n.p,{children:["Avoid confusing string arrays with ",(0,i.jsx)(n.a,{href:"/docs/33.0.0/querying/multi-value-dimensions",children:"multi-value dimensions"}),". Arrays and multi-value dimensions are stored in different column types, and query behavior is different. You can use the functions ",(0,i.jsx)(n.code,{children:"MV_TO_ARRAY"})," and ",(0,i.jsx)(n.code,{children:"ARRAY_TO_MV"})," to convert between the two if needed. In general, we recommend using arrays whenever possible, since they are a newer and more powerful feature and have SQL compliant behavior."]}),"\n",(0,i.jsx)(n.p,{children:"Use care during ingestion to ensure you get the type you want."}),"\n",(0,i.jsxs)(n.p,{children:["To get arrays when performing an ingestion using JSON ingestion specs, such as ",(0,i.jsx)(n.a,{href:"/docs/33.0.0/ingestion/native-batch",children:"native batch"})," or streaming ingestion such as with ",(0,i.jsx)(n.a,{href:"/docs/33.0.0/ingestion/kafka-ingestion",children:"Apache Kafka"}),", use dimension type ",(0,i.jsx)(n.code,{children:"auto"})," or enable ",(0,i.jsx)(n.code,{children:"useSchemaDiscovery"}),". When performing a ",(0,i.jsx)(n.a,{href:"/docs/33.0.0/multi-stage-query/",children:"SQL-based ingestion"}),", write a query that generates arrays. Arrays may contain strings or numbers."]}),"\n",(0,i.jsxs)(n.p,{children:["To get multi-value dimensions when performing an ingestion using JSON ingestion specs, use dimension type ",(0,i.jsx)(n.code,{children:"string"})," and do not enable ",(0,i.jsx)(n.code,{children:"useSchemaDiscovery"}),". When performing a ",(0,i.jsx)(n.a,{href:"/docs/33.0.0/multi-stage-query/",children:"SQL-based ingestion"}),", wrap arrays in ",(0,i.jsx)(n.a,{href:"/docs/33.0.0/querying/multi-value-dimensions#sql-based-ingestion",children:(0,i.jsx)(n.code,{children:"ARRAY_TO_MV"})}),", which ensures you get multi-value dimensions. Multi-value dimensions can only contain strings."]}),"\n",(0,i.jsxs)(n.p,{children:["You can tell which type you have by checking the ",(0,i.jsx)(n.code,{children:"INFORMATION_SCHEMA.COLUMNS"})," table, using a query like:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT COLUMN_NAME, DATA_TYPE\nFROM INFORMATION_SCHEMA.COLUMNS\nWHERE TABLE_NAME = 'mytable'\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Arrays are type ",(0,i.jsx)(n.code,{children:"ARRAY"}),", multi-value strings are type ",(0,i.jsx)(n.code,{children:"VARCHAR"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>t});var a=r(96540);const i={},s=a.createContext(i);function l(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);