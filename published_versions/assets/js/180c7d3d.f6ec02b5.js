"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4627],{28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var o=n(96540);const a={},i=o.createContext(a);function s(e){const t=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),o.createElement(i.Provider,{value:t},e.children)}},64987:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"data-management/compaction","title":"Compaction","description":"Defines compaction and automatic compaction (auto-compaction or autocompaction) for segment optimization. Use cases and strategies for compaction. Describes compaction task configuration.","source":"@site/docs/latest/data-management/compaction.md","sourceDirName":"data-management","slug":"/data-management/compaction","permalink":"/docs/latest/data-management/compaction","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"compaction","title":"Compaction","description":"Defines compaction and automatic compaction (auto-compaction or autocompaction) for segment optimization. Use cases and strategies for compaction. Describes compaction task configuration."},"sidebar":"docs","previous":{"title":"Schema changes","permalink":"/docs/latest/data-management/schema-changes"},"next":{"title":"Automatic compaction","permalink":"/docs/latest/data-management/automatic-compaction"}}');var a=n(74848),i=n(28453);const s={id:"compaction",title:"Compaction",description:"Defines compaction and automatic compaction (auto-compaction or autocompaction) for segment optimization. Use cases and strategies for compaction. Describes compaction task configuration."},r=void 0,c={},l=[{value:"Compaction guidelines",id:"compaction-guidelines",level:2},{value:"Ways to run compaction",id:"ways-to-run-compaction",level:2},{value:"Data handling with compaction",id:"data-handling-with-compaction",level:2},{value:"Segment granularity handling",id:"segment-granularity-handling",level:3},{value:"Query granularity handling",id:"query-granularity-handling",level:3},{value:"Dimension handling",id:"dimension-handling",level:3},{value:"Rollup",id:"rollup",level:3},{value:"Learn more",id:"learn-more",level:2}];function m(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:'Query performance in Apache Druid depends on optimally sized segments. Compaction is one strategy you can use to optimize segment size for your Druid database. Compaction tasks read an existing set of segments for a given time interval and combine the data into a new "compacted" set of segments. In some cases the compacted segments are larger, but there are fewer of them. In other cases the compacted segments may be smaller. Compaction tends to increase performance because optimized segments require less per-segment processing and less memory overhead for ingestion and for querying paths.'}),"\n",(0,a.jsx)(t.h2,{id:"compaction-guidelines",children:"Compaction guidelines"}),"\n",(0,a.jsx)(t.p,{children:"There are several cases to consider compaction for segment optimization:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"With streaming ingestion, data can arrive out of chronological order creating many small segments."}),"\n",(0,a.jsxs)(t.li,{children:["If you append data using ",(0,a.jsx)(t.code,{children:"appendToExisting"})," for ",(0,a.jsx)(t.a,{href:"/docs/latest/ingestion/native-batch",children:"native batch"})," ingestion creating suboptimal segments."]}),"\n",(0,a.jsxs)(t.li,{children:["When you use ",(0,a.jsx)(t.code,{children:"index_parallel"})," for parallel batch indexing and the parallel ingestion tasks create many small segments."]}),"\n",(0,a.jsx)(t.li,{children:"When a misconfigured ingestion task creates oversized segments."}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"By default, compaction does not modify the underlying data of the segments. However, there are cases when you may want to modify data during compaction to improve query performance:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"If, after ingestion, you realize that data for the time interval is sparse, you can use compaction to increase the segment granularity."}),"\n",(0,a.jsxs)(t.li,{children:["If you don't need fine-grained granularity for older data, you can use compaction to change older segments to a coarser query granularity. For example, from ",(0,a.jsx)(t.code,{children:"minute"})," to ",(0,a.jsx)(t.code,{children:"hour"})," or ",(0,a.jsx)(t.code,{children:"hour"})," to ",(0,a.jsx)(t.code,{children:"day"}),". This reduces the storage space required for older data."]}),"\n",(0,a.jsx)(t.li,{children:"You can change the dimension order to improve sorting and reduce segment size."}),"\n",(0,a.jsx)(t.li,{children:"You can remove unused columns in compaction or implement an aggregation metric for older data."}),"\n",(0,a.jsxs)(t.li,{children:["You can change segment rollup from dynamic partitioning with best-effort rollup to hash or range partitioning with perfect rollup. For more information on rollup, see ",(0,a.jsx)(t.a,{href:"/docs/latest/ingestion/rollup#perfect-rollup-vs-best-effort-rollup",children:"perfect vs best-effort rollup"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["Compaction does not improve performance in all situations. For example, if you rewrite your data with each ingestion task, you don't need to use compaction. See ",(0,a.jsx)(t.a,{href:"/docs/latest/operations/segment-optimization",children:"Segment optimization"})," for additional guidance to determine if compaction will help in your environment."]}),"\n",(0,a.jsx)(t.h2,{id:"ways-to-run-compaction",children:"Ways to run compaction"}),"\n",(0,a.jsx)(t.p,{children:"Automatic compaction, also called auto-compaction, works in most use cases and should be your first option."}),"\n",(0,a.jsxs)(t.p,{children:["The Coordinator uses its ",(0,a.jsx)(t.a,{href:"/docs/latest/design/coordinator#segment-search-policy-in-automatic-compaction",children:"segment search policy"})," to periodically identify segments for compaction starting from newest to oldest. When the Coordinator discovers segments that have not been compacted or segments that were compacted with a different or changed spec, it submits compaction tasks for the time interval covering those segments."]}),"\n",(0,a.jsxs)(t.p,{children:["To learn more, see ",(0,a.jsx)(t.a,{href:"/docs/latest/data-management/automatic-compaction",children:"Automatic compaction"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"In cases where you require more control over compaction, you can manually submit compaction tasks. For example:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Automatic compaction is running into the limit of task slots available to it, so tasks are waiting for previous automatic compaction tasks to complete. Manual compaction can use all available task slots, therefore you can complete compaction more quickly by submitting more concurrent tasks for more intervals."}),"\n",(0,a.jsx)(t.li,{children:"You want to force compaction for a specific time range or you want to compact data out of chronological order."}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["See ",(0,a.jsx)(t.a,{href:"/docs/latest/data-management/manual-compaction#setting-up-manual-compaction",children:"Setting up a manual compaction task"})," for more about manual compaction tasks."]}),"\n",(0,a.jsx)(t.h2,{id:"data-handling-with-compaction",children:"Data handling with compaction"}),"\n",(0,a.jsx)(t.p,{children:"During compaction, Druid overwrites the original set of segments with the compacted set. Druid also locks the segments for the time interval being compacted to ensure data consistency. By default, compaction tasks do not modify the underlying data. You can configure the compaction task to change the query granularity or add or remove dimensions in the compaction task. This means that the only changes to query results should be the result of intentional, not automatic, changes."}),"\n",(0,a.jsxs)(t.p,{children:["You can set ",(0,a.jsx)(t.code,{children:"dropExisting"})," in ",(0,a.jsx)(t.code,{children:"ioConfig"}),' to "true" in the compaction task to configure Druid to replace all existing segments fully contained by the interval. See the suggestion for reindexing with finer granularity under ',(0,a.jsx)(t.a,{href:"/docs/latest/ingestion/native-batch#implementation-considerations",children:"Implementation considerations"})," for an example."]}),"\n",(0,a.jsx)(t.admonition,{type:"info",children:(0,a.jsxs)(t.p,{children:["WARNING: ",(0,a.jsx)(t.code,{children:"dropExisting"})," in ",(0,a.jsx)(t.code,{children:"ioConfig"})," is a beta feature."]})}),"\n",(0,a.jsxs)(t.p,{children:["If an ingestion task needs to write data to a segment for a time interval locked for compaction, by default the ingestion task supersedes the compaction task and the compaction task fails without finishing. For manual compaction tasks, you can adjust the input spec interval to avoid conflicts between ingestion and compaction. For automatic compaction, you can set the ",(0,a.jsx)(t.code,{children:"skipOffsetFromLatest"})," key to adjust the auto-compaction starting point from the current time to reduce the chance of conflicts between ingestion and compaction.\nAnother option is to set the compaction task to higher priority than the ingestion task.\nFor more information, see ",(0,a.jsx)(t.a,{href:"/docs/latest/data-management/automatic-compaction#avoid-conflicts-with-ingestion",children:"Avoid conflicts with ingestion"}),"."]}),"\n",(0,a.jsx)(t.h3,{id:"segment-granularity-handling",children:"Segment granularity handling"}),"\n",(0,a.jsxs)(t.p,{children:["Unless you modify the segment granularity in ",(0,a.jsx)(t.a,{href:"/docs/latest/data-management/manual-compaction#compaction-granularity-spec",children:(0,a.jsx)(t.code,{children:"granularitySpec"})}),", Druid attempts to retain the granularity for the compacted segments. When segments have different segment granularities with no overlap in interval Druid creates a separate compaction task for each to retain the segment granularity in the compacted segment."]}),"\n",(0,a.jsx)(t.p,{children:"If segments have different segment granularities before compaction but there is some overlap in interval, Druid attempts find start and end of the overlapping interval and uses the closest segment granularity level for the compacted segment."}),"\n",(0,a.jsx)(t.p,{children:'For example consider two overlapping segments: segment "A" for the interval 01/01/2020-01/02/2020 with day granularity and segment "B" for the interval 01/01/2020-02/01/2020. Druid attempts to combine and compact the overlapped segments. In this example, the earliest start time for the two segments is 01/01/2020 and the latest end time of the two segments is 02/01/2020. Druid compacts the segments together even though they have different segment granularity. Druid uses month segment granularity for the newly compacted segment even though segment A\'s original segment granularity was day granularity.'}),"\n",(0,a.jsx)(t.h3,{id:"query-granularity-handling",children:"Query granularity handling"}),"\n",(0,a.jsxs)(t.p,{children:["Unless you modify the query granularity in the ",(0,a.jsx)(t.a,{href:"/docs/latest/data-management/manual-compaction#compaction-granularity-spec",children:(0,a.jsx)(t.code,{children:"granularitySpec"})}),", Druid retains the query granularity for the compacted segments. If segments have different query granularities before compaction, Druid chooses the finest level of granularity for the resulting compacted segment. For example if a compaction task combines two segments, one with day query granularity and one with minute query granularity, the resulting segment uses minute query granularity."]}),"\n",(0,a.jsx)(t.admonition,{type:"info",children:(0,a.jsxs)(t.p,{children:["In Apache Druid 0.21.0 and prior, Druid sets the granularity for compacted segments to the default granularity of ",(0,a.jsx)(t.code,{children:"NONE"})," regardless of the query granularity of the original segments."]})}),"\n",(0,a.jsx)(t.p,{children:"If you configure query granularity in compaction to go from a finer granularity like month to a coarser query granularity like year, then Druid overshadows the original segment with coarser granularity. Because the new segments have a coarser granularity, running a kill task to remove the overshadowed segments for those intervals will cause you to permanently lose the finer granularity data."}),"\n",(0,a.jsx)(t.h3,{id:"dimension-handling",children:"Dimension handling"}),"\n",(0,a.jsxs)(t.p,{children:["Apache Druid supports schema changes. Therefore, dimensions can be different across segments even if they are a part of the same datasource. See ",(0,a.jsx)(t.a,{href:"/docs/latest/design/segments#segments-with-different-schemas",children:"Segments with different schemas"}),". If the input segments have different dimensions, the resulting compacted segment includes all dimensions of the input segments."]}),"\n",(0,a.jsx)(t.p,{children:"Even when the input segments have the same set of dimensions, the dimension order or the data type of dimensions can be different. The dimensions of recent segments precede that of old segments in terms of data types and the ordering because more recent segments are more likely to have the preferred order and data types."}),"\n",(0,a.jsxs)(t.p,{children:["If you want to control dimension ordering or ensure specific values for dimension types, you can configure a custom ",(0,a.jsx)(t.code,{children:"dimensionsSpec"})," in the compaction task spec."]}),"\n",(0,a.jsx)(t.h3,{id:"rollup",children:"Rollup"}),"\n",(0,a.jsxs)(t.p,{children:["Druid only rolls up the output segment when ",(0,a.jsx)(t.code,{children:"rollup"})," is set for all input segments.\nSee ",(0,a.jsx)(t.a,{href:"/docs/latest/ingestion/rollup",children:"Roll-up"})," for more details.\nYou can check that your segments are rolled up or not by using ",(0,a.jsx)(t.a,{href:"/docs/latest/querying/segmentmetadataquery#analysistypes",children:"Segment Metadata Queries"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"learn-more",children:"Learn more"}),"\n",(0,a.jsx)(t.p,{children:"See the following topics for more information:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.a,{href:"/docs/latest/operations/segment-optimization",children:"Segment optimization"})," for guidance to determine if compaction will help in your case."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.a,{href:"/docs/latest/data-management/manual-compaction",children:"Manual compaction"})," for how to run a one-time compaction task."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.a,{href:"/docs/latest/data-management/automatic-compaction",children:"Automatic compaction"})," for how to enable and configure automatic compaction."]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(m,{...e})}):m(e)}}}]);