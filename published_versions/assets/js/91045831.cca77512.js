"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6622],{28453:(e,r,s)=>{s.d(r,{R:()=>o,x:()=>a});var t=s(96540);const i={},n=t.createContext(i);function o(e){const r=t.useContext(n);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(n.Provider,{value:r},e.children)}},90390:(e,r,s)=>{s.r(r),s.d(r,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"design/broker","title":"Broker service","description":"\x3c!--","source":"@site/docs/33.0.0/design/broker.md","sourceDirName":"design","slug":"/design/broker","permalink":"/docs/33.0.0/design/broker","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"broker","title":"Broker service","sidebar_label":"Broker"},"sidebar":"docs","previous":{"title":"Overlord","permalink":"/docs/33.0.0/design/overlord"},"next":{"title":"Router","permalink":"/docs/33.0.0/design/router"}}');var i=s(74848),n=s(28453);const o={id:"broker",title:"Broker service",sidebar_label:"Broker"},a=void 0,c={},d=[{value:"Configuration",id:"configuration",level:2},{value:"HTTP endpoints",id:"http-endpoints",level:2},{value:"Running",id:"running",level:2},{value:"Forwarding queries",id:"forwarding-queries",level:2},{value:"Caching",id:"caching",level:2}];function l(e){const r={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,n.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.p,{children:"The Broker service routes queries in a distributed cluster setup. It interprets the metadata published to ZooKeeper about segment distribution across services and routes queries accordingly. Additionally, the Broker service consolidates result sets from individual services."}),"\n",(0,i.jsx)(r.h2,{id:"configuration",children:"Configuration"}),"\n",(0,i.jsxs)(r.p,{children:["For Apache Druid Broker service configuration, see ",(0,i.jsx)(r.a,{href:"/docs/33.0.0/configuration/#broker",children:"Broker Configuration"}),"."]}),"\n",(0,i.jsxs)(r.p,{children:["For basic tuning guidance for the Broker service, see ",(0,i.jsx)(r.a,{href:"/docs/33.0.0/operations/basic-cluster-tuning#broker",children:"Basic cluster tuning"}),"."]}),"\n",(0,i.jsx)(r.h2,{id:"http-endpoints",children:"HTTP endpoints"}),"\n",(0,i.jsxs)(r.p,{children:["For a list of API endpoints supported by the Broker, see ",(0,i.jsx)(r.a,{href:"/docs/33.0.0/api-reference/legacy-metadata-api#broker",children:"Broker API"}),"."]}),"\n",(0,i.jsx)(r.h2,{id:"running",children:"Running"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:"org.apache.druid.cli.Main server broker\n"})}),"\n",(0,i.jsx)(r.h2,{id:"forwarding-queries",children:"Forwarding queries"}),"\n",(0,i.jsxs)(r.p,{children:["Most Druid queries contain an interval object that indicates a span of time for which data is requested. Similarly, Druid partitions ",(0,i.jsx)(r.a,{href:"/docs/33.0.0/design/segments",children:"segments"})," to contain data for some interval of time and distributes the segments across a cluster. Consider a simple datasource with seven segments where each segment contains data for a given day of the week. Any query issued to the datasource for more than one day of data will hit more than one segment. These segments will likely be distributed across multiple services, and hence, the query will likely hit multiple services."]}),"\n",(0,i.jsxs)(r.p,{children:["To determine which services to forward queries to, the Broker service first builds a view of the world from information in ZooKeeper. ZooKeeper maintains information about ",(0,i.jsx)(r.a,{href:"/docs/33.0.0/design/historical",children:"Historical"})," and streaming ingestion ",(0,i.jsx)(r.a,{href:"/docs/33.0.0/design/peons",children:"Peon"})," services and the segments they are serving. For every datasource in ZooKeeper, the Broker service builds a timeline of segments and the services that serve them. When queries are received for a specific datasource and interval, the Broker service performs a lookup into the timeline associated with the query datasource for the query interval and retrieves the services that contain data for the query. The Broker service then forwards down the query to the selected services."]}),"\n",(0,i.jsx)(r.h2,{id:"caching",children:"Caching"}),"\n",(0,i.jsxs)(r.p,{children:["Broker services employ a cache with an LRU cache invalidation strategy. The Broker cache stores per-segment results. The cache can be local to each Broker service or shared across multiple services using an external distributed cache such as ",(0,i.jsx)(r.a,{href:"http://memcached.org/",children:"memcached"}),". Each time a Broker service receives a query, it first maps the query to a set of segments. A subset of these segment results may already exist in the cache and the results can be directly pulled from the cache. For any segment results that do not exist in the cache, the Broker service will forward the query to the\nHistorical services. Once the Historical services return their results, the Broker will store those results in the cache. Real-time segments are never cached and hence requests for real-time data will always be forwarded to real-time services. Real-time data is perpetually changing and caching the results would be unreliable."]})]})}function h(e={}){const{wrapper:r}={...(0,n.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}}}]);