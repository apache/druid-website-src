"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7323],{22716:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>i,default:()=>h,frontMatter:()=>d,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"api-reference/legacy-metadata-api","title":"Legacy metadata API","description":"\x3c!--","source":"@site/docs/33.0.0/api-reference/legacy-metadata-api.md","sourceDirName":"api-reference","slug":"/api-reference/legacy-metadata-api","permalink":"/docs/33.0.0/api-reference/legacy-metadata-api","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"legacy-metadata-api","title":"Legacy metadata API","sidebar_label":"Legacy metadata"},"sidebar":"docs","previous":{"title":"Dynamic configuration","permalink":"/docs/33.0.0/api-reference/dynamic-configuration-api"},"next":{"title":"SQL JDBC driver","permalink":"/docs/33.0.0/api-reference/sql-jdbc"}}');var r=a(74848),n=a(28453);const d={id:"legacy-metadata-api",title:"Legacy metadata API",sidebar_label:"Legacy metadata"},i=void 0,o={},l=[{value:"Segment loading",id:"segment-loading",level:2},{value:"Segment loading by datasource",id:"segment-loading-by-datasource",level:2},{value:"Metadata store information",id:"metadata-store-information",level:2},{value:"Datasources",id:"datasources",level:2},{value:"Intervals",id:"intervals",level:2},{value:"Server information",id:"server-information",level:2},{value:"Query server",id:"query-server",level:2},{value:"Broker",id:"broker",level:3},{value:"Datasource information",id:"datasource-information",level:4}];function c(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",ul:"ul",...(0,n.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["This document describes the legacy API endpoints to retrieve datasource metadata from Apache Druid. Use the ",(0,r.jsx)(t.a,{href:"/docs/33.0.0/querying/sql-metadata-tables",children:"SQL metadata tables"})," to retrieve datasource metadata instead."]}),"\n",(0,r.jsx)(t.h2,{id:"segment-loading",children:"Segment loading"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/loadstatus"})}),"\n",(0,r.jsx)(t.p,{children:"Returns the percentage of segments actually loaded in the cluster versus segments that should be loaded in the cluster."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/loadstatus?simple"})}),"\n",(0,r.jsx)(t.p,{children:"Returns the number of segments left to load until segments that should be loaded in the cluster are available for queries. This does not include segment replication counts."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/loadstatus?full"})}),"\n",(0,r.jsx)(t.p,{children:"Returns the number of segments left to load in each tier until segments that should be loaded in the cluster are all available. This includes segment replication counts."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/loadstatus?full&computeUsingClusterView"})}),"\n",(0,r.jsx)(t.p,{children:"Returns the number of segments not yet loaded for each tier until all segments loading in the cluster are available.\nThe result includes segment replication counts. It also factors in the number of available nodes that are of a service type that can load the segment when computing the number of segments remaining to load.\nA segment is considered fully loaded when:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Druid has replicated it the number of times configured in the corresponding load rule."}),"\n",(0,r.jsx)(t.li,{children:"Or the number of replicas for the segment in each tier where it is configured to be replicated equals the available nodes of a service type that are currently allowed to load the segment in the tier."}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/loadqueue"})}),"\n",(0,r.jsx)(t.p,{children:"Returns the ids of segments to load and drop for each Historical process."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/loadqueue?simple"})}),"\n",(0,r.jsx)(t.p,{children:"Returns the number of segments to load and drop, as well as the total segment load and drop size in bytes for each Historical process."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/loadqueue?full"})}),"\n",(0,r.jsx)(t.p,{children:"Returns the serialized JSON of segments to load and drop for each Historical process."}),"\n",(0,r.jsx)(t.h2,{id:"segment-loading-by-datasource",children:"Segment loading by datasource"}),"\n",(0,r.jsxs)(t.p,{children:["Note that all ",(0,r.jsx)(t.em,{children:"interval"})," query parameters are ISO 8601 strings\u2014for example, 2016-06-27/2016-06-28.\nAlso note that these APIs only guarantees that the segments are available at the time of the call.\nSegments can still become missing because of historical process failures or any other reasons afterward."]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/datasources/{dataSourceName}/loadstatus?forceMetadataRefresh={boolean}&interval={myInterval}"})}),"\n",(0,r.jsxs)(t.p,{children:["Returns the percentage of segments actually loaded in the cluster versus segments that should be loaded in the cluster for the given\ndatasource over the given interval (or last 2 weeks if interval is not given). ",(0,r.jsx)(t.code,{children:"forceMetadataRefresh"})," is required to be set."]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Setting ",(0,r.jsx)(t.code,{children:"forceMetadataRefresh"})," to true will force the coordinator to poll latest segment metadata from the metadata store\n(Note: ",(0,r.jsx)(t.code,{children:"forceMetadataRefresh=true"})," refreshes Coordinator's metadata cache of all datasources. This can be a heavy operation in terms\nof the load on the metadata store but can be necessary to make sure that we verify all the latest segments' load status)"]}),"\n",(0,r.jsxs)(t.li,{children:["Setting ",(0,r.jsx)(t.code,{children:"forceMetadataRefresh"})," to false will use the metadata cached on the coordinator from the last force/periodic refresh.\nIf no used segments are found for the given inputs, this API returns ",(0,r.jsx)(t.code,{children:"204 No Content"})]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/datasources/{dataSourceName}/loadstatus?simple&forceMetadataRefresh={boolean}&interval={myInterval}"})}),"\n",(0,r.jsxs)(t.p,{children:["Returns the number of segments left to load until segments that should be loaded in the cluster are available for the given datasource\nover the given interval (or last 2 weeks if interval is not given). This does not include segment replication counts. ",(0,r.jsx)(t.code,{children:"forceMetadataRefresh"})," is required to be set."]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Setting ",(0,r.jsx)(t.code,{children:"forceMetadataRefresh"})," to true will force the coordinator to poll latest segment metadata from the metadata store\n(Note: ",(0,r.jsx)(t.code,{children:"forceMetadataRefresh=true"})," refreshes Coordinator's metadata cache of all datasources. This can be a heavy operation in terms\nof the load on the metadata store but can be necessary to make sure that we verify all the latest segments' load status)"]}),"\n",(0,r.jsxs)(t.li,{children:["Setting ",(0,r.jsx)(t.code,{children:"forceMetadataRefresh"})," to false will use the metadata cached on the coordinator from the last force/periodic refresh.\nIf no used segments are found for the given inputs, this API returns ",(0,r.jsx)(t.code,{children:"204 No Content"})]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/datasources/{dataSourceName}/loadstatus?full&forceMetadataRefresh={boolean}&interval={myInterval}"})}),"\n",(0,r.jsxs)(t.p,{children:["Returns the number of segments left to load in each tier until segments that should be loaded in the cluster are all available for the given datasource  over the given interval (or last 2 weeks if interval is not given). This includes segment replication counts. ",(0,r.jsx)(t.code,{children:"forceMetadataRefresh"})," is required to be set."]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Setting ",(0,r.jsx)(t.code,{children:"forceMetadataRefresh"})," to true will force the coordinator to poll latest segment metadata from the metadata store\n(Note: ",(0,r.jsx)(t.code,{children:"forceMetadataRefresh=true"})," refreshes Coordinator's metadata cache of all datasources. This can be a heavy operation in terms\nof the load on the metadata store but can be necessary to make sure that we verify all the latest segments' load status)"]}),"\n",(0,r.jsxs)(t.li,{children:["Setting ",(0,r.jsx)(t.code,{children:"forceMetadataRefresh"})," to false will use the metadata cached on the coordinator from the last force/periodic refresh."]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["You can pass the optional query parameter ",(0,r.jsx)(t.code,{children:"computeUsingClusterView"})," to factor in the available cluster services when calculating\nthe segments left to load. See ",(0,r.jsx)(t.a,{href:"#segment-loading",children:"Coordinator Segment Loading"})," for details.\nIf no used segments are found for the given inputs, this API returns ",(0,r.jsx)(t.code,{children:"204 No Content"})]}),"\n",(0,r.jsx)(t.h2,{id:"metadata-store-information",children:"Metadata store information"}),"\n",(0,r.jsx)(t.admonition,{type:"info",children:(0,r.jsxs)(t.p,{children:["Note: Much of this information is available in a simpler, easier-to-use form through the Druid SQL\n",(0,r.jsx)(t.a,{href:"/docs/33.0.0/querying/sql-metadata-tables#segments-table",children:(0,r.jsx)(t.code,{children:"sys.segments"})})," table."]})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/metadata/segments"})}),"\n",(0,r.jsx)(t.p,{children:"Returns a list of all segments for each datasource enabled in the cluster."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/metadata/segments?datasources={dataSourceName1}&datasources={dataSourceName2}"})}),"\n",(0,r.jsx)(t.p,{children:"Returns a list of all segments for one or more specific datasources enabled in the cluster."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/metadata/segments?includeOvershadowedStatus"})}),"\n",(0,r.jsxs)(t.p,{children:["Returns a list of all segments for each datasource with the full segment metadata and an extra field ",(0,r.jsx)(t.code,{children:"overshadowed"}),"."]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/metadata/segments?includeOvershadowedStatus&includeRealtimeSegments"})}),"\n",(0,r.jsxs)(t.p,{children:["Returns a list of all published and realtime segments for each datasource with the full segment metadata and extra fields ",(0,r.jsx)(t.code,{children:"overshadowed"}),",",(0,r.jsx)(t.code,{children:"realtime"})," & ",(0,r.jsx)(t.code,{children:"numRows"}),". Realtime segments are returned only when ",(0,r.jsx)(t.code,{children:"druid.centralizedDatasourceSchema.enabled"})," is set on the Coordinator."]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/metadata/segments?includeOvershadowedStatus&datasources={dataSourceName1}&datasources={dataSourceName2}"})}),"\n",(0,r.jsxs)(t.p,{children:["Returns a list of all segments for one or more specific datasources with the full segment metadata and an extra field ",(0,r.jsx)(t.code,{children:"overshadowed"}),"."]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/metadata/segments?includeOvershadowedStatus&includeRealtimeSegments&datasources={dataSourceName1}&datasources={dataSourceName2}"})}),"\n",(0,r.jsxs)(t.p,{children:["Returns a list of all published and realtime segments for the specified datasources with the full segment metadata and extra fields ",(0,r.jsx)(t.code,{children:"overshadwed"}),",",(0,r.jsx)(t.code,{children:"realtime"})," & ",(0,r.jsx)(t.code,{children:"numRows"}),". Realtime segments are returned only when ",(0,r.jsx)(t.code,{children:"druid.centralizedDatasourceSchema.enabled"})," is set on the Coordinator."]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/metadata/datasources"})}),"\n",(0,r.jsx)(t.p,{children:"Returns a list of the names of datasources with at least one used segment in the cluster, retrieved from the metadata database. Users should call this API to get the eventual state that the system will be in."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/metadata/datasources?includeUnused"})}),"\n",(0,r.jsx)(t.p,{children:"Returns a list of the names of datasources, regardless of whether there are used segments belonging to those datasources in the cluster or not."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/metadata/datasources?includeDisabled"})}),"\n",(0,r.jsx)(t.p,{children:"Returns a list of the names of datasources, regardless of whether the datasource is disabled or not."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/metadata/datasources?full"})}),"\n",(0,r.jsx)(t.p,{children:"Returns a list of all datasources with at least one used segment in the cluster. Returns all metadata about those datasources as stored in the metadata store."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/metadata/datasources/{dataSourceName}"})}),"\n",(0,r.jsx)(t.p,{children:"Returns full metadata for a datasource as stored in the metadata store."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/metadata/datasources/{dataSourceName}/segments"})}),"\n",(0,r.jsx)(t.p,{children:"Returns a list of all segments for a datasource as stored in the metadata store."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/metadata/datasources/{dataSourceName}/segments?full"})}),"\n",(0,r.jsx)(t.p,{children:"Returns a list of all segments for a datasource with the full segment metadata as stored in the metadata store."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/metadata/datasources/{dataSourceName}/segments/{segmentId}"})}),"\n",(0,r.jsx)(t.p,{children:"Returns full segment metadata for a specific segment as stored in the metadata store, if the segment is used. If the\nsegment is unused, or is unknown, a 404 response is returned."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/metadata/datasources/{dataSourceName}/segments/{segmentId}?includeUnused=true"})}),"\n",(0,r.jsx)(t.p,{children:"Returns full segment metadata for a specific segment as stored in the metadata store. If it is unknown, a 404 response\nis returned."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/metadata/datasources/{dataSourceName}/segments"})}),"\n",(0,r.jsxs)(t.p,{children:["Returns a list of all segments, overlapping with any of given intervals,  for a datasource as stored in the metadata store. Request body is array of string IS0 8601 intervals like ",(0,r.jsx)(t.code,{children:"[interval1, interval2,...]"}),"\u2014for example, ",(0,r.jsx)(t.code,{children:'["2012-01-01T00:00:00.000/2012-01-03T00:00:00.000", "2012-01-05T00:00:00.000/2012-01-07T00:00:00.000"]'}),"."]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/metadata/datasources/{dataSourceName}/segments?full"})}),"\n",(0,r.jsxs)(t.p,{children:["Returns a list of all segments, overlapping with any of given intervals, for a datasource with the full segment metadata as stored in the metadata store. Request body is array of string ISO 8601 intervals like ",(0,r.jsx)(t.code,{children:"[interval1, interval2,...]"}),"\u2014for example, ",(0,r.jsx)(t.code,{children:'["2012-01-01T00:00:00.000/2012-01-03T00:00:00.000", "2012-01-05T00:00:00.000/2012-01-07T00:00:00.000"]'}),"."]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"POST /druid/coordinator/v1/metadata/dataSourceInformation"})}),"\n",(0,r.jsx)(t.p,{children:"Returns information about the specified datasources, including the datasource schema."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"POST /druid/coordinator/v1/metadata/bootstrapSegments"})}),"\n",(0,r.jsx)(t.p,{children:"Returns information about bootstrap segments for all datasources. The returned set includes all broadcast segments if broadcast rules are configured."}),"\n",(0,r.jsx)("a",{name:"coordinator-datasources"}),"\n",(0,r.jsx)(t.h2,{id:"datasources",children:"Datasources"}),"\n",(0,r.jsxs)(t.p,{children:["Note that all ",(0,r.jsx)(t.em,{children:"interval"})," URL parameters are ISO 8601 strings delimited by a ",(0,r.jsx)(t.code,{children:"_"})," instead of a ",(0,r.jsx)(t.code,{children:"/"}),"\u2014for example, ",(0,r.jsx)(t.code,{children:"2016-06-27_2016-06-28"}),"."]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/datasources"})}),"\n",(0,r.jsxs)(t.p,{children:["Returns a list of datasource names found in the cluster as seen by the coordinator. This view is updated every ",(0,r.jsx)(t.a,{href:"/docs/33.0.0/configuration/#coordinator-operation",children:(0,r.jsx)(t.code,{children:"druid.coordinator.period"})}),"."]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/datasources?simple"})}),"\n",(0,r.jsx)(t.p,{children:"Returns a list of JSON objects containing the name and properties of datasources found in the cluster. Properties include segment count, total segment byte size, replicated total segment byte size, minTime, and maxTime."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/datasources?full"})}),"\n",(0,r.jsx)(t.p,{children:"Returns a list of datasource names found in the cluster with all metadata about those datasources."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/datasources/{dataSourceName}"})}),"\n",(0,r.jsx)(t.p,{children:"Returns a JSON object containing the name and properties of a datasource. Properties include segment count, total segment byte size, replicated total segment byte size, minTime, and maxTime."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/datasources/{dataSourceName}?full"})}),"\n",(0,r.jsx)(t.p,{children:"Returns full metadata for a datasource."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/datasources/{dataSourceName}/intervals"})}),"\n",(0,r.jsx)(t.p,{children:"Returns a set of segment intervals."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/datasources/{dataSourceName}/intervals?simple"})}),"\n",(0,r.jsx)(t.p,{children:"Returns a map of an interval to a JSON object containing the total byte size of segments and number of segments for that interval."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/datasources/{dataSourceName}/intervals?full"})}),"\n",(0,r.jsx)(t.p,{children:"Returns a map of an interval to a map of segment metadata to a set of server names that contain the segment for that interval."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/datasources/{dataSourceName}/intervals/{interval}"})}),"\n",(0,r.jsx)(t.p,{children:"Returns a set of segment ids for an interval."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/datasources/{dataSourceName}/intervals/{interval}?simple"})}),"\n",(0,r.jsx)(t.p,{children:"Returns a map of segment intervals contained within the specified interval to a JSON object containing the total byte size of segments and number of segments for an interval."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/datasources/{dataSourceName}/intervals/{interval}?full"})}),"\n",(0,r.jsx)(t.p,{children:"Returns a map of segment intervals contained within the specified interval to a map of segment metadata to a set of server names that contain the segment for an interval."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/datasources/{dataSourceName}/intervals/{interval}/serverview"})}),"\n",(0,r.jsx)(t.p,{children:"Returns a map of segment intervals contained within the specified interval to information about the servers that contain the segment for an interval."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/datasources/{dataSourceName}/segments"})}),"\n",(0,r.jsx)(t.p,{children:"Returns a list of all segments for a datasource in the cluster."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/datasources/{dataSourceName}/segments?full"})}),"\n",(0,r.jsx)(t.p,{children:"Returns a list of all segments for a datasource in the cluster with the full segment metadata."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/datasources/{dataSourceName}/segments/{segmentId}"})}),"\n",(0,r.jsx)(t.p,{children:"Returns full segment metadata for a specific segment in the cluster."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/datasources/{dataSourceName}/tiers"})}),"\n",(0,r.jsx)(t.p,{children:"Return the tiers that a datasource exists in."}),"\n",(0,r.jsx)(t.h2,{id:"intervals",children:"Intervals"}),"\n",(0,r.jsxs)(t.p,{children:["Note that all ",(0,r.jsx)(t.em,{children:"interval"})," URL parameters are ISO 8601 strings delimited by a ",(0,r.jsx)(t.code,{children:"_"})," instead of a ",(0,r.jsx)(t.code,{children:"/"})," as in ",(0,r.jsx)(t.code,{children:"2016-06-27_2016-06-28"}),"."]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/intervals"})}),"\n",(0,r.jsx)(t.p,{children:"Returns all intervals for all datasources with total size and count."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/intervals/{interval}"})}),"\n",(0,r.jsx)(t.p,{children:"Returns aggregated total size and count for all intervals that intersect given ISO interval."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/intervals/{interval}?simple"})}),"\n",(0,r.jsx)(t.p,{children:"Returns total size and count for each interval within given ISO interval."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/intervals/{interval}?full"})}),"\n",(0,r.jsx)(t.p,{children:"Returns total size and count for each datasource for each interval within given ISO interval."}),"\n",(0,r.jsx)(t.h2,{id:"server-information",children:"Server information"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/servers"})}),"\n",(0,r.jsxs)(t.p,{children:["Returns a list of servers URLs using the format ",(0,r.jsx)(t.code,{children:"{hostname}:{port}"}),". Note that\nprocesses that run with different types will appear multiple times with different\nports."]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/coordinator/v1/servers?simple"})}),"\n",(0,r.jsx)(t.p,{children:"Returns a list of server data objects in which each object has the following keys:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"host"}),": host URL include (",(0,r.jsx)(t.code,{children:"{hostname}:{port}"}),")"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"type"}),": process type (",(0,r.jsx)(t.code,{children:"indexer-executor"}),", ",(0,r.jsx)(t.code,{children:"historical"}),")"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"currSize"}),": storage size currently used"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"maxSize"}),": maximum storage size"]}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"priority"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"tier"})}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"query-server",children:"Query server"}),"\n",(0,r.jsxs)(t.p,{children:["This section documents the API endpoints for the services that reside on Query servers (Brokers) in the suggested ",(0,r.jsx)(t.a,{href:"/docs/33.0.0/design/architecture#druid-servers",children:"three-server configuration"}),"."]}),"\n",(0,r.jsx)(t.h3,{id:"broker",children:"Broker"}),"\n",(0,r.jsx)(t.h4,{id:"datasource-information",children:"Datasource information"}),"\n",(0,r.jsxs)(t.p,{children:["Note that all ",(0,r.jsx)(t.em,{children:"interval"})," URL parameters are ISO 8601 strings delimited by a ",(0,r.jsx)(t.code,{children:"_"})," instead of a ",(0,r.jsx)(t.code,{children:"/"}),"\nas in ",(0,r.jsx)(t.code,{children:"2016-06-27_2016-06-28"}),"."]}),"\n",(0,r.jsx)(t.admonition,{type:"info",children:(0,r.jsxs)(t.p,{children:["Note: Much of this information is available in a simpler, easier-to-use form through the Druid SQL\n",(0,r.jsx)(t.a,{href:"/docs/33.0.0/querying/sql-metadata-tables#tables-table",children:(0,r.jsx)(t.code,{children:"INFORMATION_SCHEMA.TABLES"})}),",\n",(0,r.jsx)(t.a,{href:"/docs/33.0.0/querying/sql-metadata-tables#columns-table",children:(0,r.jsx)(t.code,{children:"INFORMATION_SCHEMA.COLUMNS"})}),", and\n",(0,r.jsx)(t.a,{href:"/docs/33.0.0/querying/sql-metadata-tables#segments-table",children:(0,r.jsx)(t.code,{children:"sys.segments"})})," tables."]})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/v2/datasources"})}),"\n",(0,r.jsx)(t.p,{children:"Returns a list of queryable datasources."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/v2/datasources/{dataSourceName}"})}),"\n",(0,r.jsx)(t.p,{children:'Returns the dimensions and metrics of the datasource. Optionally, you can provide request parameter "full" to get list of served intervals with dimensions and metrics being served for those intervals. You can also provide request param "interval" explicitly to refer to a particular interval.'}),"\n",(0,r.jsxs)(t.p,{children:["If no interval is specified, a default interval spanning a configurable period before the current time will be used. The default duration of this interval is specified in ISO 8601 duration format via: ",(0,r.jsx)(t.code,{children:"druid.query.segmentMetadata.defaultHistory"})]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/v2/datasources/{dataSourceName}/dimensions"})}),"\n",(0,r.jsx)(t.admonition,{type:"info",children:(0,r.jsxs)(t.p,{children:["This API is deprecated and will be removed in future releases. Please use ",(0,r.jsx)(t.a,{href:"/docs/33.0.0/querying/segmentmetadataquery",children:"SegmentMetadataQuery"})," instead\nwhich provides more comprehensive information and supports all dataSource types including streaming dataSources. It's also encouraged to use ",(0,r.jsx)(t.a,{href:"/docs/33.0.0/querying/sql-metadata-tables",children:"INFORMATION_SCHEMA tables"}),"\nif you're using SQL."]})}),"\n",(0,r.jsx)(t.p,{children:"Returns the dimensions of the datasource."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/v2/datasources/{dataSourceName}/metrics"})}),"\n",(0,r.jsx)(t.admonition,{type:"info",children:(0,r.jsxs)(t.p,{children:["This API is deprecated and will be removed in future releases. Please use ",(0,r.jsx)(t.a,{href:"/docs/33.0.0/querying/segmentmetadataquery",children:"SegmentMetadataQuery"})," instead\nwhich provides more comprehensive information and supports all dataSource types including streaming dataSources. It's also encouraged to use ",(0,r.jsx)(t.a,{href:"/docs/33.0.0/querying/sql-metadata-tables",children:"INFORMATION_SCHEMA tables"}),"\nif you're using SQL."]})}),"\n",(0,r.jsx)(t.p,{children:"Returns the metrics of the datasource."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"GET /druid/v2/datasources/{dataSourceName}/candidates?intervals={comma-separated-intervals}&numCandidates={numCandidates}"})}),"\n",(0,r.jsx)(t.p,{children:'Returns segment information lists including server locations for the given datasource and intervals. If "numCandidates" is not specified, it will return all servers for each interval.'})]})}function h(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},28453:(e,t,a)=>{a.d(t,{R:()=>d,x:()=>i});var s=a(96540);const r={},n=s.createContext(r);function d(e){const t=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),s.createElement(n.Provider,{value:t},e.children)}}}]);