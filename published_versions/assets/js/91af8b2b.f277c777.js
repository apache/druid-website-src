"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[146],{20149:(e,o,r)=>{r.r(o),r.d(o,{assets:()=>s,contentTitle:()=>d,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"operations/clean-metadata-store","title":"Automated cleanup for metadata records","description":"Defines a strategy to maintain Druid metadata store performance by automatically removing leftover records for deleted entities: datasources, supervisors, rules, compaction configuration, audit records, etc. Most applicable to databases with \'high-churn\' datasources.","source":"@site/docs/33.0.0/operations/clean-metadata-store.md","sourceDirName":"operations","slug":"/operations/clean-metadata-store","permalink":"/docs/33.0.0/operations/clean-metadata-store","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"clean-metadata-store","title":"Automated cleanup for metadata records","sidebar_label":"Automated metadata cleanup","description":"Defines a strategy to maintain Druid metadata store performance by automatically removing leftover records for deleted entities: datasources, supervisors, rules, compaction configuration, audit records, etc. Most applicable to databases with \'high-churn\' datasources."},"sidebar":"docs","previous":{"title":"HTTP compression","permalink":"/docs/33.0.0/operations/http-compression"},"next":{"title":"Request logging","permalink":"/docs/33.0.0/operations/request-logging"}}');var t=r(74848),n=r(28453);const a={id:"clean-metadata-store",title:"Automated cleanup for metadata records",sidebar_label:"Automated metadata cleanup",description:"Defines a strategy to maintain Druid metadata store performance by automatically removing leftover records for deleted entities: datasources, supervisors, rules, compaction configuration, audit records, etc. Most applicable to databases with 'high-churn' datasources."},d=void 0,s={},l=[{value:"Automated cleanup strategies",id:"automated-cleanup-strategies",level:2},{value:"Configure automated metadata cleanup",id:"configure-automated-metadata-cleanup",level:2},{value:"Segment records and segments in deep storage (kill task)",id:"segment-records-and-segments-in-deep-storage-kill-task",level:3},{value:"Audit records",id:"audit-records",level:3},{value:"Supervisor records",id:"supervisor-records",level:3},{value:"Rules records",id:"rules-records",level:3},{value:"Compaction configuration records",id:"compaction-configuration-records",level:3},{value:"Datasource records created by supervisors",id:"datasource-records-created-by-supervisors",level:3},{value:"Indexer task logs",id:"indexer-task-logs",level:3},{value:"Disable automated metadata cleanup",id:"disable-automated-metadata-cleanup",level:2},{value:"Example configuration for automated metadata cleanup",id:"example-configuration-for-automated-metadata-cleanup",level:2},{value:"Learn more",id:"learn-more",level:2}];function c(e){const o={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,n.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(o.p,{children:["Apache Druid relies on ",(0,t.jsx)(o.a,{href:"/docs/33.0.0/design/metadata-storage",children:"metadata storage"})," to track information on data storage, operations, and system configuration.\nThe metadata store includes the following:"]}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsx)(o.li,{children:"Segment records"}),"\n",(0,t.jsx)(o.li,{children:"Audit records"}),"\n",(0,t.jsx)(o.li,{children:"Supervisor records"}),"\n",(0,t.jsx)(o.li,{children:"Rule records"}),"\n",(0,t.jsx)(o.li,{children:"Compaction configuration records"}),"\n",(0,t.jsx)(o.li,{children:"Datasource records created by supervisors"}),"\n",(0,t.jsx)(o.li,{children:"Indexer task logs"}),"\n"]}),"\n",(0,t.jsx)(o.p,{children:"When you delete some entities from Apache Druid, records related to the entity may remain in the metadata store.\nIf you have a high datasource churn rate, meaning you frequently create and delete many short-lived datasources or other related entities like compaction configuration or rules, the leftover records can fill your metadata store and cause performance issues.\nTo maintain metadata store performance, you can configure Apache Druid to automatically remove records associated with deleted entities from the metadata store."}),"\n",(0,t.jsxs)(o.p,{children:["By default, Druid automatically cleans up metadata older than 90 days.\nThis applies to all metadata entities in this topic except compaction configuration records and indexer task logs, for which cleanup is disabled by default.\nYou can configure the retention period for each metadata type, when available, through the record's ",(0,t.jsx)(o.code,{children:"durationToRetain"})," property.\nCertain records may require additional conditions be satisfied before clean up occurs."]}),"\n",(0,t.jsxs)(o.p,{children:["See the ",(0,t.jsx)(o.a,{href:"#example-configuration-for-automated-metadata-cleanup",children:"example"})," for how you can customize the automated metadata cleanup for a specific use case."]}),"\n",(0,t.jsx)(o.h2,{id:"automated-cleanup-strategies",children:"Automated cleanup strategies"}),"\n",(0,t.jsx)(o.p,{children:"There are several cases when you should consider automated cleanup of the metadata related to deleted datasources:"}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsx)(o.li,{children:"If you know you have many high-churn datasources, for example, you have scripts that create and delete supervisors regularly."}),"\n",(0,t.jsx)(o.li,{children:"If you have issues with the hard disk for your metadata database filling up."}),"\n",(0,t.jsx)(o.li,{children:"If you run into performance issues with the metadata database. For example, API calls are very slow or fail to execute."}),"\n"]}),"\n",(0,t.jsx)(o.p,{children:"If you have compliance requirements to keep audit records and you enable automated cleanup for audit records, use alternative methods to preserve audit metadata, for example, by periodically exporting audit metadata records to external storage."}),"\n",(0,t.jsx)(o.h2,{id:"configure-automated-metadata-cleanup",children:"Configure automated metadata cleanup"}),"\n",(0,t.jsxs)(o.p,{children:["You can configure cleanup for each entity separately, as described in this section.\nDefine the properties in the ",(0,t.jsx)(o.code,{children:"coordinator/runtime.properties"})," file."]}),"\n",(0,t.jsx)(o.p,{children:"The cleanup of one entity may depend on the cleanup of another entity as follows:"}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsxs)(o.li,{children:["You have to configure a ",(0,t.jsx)(o.a,{href:"#segment-records-and-segments-in-deep-storage-kill-task",children:"kill task for segment records"})," before you can configure automated cleanup for ",(0,t.jsx)(o.a,{href:"#rules-records",children:"rules"})," or ",(0,t.jsx)(o.a,{href:"#compaction-configuration-records",children:"compaction configuration"}),"."]}),"\n",(0,t.jsxs)(o.li,{children:["You have to schedule the metadata management tasks to run at the same or higher frequency as your most frequent cleanup job. For example, if your most frequent cleanup job is every hour, set the metadata store management period to one hour or less: ",(0,t.jsx)(o.code,{children:"druid.coordinator.period.metadataStoreManagementPeriod=P1H"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(o.p,{children:["For details on configuration properties, see ",(0,t.jsx)(o.a,{href:"/docs/33.0.0/configuration/#metadata-management",children:"Metadata management"}),".\nIf you want to skip the details, check out the ",(0,t.jsx)(o.a,{href:"#example-configuration-for-automated-metadata-cleanup",children:"example"})," for configuring automated metadata cleanup."]}),"\n",(0,t.jsx)(o.h3,{id:"segment-records-and-segments-in-deep-storage-kill-task",children:"Segment records and segments in deep storage (kill task)"}),"\n",(0,t.jsx)(o.admonition,{type:"info",children:(0,t.jsx)(o.p,{children:"The kill task is the only configuration in this topic that affects actual data in deep storage and not simply metadata or logs."})}),"\n",(0,t.jsx)(o.p,{children:"Segment records and segments in deep storage become eligible for deletion when both of the following conditions hold:"}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsxs)(o.li,{children:["When they meet the eligibility requirement of kill task datasource configuration according to ",(0,t.jsx)(o.code,{children:"killDataSourceWhitelist"})," set in the Coordinator dynamic configuration. See ",(0,t.jsx)(o.a,{href:"/docs/33.0.0/configuration/#dynamic-configuration",children:"Dynamic configuration"}),"."]}),"\n",(0,t.jsxs)(o.li,{children:["When the ",(0,t.jsx)(o.code,{children:"durationToRetain"})," time has passed since their creation."]}),"\n"]}),"\n",(0,t.jsx)(o.p,{children:"Kill tasks use the following configuration:"}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"druid.coordinator.kill.on"}),": When ",(0,t.jsx)(o.code,{children:"true"}),", enables the Coordinator to submit a kill task for unused segments, which deletes them completely from metadata store and from deep storage.\nOnly applies to the specified datasources in the dynamic configuration parameter ",(0,t.jsx)(o.code,{children:"killDataSourceWhitelist"}),".\nIf ",(0,t.jsx)(o.code,{children:"killDataSourceWhitelist"})," is not set or empty, then kill tasks can be submitted for all datasources."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"druid.coordinator.kill.period"}),": Defines the frequency in ",(0,t.jsx)(o.a,{href:"https://en.wikipedia.org/wiki/ISO_8601#Durations",children:"ISO 8601 format"})," for the cleanup job to check for and delete eligible segments. Defaults to ",(0,t.jsx)(o.code,{children:"druid.coordinator.period.indexingPeriod"}),". Must be greater than or equal to ",(0,t.jsx)(o.code,{children:"druid.coordinator.period.indexingPeriod"}),"."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"druid.coordinator.kill.durationToRetain"}),": Defines the retention period in ",(0,t.jsx)(o.a,{href:"https://en.wikipedia.org/wiki/ISO_8601#Durations",children:"ISO 8601 format"})," after creation that segments become eligible for deletion."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"druid.coordinator.kill.ignoreDurationToRetain"}),": A way to override ",(0,t.jsx)(o.code,{children:"druid.coordinator.kill.durationToRetain"}),". When enabled, the coordinator considers all unused segments as eligible to be killed."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"druid.coordinator.kill.bufferPeriod"}),": Defines the amount of time that a segment must be unused before it can be permanently removed from metadata and deep storage. This serves as a buffer period to prevent data loss if data ends up being needed after being marked unused."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"druid.coordinator.kill.maxSegments"}),": Defines the maximum number of segments to delete per kill task."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"druid.coordinator.kill.maxInterval"}),": Defines the largest interval, as an ",(0,t.jsx)(o.a,{href:"https://en.wikipedia.org/wiki/ISO_8601#Durations",children:"ISO 8601 duration"}),", of segments to delete per kill task. Set to zero, e.g. ",(0,t.jsx)(o.code,{children:"PT0S"}),", for unlimited."]}),"\n"]}),"\n",(0,t.jsx)(o.h3,{id:"audit-records",children:"Audit records"}),"\n",(0,t.jsxs)(o.p,{children:["All audit records become eligible for deletion when the ",(0,t.jsx)(o.code,{children:"durationToRetain"})," time has passed since their creation."]}),"\n",(0,t.jsx)(o.p,{children:"Audit cleanup uses the following configuration:"}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"druid.coordinator.kill.audit.on"}),": When ",(0,t.jsx)(o.code,{children:"true"}),", enables cleanup for audit records."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"druid.coordinator.kill.audit.period"}),": Defines the frequency in ",(0,t.jsx)(o.a,{href:"https://en.wikipedia.org/wiki/ISO_8601#Durations",children:"ISO 8601 format"})," for the cleanup job to check for and delete eligible audit records. Defaults to ",(0,t.jsx)(o.code,{children:"P1D"}),"."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"druid.coordinator.kill.audit.durationToRetain"}),": Defines the retention period in ",(0,t.jsx)(o.a,{href:"https://en.wikipedia.org/wiki/ISO_8601#Durations",children:"ISO 8601 format"})," after creation that audit records become eligible for deletion."]}),"\n"]}),"\n",(0,t.jsx)(o.h3,{id:"supervisor-records",children:"Supervisor records"}),"\n",(0,t.jsxs)(o.p,{children:["Supervisor records become eligible for deletion when the supervisor is terminated and the ",(0,t.jsx)(o.code,{children:"durationToRetain"})," time has passed since their creation."]}),"\n",(0,t.jsx)(o.p,{children:"Supervisor cleanup uses the following configuration:"}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"druid.coordinator.kill.supervisor.on"}),": When ",(0,t.jsx)(o.code,{children:"true"}),", enables cleanup for supervisor records."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"druid.coordinator.kill.supervisor.period"}),": Defines the frequency in ",(0,t.jsx)(o.a,{href:"https://en.wikipedia.org/wiki/ISO_8601#Durations",children:"ISO 8601 format"})," for the cleanup job to check for and delete eligible supervisor records. Defaults to ",(0,t.jsx)(o.code,{children:"P1D"}),"."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"druid.coordinator.kill.supervisor.durationToRetain"}),": Defines the retention period in ",(0,t.jsx)(o.a,{href:"https://en.wikipedia.org/wiki/ISO_8601#Durations",children:"ISO 8601 format"})," after creation that supervisor records become eligible for deletion."]}),"\n"]}),"\n",(0,t.jsx)(o.h3,{id:"rules-records",children:"Rules records"}),"\n",(0,t.jsxs)(o.p,{children:["Rule records become eligible for deletion when all segments for the datasource have been killed by the kill task and the ",(0,t.jsx)(o.code,{children:"durationToRetain"})," time has passed since their creation. Automated cleanup for rules requires a ",(0,t.jsx)(o.a,{href:"#segment-records-and-segments-in-deep-storage-kill-task",children:"kill task"}),"."]}),"\n",(0,t.jsx)(o.p,{children:"Rule cleanup uses the following configuration:"}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"druid.coordinator.kill.rule.on"}),": When ",(0,t.jsx)(o.code,{children:"true"}),", enables cleanup for rules records."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"druid.coordinator.kill.rule.period"}),": Defines the frequency in ",(0,t.jsx)(o.a,{href:"https://en.wikipedia.org/wiki/ISO_8601#Durations",children:"ISO 8601 format"})," for the cleanup job to check for and delete eligible rules records. Defaults to ",(0,t.jsx)(o.code,{children:"P1D"}),"."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"druid.coordinator.kill.rule.durationToRetain"}),": Defines the retention period in ",(0,t.jsx)(o.a,{href:"https://en.wikipedia.org/wiki/ISO_8601#Durations",children:"ISO 8601 format"})," after creation that rules records become eligible for deletion."]}),"\n"]}),"\n",(0,t.jsx)(o.h3,{id:"compaction-configuration-records",children:"Compaction configuration records"}),"\n",(0,t.jsx)(o.p,{children:"Druid retains all compaction configuration records by default, which should be suitable for most use cases.\nIf you create and delete short-lived datasources with high frequency, and you set auto compaction configuration on those datasources, then consider turning on automated cleanup of compaction configuration records."}),"\n",(0,t.jsx)(o.admonition,{type:"info",children:(0,t.jsx)(o.p,{children:"With automated cleanup of compaction configuration records, if you create a compaction configuration for some datasource before the datasource exists, for example if initial ingestion is still ongoing, Druid may remove the compaction configuration.\nTo prevent the configuration from being prematurely removed, wait for the datasource to be created before applying the compaction configuration to the datasource."})}),"\n",(0,t.jsxs)(o.p,{children:["Unlike other metadata records, compaction configuration records do not have a retention period set by ",(0,t.jsx)(o.code,{children:"durationToRetain"}),". Druid deletes compaction configuration records at every cleanup cycle for inactive datasources, which do not have segments either used or unused."]}),"\n",(0,t.jsxs)(o.p,{children:["Compaction configuration records in the ",(0,t.jsx)(o.code,{children:"druid_config"})," table become eligible for deletion after all segments for the datasource have been killed by the kill task. Automated cleanup for compaction configuration requires a ",(0,t.jsx)(o.a,{href:"#segment-records-and-segments-in-deep-storage-kill-task",children:"kill task"}),"."]}),"\n",(0,t.jsx)(o.p,{children:"Compaction configuration cleanup uses the following configuration:"}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"druid.coordinator.kill.compaction.on"}),": When ",(0,t.jsx)(o.code,{children:"true"}),", enables cleanup for compaction configuration records."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"druid.coordinator.kill.compaction.period"}),": Defines the frequency in ",(0,t.jsx)(o.a,{href:"https://en.wikipedia.org/wiki/ISO_8601#Durations",children:"ISO 8601 format"})," for the cleanup job to check for and delete eligible compaction configuration records. Defaults to ",(0,t.jsx)(o.code,{children:"P1D"}),"."]}),"\n"]}),"\n",(0,t.jsx)(o.admonition,{type:"info",children:(0,t.jsxs)(o.p,{children:["If you already have an extremely large compaction configuration, you may not be able to delete compaction configuration due to size limits with the audit log. In this case you can set ",(0,t.jsx)(o.code,{children:"druid.audit.manager.maxPayloadSizeBytes"})," and ",(0,t.jsx)(o.code,{children:"druid.audit.manager.skipNullField"})," to avoid the auditing issue. See ",(0,t.jsx)(o.a,{href:"/docs/33.0.0/configuration/#audit-logging",children:"Audit logging"}),"."]})}),"\n",(0,t.jsx)(o.h3,{id:"datasource-records-created-by-supervisors",children:"Datasource records created by supervisors"}),"\n",(0,t.jsxs)(o.p,{children:["Datasource records created by supervisors become eligible for deletion when the supervisor is terminated or does not exist in the ",(0,t.jsx)(o.code,{children:"druid_supervisors"})," table and the ",(0,t.jsx)(o.code,{children:"durationToRetain"})," time has passed since their creation."]}),"\n",(0,t.jsx)(o.p,{children:"Datasource cleanup uses the following configuration:"}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"druid.coordinator.kill.datasource.on"}),": When ",(0,t.jsx)(o.code,{children:"true"}),", enables cleanup datasources created by supervisors."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"druid.coordinator.kill.datasource.period"}),": Defines the frequency in ",(0,t.jsx)(o.a,{href:"https://en.wikipedia.org/wiki/ISO_8601#Durations",children:"ISO 8601 format"})," for the cleanup job to check for and delete eligible datasource records. Defaults to ",(0,t.jsx)(o.code,{children:"P1D"}),"."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"druid.coordinator.kill.datasource.durationToRetain"}),": Defines the retention period in ",(0,t.jsx)(o.a,{href:"https://en.wikipedia.org/wiki/ISO_8601#Durations",children:"ISO 8601 format"})," after creation that datasource records become eligible for deletion."]}),"\n"]}),"\n",(0,t.jsx)(o.h3,{id:"indexer-task-logs",children:"Indexer task logs"}),"\n",(0,t.jsx)(o.p,{children:"You can configure the Overlord to periodically delete indexer task logs and associated metadata. During cleanup, the Overlord removes the following:"}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsx)(o.li,{children:"Indexer task logs from deep storage."}),"\n",(0,t.jsxs)(o.li,{children:["Indexer task log metadata from the tasks table in ",(0,t.jsx)(o.a,{href:"/docs/33.0.0/configuration/#metadata-storage",children:"metadata storage"})," (named ",(0,t.jsx)(o.code,{children:"druid_tasks"})," by default)."]}),"\n"]}),"\n",(0,t.jsxs)(o.p,{children:["To configure cleanup of task logs by the Overlord, set the following properties in the ",(0,t.jsx)(o.code,{children:"overlord/runtime.properties"})," file."]}),"\n",(0,t.jsx)(o.p,{children:"Indexer task log cleanup on the Overlord uses the following configuration:"}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"druid.indexer.logs.kill.enabled"}),": When ",(0,t.jsx)(o.code,{children:"true"}),", enables cleanup of task logs."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"druid.indexer.logs.kill.durationToRetain"}),": Defines the length of time in milliseconds to retain task logs."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"druid.indexer.logs.kill.initialDelay"}),": Defines the length of time in milliseconds after the Overlord starts before it executes its first job to kill task logs."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"druid.indexer.logs.kill.delay"}),": The length of time in milliseconds between jobs to kill task logs."]}),"\n"]}),"\n",(0,t.jsxs)(o.p,{children:["For more detail, see ",(0,t.jsx)(o.a,{href:"/docs/33.0.0/configuration/#task-logging",children:"Task logging"}),"."]}),"\n",(0,t.jsx)(o.h2,{id:"disable-automated-metadata-cleanup",children:"Disable automated metadata cleanup"}),"\n",(0,t.jsxs)(o.p,{children:["Druid automatically cleans up metadata records, excluding compaction configuration records and indexer task logs.\nTo disable automated metadata cleanup, set the following properties in the ",(0,t.jsx)(o.code,{children:"coordinator/runtime.properties"})," file:"]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-properties",children:"# Keep unused segments\ndruid.coordinator.kill.on=false\n\n# Keep audit records\ndruid.coordinator.kill.audit.on=false\n\n# Keep supervisor records\ndruid.coordinator.kill.supervisor.on=false\n\n# Keep rules records\ndruid.coordinator.kill.rule.on=false\n\n# Keep datasource records created by supervisors\ndruid.coordinator.kill.datasource.on=false\n"})}),"\n",(0,t.jsx)(o.h2,{id:"example-configuration-for-automated-metadata-cleanup",children:"Example configuration for automated metadata cleanup"}),"\n",(0,t.jsx)(o.p,{children:"Consider a scenario where you have scripts to create and delete hundreds of datasources and related entities a day. You do not want to fill your metadata store with leftover records. The datasources and related entities tend to persist for only one or two days. Therefore, you want to run a cleanup job that identifies and removes leftover records that are at least four days old after a seven day buffer period in case you want to recover the data. The exception is for audit logs, which you need to retain for 30 days:"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-properties",children:"...\n# Schedule the metadata management store task for every hour:\ndruid.coordinator.period.metadataStoreManagementPeriod=PT1H\n\n# Set a kill task to poll every day to delete segment records and segments\n# in deep storage > 4 days old after a 7-day buffer period. When druid.coordinator.kill.on is set to true,\n# you can set killDataSourceWhitelist in the dynamic configuration to limit\n# the datasources that can be killed.\n# Required also for automated cleanup of rules and compaction configuration.\n\ndruid.coordinator.kill.on=true\ndruid.coordinator.kill.period=P1D\ndruid.coordinator.kill.durationToRetain=P4D\ndruid.coordinator.kill.bufferPeriod=P7D\ndruid.coordinator.kill.maxSegments=1000\n\n# Poll every day to delete audit records > 30 days old\ndruid.coordinator.kill.audit.on=true\ndruid.coordinator.kill.audit.period=P1D\ndruid.coordinator.kill.audit.durationToRetain=P30D\n\n# Poll every day to delete supervisor records > 4 days old\ndruid.coordinator.kill.supervisor.on=true\ndruid.coordinator.kill.supervisor.period=P1D\ndruid.coordinator.kill.supervisor.durationToRetain=P4D\n\n# Poll every day to delete rules records > 4 days old\ndruid.coordinator.kill.rule.on=true\ndruid.coordinator.kill.rule.period=P1D\ndruid.coordinator.kill.rule.durationToRetain=P4D\n\n# Poll every day to delete compaction configuration records\ndruid.coordinator.kill.compaction.on=true\ndruid.coordinator.kill.compaction.period=P1D\n\n# Poll every day to delete datasource records created by supervisors > 4 days old\ndruid.coordinator.kill.datasource.on=true\ndruid.coordinator.kill.datasource.period=P1D\ndruid.coordinator.kill.datasource.durationToRetain=P4D\n...\n"})}),"\n",(0,t.jsx)(o.h2,{id:"learn-more",children:"Learn more"}),"\n",(0,t.jsx)(o.p,{children:"See the following topics for more information:"}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.a,{href:"/docs/33.0.0/configuration/#metadata-management",children:"Metadata management"})," for metadata store configuration reference."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.a,{href:"/docs/33.0.0/design/metadata-storage",children:"Metadata storage"})," for an overview of the metadata storage database."]}),"\n"]})]})}function u(e={}){const{wrapper:o}={...(0,n.R)(),...e.components};return o?(0,t.jsx)(o,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},28453:(e,o,r)=>{r.d(o,{R:()=>a,x:()=>d});var i=r(96540);const t={},n=i.createContext(t);function a(e){const o=i.useContext(n);return i.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function d(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(n.Provider,{value:o},e.children)}}}]);