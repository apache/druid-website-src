"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6728],{28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var a=t(96540);const i={},o=a.createContext(i);function s(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(o.Provider,{value:n},e.children)}},31877:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>u,frontMatter:()=>s,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"comparisons/druid-vs-sql-on-hadoop","title":"Apache Druid vs SQL-on-Hadoop","description":"\x3c!--","source":"@site/docs/latest/comparisons/druid-vs-sql-on-hadoop.md","sourceDirName":"comparisons","slug":"/comparisons/druid-vs-sql-on-hadoop","permalink":"/docs/latest/comparisons/druid-vs-sql-on-hadoop","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"druid-vs-sql-on-hadoop","title":"Apache Druid vs SQL-on-Hadoop"}}');var i=t(74848),o=t(28453);const s={id:"druid-vs-sql-on-hadoop",title:"Apache Druid vs SQL-on-Hadoop"},r=void 0,d={},l=[{value:"Queries",id:"queries",level:3},{value:"Data Ingestion",id:"data-ingestion",level:3},{value:"Query Flexibility",id:"query-flexibility",level:3},{value:"Druid vs Parquet",id:"druid-vs-parquet",level:2}];function c(e){const n={h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"SQL-on-Hadoop engines provide an\nexecution engine for various data formats and data stores, and\nmany can be made to push down computations down to Druid, while providing a SQL interface to Druid."}),"\n",(0,i.jsx)(n.p,{children:"For a direct comparison between the technologies and when to only use one or the other, things basically comes down to your\nproduct requirements and what the systems were designed to do."}),"\n",(0,i.jsx)(n.p,{children:"Druid was designed to"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"be an always on service"}),"\n",(0,i.jsx)(n.li,{children:"ingest data in real-time"}),"\n",(0,i.jsx)(n.li,{children:"handle slice-n-dice style ad-hoc queries"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"SQL-on-Hadoop engines generally sidestep Map/Reduce, instead querying data directly from HDFS or, in some cases, other storage systems.\nSome of these engines (including Impala and Presto) can be co-located with HDFS data nodes and coordinate with them to achieve data locality for queries.\nWhat does this mean?  We can talk about it in terms of three general areas"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Queries"}),"\n",(0,i.jsx)(n.li,{children:"Data Ingestion"}),"\n",(0,i.jsx)(n.li,{children:"Query Flexibility"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"queries",children:"Queries"}),"\n",(0,i.jsx)(n.p,{children:"Druid segments stores data in a custom column format. Segments are scanned directly as part of queries and each Druid server\ncalculates a set of results that are eventually merged at the Broker level. This means the data that is transferred between servers\nare queries and results, and all computation is done internally as part of the Druid servers."}),"\n",(0,i.jsx)(n.p,{children:"Most SQL-on-Hadoop engines are responsible for query planning and execution for underlying storage layers and storage formats.\nThey are processes that stay on even if there is no query running (eliminating the JVM startup costs from Hadoop MapReduce).\nSome (Impala/Presto) SQL-on-Hadoop engines have daemon processes that can be run where the data is stored, virtually eliminating network transfer costs. There is still\nsome latency overhead (e.g. serialization/deserialization time) associated with pulling data from the underlying storage layer into the computation layer. We are unaware of exactly\nhow much of a performance impact this makes."}),"\n",(0,i.jsx)(n.h3,{id:"data-ingestion",children:"Data Ingestion"}),"\n",(0,i.jsx)(n.p,{children:"Druid is built to allow for real-time ingestion of data.  You can ingest data and query it immediately upon ingestion,\nthe latency between how quickly the event is reflected in the data is dominated by how long it takes to deliver the event to Druid."}),"\n",(0,i.jsx)(n.p,{children:"SQL-on-Hadoop, being based on data in HDFS or some other backing store, are limited in their data ingestion rates by the\nrate at which that backing store can make data available.  Generally, the backing store is the biggest bottleneck for\nhow quickly data can become available."}),"\n",(0,i.jsx)(n.h3,{id:"query-flexibility",children:"Query Flexibility"}),"\n",(0,i.jsx)(n.p,{children:"Druid's query language is fairly low level and maps to how Druid operates internally. Although Druid can be combined with a high level query\nplanner to support most SQL queries and analytic SQL queries (minus joins among large tables),\nbase Druid is less flexible than SQL-on-Hadoop solutions for generic processing."}),"\n",(0,i.jsx)(n.p,{children:"SQL-on-Hadoop support SQL style queries with full joins."}),"\n",(0,i.jsx)(n.h2,{id:"druid-vs-parquet",children:"Druid vs Parquet"}),"\n",(0,i.jsx)(n.p,{children:"Parquet is a column storage format that is designed to work with SQL-on-Hadoop engines. Parquet doesn't have a query execution engine, and instead\nrelies on external sources to pull data out of it."}),"\n",(0,i.jsx)(n.p,{children:"Druid's storage format is highly optimized for linear scans. Although Druid has support for nested data, Parquet's storage format is much\nmore hierarchical, and is more designed for binary chunking. In theory, this should lead to faster scans in Druid."})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);