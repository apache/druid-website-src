"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7662],{28453:(e,r,n)=>{n.d(r,{R:()=>s,x:()=>a});var t=n(96540);const i={},o=t.createContext(i);function s(e){const r=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(o.Provider,{value:r},e.children)}},35807:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"design/router","title":"Router service","description":"\x3c!--","source":"@site/docs/33.0.0/design/router.md","sourceDirName":"design","slug":"/design/router","permalink":"/docs/33.0.0/design/router","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"router","title":"Router service","sidebar_label":"Router"},"sidebar":"docs","previous":{"title":"Broker","permalink":"/docs/33.0.0/design/broker"},"next":{"title":"Historical","permalink":"/docs/33.0.0/design/historical"}}');var i=n(74848),o=n(28453);const s={id:"router",title:"Router service",sidebar_label:"Router"},a=void 0,d={},c=[{value:"Configuration",id:"configuration",level:2},{value:"HTTP endpoints",id:"http-endpoints",level:2},{value:"Running",id:"running",level:2},{value:"Router as management proxy",id:"router-as-management-proxy",level:2},{value:"Enable the management proxy",id:"enable-the-management-proxy",level:3},{value:"Management proxy routing",id:"management-proxy-routing",level:3},{value:"Router strategies",id:"router-strategies",level:2},{value:"timeBoundary",id:"timeboundary",level:3},{value:"priority",id:"priority",level:3},{value:"manual",id:"manual",level:3},{value:"JavaScript",id:"javascript",level:3},{value:"Routing of SQL queries using strategies",id:"routing-of-sql-queries-using-strategies",level:2},{value:"Avatica query balancing",id:"avatica-query-balancing",level:2},{value:"Rendezvous hash balancer",id:"rendezvous-hash-balancer",level:3},{value:"Consistent hash balancer",id:"consistent-hash-balancer",level:3},{value:"Example production configuration",id:"example-production-configuration",level:2}];function l(e){const r={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.p,{children:["The Router service distributes queries between different Broker services. By default, the Broker routes queries based on preconfigured ",(0,i.jsx)(r.a,{href:"/docs/33.0.0/operations/rule-configuration",children:"data retention rules"}),". For example, if one month of recent data is loaded into a ",(0,i.jsx)(r.code,{children:"hot"})," cluster, queries that fall within the recent month can be routed to a dedicated set of Brokers. Queries outside this range are routed to another set of Brokers. This set up provides query isolation such that queries for more important data are not impacted by queries for less important data."]}),"\n",(0,i.jsx)(r.p,{children:"For query routing purposes, you should only ever need the Router service if you have a Druid cluster well into the terabyte range."}),"\n",(0,i.jsxs)(r.p,{children:["In addition to query routing, the Router also runs the ",(0,i.jsx)(r.a,{href:"/docs/33.0.0/operations/web-console",children:"web console"}),", a UI for loading data, managing datasources and tasks, and viewing server status and segment information."]}),"\n",(0,i.jsx)(r.h2,{id:"configuration",children:"Configuration"}),"\n",(0,i.jsxs)(r.p,{children:["For Apache Druid Router service configuration, see ",(0,i.jsx)(r.a,{href:"/docs/33.0.0/configuration/#router",children:"Router configuration"}),"."]}),"\n",(0,i.jsxs)(r.p,{children:["For basic tuning guidance for the Router service, see ",(0,i.jsx)(r.a,{href:"/docs/33.0.0/operations/basic-cluster-tuning#router",children:"Basic cluster tuning"}),"."]}),"\n",(0,i.jsx)(r.h2,{id:"http-endpoints",children:"HTTP endpoints"}),"\n",(0,i.jsxs)(r.p,{children:["For a list of API endpoints supported by the Router, see ",(0,i.jsx)(r.a,{href:"/docs/33.0.0/api-reference/legacy-metadata-api#datasource-information",children:"Legacy metadata API reference"}),"."]}),"\n",(0,i.jsx)(r.h2,{id:"running",children:"Running"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:"org.apache.druid.cli.Main server router\n"})}),"\n",(0,i.jsx)(r.h2,{id:"router-as-management-proxy",children:"Router as management proxy"}),"\n",(0,i.jsx)(r.p,{children:"You can configure the Router to forward requests to the active Coordinator or Overlord service. This may be useful for\nsetting up a highly available cluster in situations where the HTTP redirect mechanism of the inactive to active\nCoordinator or Overlord service does not function correctly, such as when servers are behind a load balancer or the hostname used in the redirect is only resolvable internally."}),"\n",(0,i.jsx)(r.h3,{id:"enable-the-management-proxy",children:"Enable the management proxy"}),"\n",(0,i.jsxs)(r.p,{children:["To enable the management proxy, set the following in the Router's ",(0,i.jsx)(r.code,{children:"runtime.properties"}),":"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:"druid.router.managementProxy.enabled=true\n"})}),"\n",(0,i.jsx)(r.h3,{id:"management-proxy-routing",children:"Management proxy routing"}),"\n",(0,i.jsxs)(r.p,{children:["The management proxy supports implicit and explicit routes. Implicit routes are those where the destination can be\ndetermined from the original request path based on Druid API path conventions. For the Coordinator the convention is\n",(0,i.jsx)(r.code,{children:"/druid/coordinator/*"})," and for the Overlord the convention is ",(0,i.jsx)(r.code,{children:"/druid/indexer/*"}),". These are convenient because they mean\nthat using the management proxy does not require modifying the API request other than issuing the request to the Router\ninstead of the Coordinator or Overlord. Most Druid API requests can be routed implicitly."]}),"\n",(0,i.jsxs)(r.p,{children:["Explicit routes are those where the request to the Router contains a path prefix indicating which service the request\nshould be routed to. For the Coordinator this prefix is ",(0,i.jsx)(r.code,{children:"/proxy/coordinator"})," and for the Overlord it is ",(0,i.jsx)(r.code,{children:"/proxy/overlord"}),".\nThis is required for API calls with an ambiguous destination. For example, the ",(0,i.jsx)(r.code,{children:"/status"})," API is present on all Druid\nservices, so explicit routing needs to be used to indicate the proxy destination."]}),"\n",(0,i.jsx)(r.p,{children:"This is summarized in the table below:"}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Request Route"}),(0,i.jsx)(r.th,{children:"Destination"}),(0,i.jsx)(r.th,{children:"Rewritten Route"}),(0,i.jsx)(r.th,{children:"Example"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"/druid/coordinator/*"})}),(0,i.jsx)(r.td,{children:"Coordinator"}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"/druid/coordinator/*"})}),(0,i.jsxs)(r.td,{children:[(0,i.jsx)(r.code,{children:"router:8888/druid/coordinator/v1/datasources"})," -> ",(0,i.jsx)(r.code,{children:"coordinator:8081/druid/coordinator/v1/datasources"})]})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"/druid/indexer/*"})}),(0,i.jsx)(r.td,{children:"Overlord"}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"/druid/indexer/*"})}),(0,i.jsxs)(r.td,{children:[(0,i.jsx)(r.code,{children:"router:8888/druid/indexer/v1/task"})," -> ",(0,i.jsx)(r.code,{children:"overlord:8090/druid/indexer/v1/task"})]})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"/proxy/coordinator/*"})}),(0,i.jsx)(r.td,{children:"Coordinator"}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"/*"})}),(0,i.jsxs)(r.td,{children:[(0,i.jsx)(r.code,{children:"router:8888/proxy/coordinator/status"})," -> ",(0,i.jsx)(r.code,{children:"coordinator:8081/status"})]})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"/proxy/overlord/*"})}),(0,i.jsx)(r.td,{children:"Overlord"}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"/*"})}),(0,i.jsxs)(r.td,{children:[(0,i.jsx)(r.code,{children:"router:8888/proxy/overlord/druid/indexer/v1/isLeader"})," -> ",(0,i.jsx)(r.code,{children:"overlord:8090/druid/indexer/v1/isLeader"})]})]})]})]}),"\n",(0,i.jsx)(r.h2,{id:"router-strategies",children:"Router strategies"}),"\n",(0,i.jsx)(r.p,{children:"The Router has a configurable list of strategies to determine which Brokers to route queries to. The order of the strategies is important because the Broker is selected immediately after the strategy condition is satisfied."}),"\n",(0,i.jsx)(r.h3,{id:"timeboundary",children:"timeBoundary"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-json",children:'{\n  "type":"timeBoundary"\n}\n'})}),"\n",(0,i.jsxs)(r.p,{children:["Including this strategy means all ",(0,i.jsx)(r.code,{children:"timeBoundary"})," queries are always routed to the highest priority Broker."]}),"\n",(0,i.jsx)(r.h3,{id:"priority",children:"priority"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-json",children:'{\n  "type":"priority",\n  "minPriority":0,\n  "maxPriority":1\n}\n'})}),"\n",(0,i.jsxs)(r.p,{children:["Queries with a priority set to less than ",(0,i.jsx)(r.code,{children:"minPriority"})," are routed to the lowest priority Broker. Queries with priority set to greater than ",(0,i.jsx)(r.code,{children:"maxPriority"})," are routed to the highest priority Broker. By default, ",(0,i.jsx)(r.code,{children:"minPriority"})," is 0 and ",(0,i.jsx)(r.code,{children:"maxPriority"})," is 1. Using these default values, if a query with priority 0 (the default query priority is 0) is sent, the query skips the priority selection logic."]}),"\n",(0,i.jsx)(r.h3,{id:"manual",children:"manual"}),"\n",(0,i.jsxs)(r.p,{children:["This strategy reads the parameter ",(0,i.jsx)(r.code,{children:"brokerService"})," from the query context and routes the query to that broker service. If no valid ",(0,i.jsx)(r.code,{children:"brokerService"})," is specified in the query context, the field ",(0,i.jsx)(r.code,{children:"defaultManualBrokerService"})," is used to determine target broker service given the value is valid and non-null. A value is considered valid if it is present in ",(0,i.jsx)(r.code,{children:"druid.router.tierToBrokerMap"}),".\nThis strategy can route both native and SQL queries."]}),"\n",(0,i.jsxs)(r.p,{children:["The following example strategy routes queries to the Broker ",(0,i.jsx)(r.code,{children:"druid:broker-hot"})," if no valid ",(0,i.jsx)(r.code,{children:"brokerService"})," is found in the query context."]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-json",children:'{\n  "type": "manual",\n  "defaultManualBrokerService": "druid:broker-hot"\n}\n'})}),"\n",(0,i.jsx)(r.h3,{id:"javascript",children:"JavaScript"}),"\n",(0,i.jsx)(r.p,{children:"Allows defining arbitrary routing rules using a JavaScript function. The function takes the configuration and the query to be executed, and returns the tier it should be routed to, or null for the default tier."}),"\n",(0,i.jsx)(r.p,{children:"The following example function sends queries containing more than three aggregators to the lowest priority Broker."}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-json",children:'{\n  "type" : "javascript",\n  "function" : "function (config, query) { if (query.getAggregatorSpecs && query.getAggregatorSpecs().size() >= 3) { var size = config.getTierToBrokerMap().values().size(); if (size > 0) { return config.getTierToBrokerMap().values().toArray()[size-1] } else { return config.getDefaultBrokerServiceName() } } else { return null } }"\n}\n'})}),"\n",(0,i.jsx)(r.admonition,{type:"info",children:(0,i.jsxs)(r.p,{children:["JavaScript-based functionality is disabled by default. Please refer to the Druid ",(0,i.jsx)(r.a,{href:"/docs/33.0.0/development/javascript",children:"JavaScript programming guide"})," for guidelines about using Druid's JavaScript functionality, including instructions on how to enable it."]})}),"\n",(0,i.jsx)(r.h2,{id:"routing-of-sql-queries-using-strategies",children:"Routing of SQL queries using strategies"}),"\n",(0,i.jsxs)(r.p,{children:["To enable routing of SQL queries using strategies, set ",(0,i.jsx)(r.code,{children:"druid.router.sql.enable"})," to ",(0,i.jsx)(r.code,{children:"true"}),". The Broker service for a\ngiven SQL query is resolved using only the provided Router strategies. If not resolved using any of the strategies, the\nRouter uses the ",(0,i.jsx)(r.code,{children:"defaultBrokerServiceName"}),". This behavior is slightly different from native queries where the Router\nfirst tries to resolve the Broker service using strategies, then load rules and finally using the ",(0,i.jsx)(r.code,{children:"defaultBrokerServiceName"}),"\nif still not resolved. When ",(0,i.jsx)(r.code,{children:"druid.router.sql.enable"})," is set to ",(0,i.jsx)(r.code,{children:"false"})," (default value), the Router uses the\n",(0,i.jsx)(r.code,{children:"defaultBrokerServiceName"}),"."]}),"\n",(0,i.jsxs)(r.p,{children:["Setting ",(0,i.jsx)(r.code,{children:"druid.router.sql.enable"})," does not affect either Avatica JDBC requests or native queries.\nDruid always routes native queries using the strategies and load rules as documented.\nDruid always routes Avatica JDBC requests based on connection ID."]}),"\n",(0,i.jsx)(r.h2,{id:"avatica-query-balancing",children:"Avatica query balancing"}),"\n",(0,i.jsx)(r.p,{children:"All Avatica JDBC requests with a given connection ID must be routed to the same Broker, since Druid Brokers do not share connection state with each other."}),"\n",(0,i.jsx)(r.p,{children:"To accomplish this, Druid provides two built-in balancers that use rendezvous hashing and consistent hashing of a request's connection ID respectively to assign requests to Brokers."}),"\n",(0,i.jsx)(r.p,{children:"Note that when multiple Routers are used, all Routers should have identical balancer configuration to ensure that they make the same routing decisions."}),"\n",(0,i.jsx)(r.h3,{id:"rendezvous-hash-balancer",children:"Rendezvous hash balancer"}),"\n",(0,i.jsxs)(r.p,{children:["This balancer uses ",(0,i.jsx)(r.a,{href:"https://en.wikipedia.org/wiki/Rendezvous_hashing",children:"Rendezvous Hashing"})," on an Avatica request's connection ID to assign the request to a Broker."]}),"\n",(0,i.jsx)(r.p,{children:"To use this balancer, specify the following property:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:"druid.router.avatica.balancer.type=rendezvousHash\n"})}),"\n",(0,i.jsxs)(r.p,{children:["If no ",(0,i.jsx)(r.code,{children:"druid.router.avatica.balancer"})," property is set, the Router defaults to using the rendezvous hash balancer."]}),"\n",(0,i.jsx)(r.h3,{id:"consistent-hash-balancer",children:"Consistent hash balancer"}),"\n",(0,i.jsxs)(r.p,{children:["This balancer uses ",(0,i.jsx)(r.a,{href:"https://en.wikipedia.org/wiki/Consistent_hashing",children:"Consistent Hashing"})," on an Avatica request's connection ID to assign the request to a Broker."]}),"\n",(0,i.jsx)(r.p,{children:"To use this balancer, specify the following property:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:"druid.router.avatica.balancer.type=consistentHash\n"})}),"\n",(0,i.jsxs)(r.p,{children:["This is a non-default implementation that is provided for experimentation purposes. The consistent hasher has longer setup times on initialization and when the set of Brokers changes, but has a faster Broker assignment time than the rendezvous hasher when tested with 5 Brokers. Benchmarks for both implementations have been provided in ",(0,i.jsx)(r.code,{children:"ConsistentHasherBenchmark"})," and ",(0,i.jsx)(r.code,{children:"RendezvousHasherBenchmark"}),". The consistent hasher also requires locking, while the rendezvous hasher does not."]}),"\n",(0,i.jsx)(r.h2,{id:"example-production-configuration",children:"Example production configuration"}),"\n",(0,i.jsxs)(r.p,{children:["In this example, we have two tiers in our production cluster: ",(0,i.jsx)(r.code,{children:"hot"})," and ",(0,i.jsx)(r.code,{children:"_default_tier"}),". Queries for the ",(0,i.jsx)(r.code,{children:"hot"})," tier are routed through the ",(0,i.jsx)(r.code,{children:"broker-hot"})," set of Brokers, and queries for the ",(0,i.jsx)(r.code,{children:"_default_tier"})," are routed through the ",(0,i.jsx)(r.code,{children:"broker-cold"})," set of Brokers. If any exceptions or network problems occur, queries are routed to the ",(0,i.jsx)(r.code,{children:"broker-cold"})," set of brokers. In our example, we are running with a c3.2xlarge EC2 instance. We assume a ",(0,i.jsx)(r.code,{children:"common.runtime.properties"})," already exists."]}),"\n",(0,i.jsx)(r.p,{children:"JVM settings:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:"-server\n-Xmx13g\n-Xms13g\n-XX:NewSize=256m\n-XX:MaxNewSize=256m\n-XX:+UseConcMarkSweepGC\n-XX:+PrintGCDetails\n-XX:+PrintGCTimeStamps\n-XX:+UseLargePages\n-XX:+HeapDumpOnOutOfMemoryError\n-XX:HeapDumpPath=/mnt/galaxy/deploy/current/\n-Duser.timezone=UTC\n-Dfile.encoding=UTF-8\n-Djava.io.tmpdir=/mnt/tmp\n\n-Dcom.sun.management.jmxremote.port=17071\n-Dcom.sun.management.jmxremote.authenticate=false\n-Dcom.sun.management.jmxremote.ssl=false\n"})}),"\n",(0,i.jsx)(r.p,{children:"Runtime.properties:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:'druid.host=#{IP_ADDR}:8080\ndruid.plaintextPort=8080\ndruid.service=druid/router\n\ndruid.router.defaultBrokerServiceName=druid:broker-cold\ndruid.router.coordinatorServiceName=druid:coordinator\ndruid.router.tierToBrokerMap={"hot":"druid:broker-hot","_default_tier":"druid:broker-cold"}\ndruid.router.http.numConnections=50\ndruid.router.http.readTimeout=PT5M\n\n# Number of threads used by the Router proxy http client\ndruid.router.http.numMaxThreads=100\n\ndruid.server.http.numThreads=100\n'})})]})}function h(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}}}]);