"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[462],{28453:(n,e,t)=>{t.d(e,{R:()=>l,x:()=>o});var d=t(96540);const s={},i=d.createContext(s);function l(n){const e=d.useContext(i);return d.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:l(n.components),d.createElement(i.Provider,{value:e},n.children)}},55671:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>a,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>d,toc:()=>r});const d=JSON.parse('{"id":"operations/dump-segment","title":"dump-segment tool","description":"\x3c!--","source":"@site/docs/33.0.0/operations/dump-segment.md","sourceDirName":"operations","slug":"/operations/dump-segment","permalink":"/docs/33.0.0/operations/dump-segment","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"dump-segment","title":"dump-segment tool"},"sidebar":"docs","previous":{"title":"Working with different versions of Apache Hadoop","permalink":"/docs/33.0.0/operations/other-hadoop"},"next":{"title":"reset-cluster tool","permalink":"/docs/33.0.0/operations/reset-cluster"}}');var s=t(74848),i=t(28453);const l={id:"dump-segment",title:"dump-segment tool"},o=void 0,a={},r=[{value:"Output format",id:"output-format",level:3},{value:"Data dumps",id:"data-dumps",level:4},{value:"Metadata dumps",id:"metadata-dumps",level:4},{value:"Bitmap dumps",id:"bitmap-dumps",level:4},{value:"Nested column dumps",id:"nested-column-dumps",level:4},{value:"Command line arguments",id:"command-line-arguments",level:3}];function c(n){const e={a:"a",code:"code",h3:"h3",h4:"h4",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.p,{children:"The DumpSegment tool can be used to dump the metadata or contents of an Apache Druid segment for debugging purposes. Note that the\ndump is not necessarily a full-fidelity translation of the segment. In particular, not all metadata is included, and\ncomplex metric values may not be complete."}),"\n",(0,s.jsx)(e.p,{children:"To run the tool, point it at a segment directory and provide a file for writing output:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'java -classpath "/my/druid/lib/*" -Ddruid.extensions.loadList="[]" org.apache.druid.cli.Main \\\n  tools dump-segment \\\n  --directory /home/druid/path/to/segment/ \\\n  --out /home/druid/output.txt\n'})}),"\n",(0,s.jsx)(e.p,{children:"If you use JDK 11 and above, you need to add the following additional parameters"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"--add-opens java.base/java.lang=ALL-UNNAMED\n--add-opens java.base/sun.nio.ch=ALL-UNNAMED\n"})}),"\n",(0,s.jsx)(e.p,{children:"The following is an example"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'java --add-opens java.base/java.lang=ALL-UNNAMED --add-opens java.base/sun.nio.ch=ALL-UNNAMED \\\n  -classpath "/my/druid/lib/*" \\\n  -Ddruid.extensions.loadList="[]" org.apache.druid.cli.Main \\\n  tools dump-segment \\\n  --directory /home/druid/path/to/segment/ \\\n  --out /home/druid/output.txt\n'})}),"\n",(0,s.jsx)(e.h3,{id:"output-format",children:"Output format"}),"\n",(0,s.jsx)(e.h4,{id:"data-dumps",children:"Data dumps"}),"\n",(0,s.jsxs)(e.p,{children:["By default, or with ",(0,s.jsx)(e.code,{children:"--dump rows"}),", this tool dumps rows of the segment as newline-separate JSON objects, with one\nobject per line, using the default serialization for each column. Normally all columns are included, but if you like,\nyou can limit the dump to specific columns with ",(0,s.jsx)(e.code,{children:"--column name"}),"."]}),"\n",(0,s.jsx)(e.p,{children:"For example, one line might look like this when pretty-printed:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'{\n  "__time": 1442018818771,\n  "added": 36,\n  "channel": "#en.wikipedia",\n  "cityName": null,\n  "comment": "added project",\n  "count": 1,\n  "countryIsoCode": null,\n  "countryName": null,\n  "deleted": 0,\n  "delta": 36,\n  "isAnonymous": "false",\n  "isMinor": "false",\n  "isNew": "false",\n  "isRobot": "false",\n  "isUnpatrolled": "false",\n  "iuser": "00001553",\n  "metroCode": null,\n  "namespace": "Talk",\n  "page": "Talk:Oswald Tilghman",\n  "regionIsoCode": null,\n  "regionName": null,\n  "user": "GELongstreet"\n}\n'})}),"\n",(0,s.jsx)(e.h4,{id:"metadata-dumps",children:"Metadata dumps"}),"\n",(0,s.jsxs)(e.p,{children:["With ",(0,s.jsx)(e.code,{children:"--dump metadata"}),", this tool dumps metadata instead of rows. Metadata dumps generated by this tool are in the same\nformat as returned by the ",(0,s.jsx)(e.a,{href:"/docs/33.0.0/querying/segmentmetadataquery",children:"SegmentMetadata query"}),"."]}),"\n",(0,s.jsx)(e.h4,{id:"bitmap-dumps",children:"Bitmap dumps"}),"\n",(0,s.jsxs)(e.p,{children:["With ",(0,s.jsx)(e.code,{children:"--dump bitmaps"}),', this tool will dump bitmap indexes instead of rows. Bitmap dumps generated by this tool include\ndictionary-encoded string columns only. The output contains a field "bitmapSerdeFactory" describing the type of bitmaps\nused in the segment, and a field "bitmaps" containing the bitmaps for each value of each column. These are base64\nencoded by default, but you can also dump them as lists of row numbers with ',(0,s.jsx)(e.code,{children:"--decompress-bitmaps"}),"."]}),"\n",(0,s.jsxs)(e.p,{children:["Normally all columns are included, but if you like, you can limit the dump to specific columns with ",(0,s.jsx)(e.code,{children:"--column name"}),"."]}),"\n",(0,s.jsx)(e.p,{children:"Sample output:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'{\n  "bitmapSerdeFactory": {\n    "type": "roaring"\n  },\n  "bitmaps": {\n    "isRobot": {\n      "false": "//aExfu+Nv3X...",\n      "true": "gAl7OoRByQ..."\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(e.h4,{id:"nested-column-dumps",children:"Nested column dumps"}),"\n",(0,s.jsxs)(e.p,{children:["With ",(0,s.jsx)(e.code,{children:"--dump nested"}),", this tool can be used to examine Druid ",(0,s.jsx)(e.a,{href:"/docs/33.0.0/querying/nested-columns",children:"nested columns"}),". Using\n",(0,s.jsx)(e.code,{children:"nested"})," always requires exactly one ",(0,s.jsx)(e.code,{children:"--column name"})," argument, and takes an optional argument to specify a specific\nnested field in ",(0,s.jsx)(e.a,{href:"/docs/33.0.0/querying/sql-json-functions#jsonpath-syntax",children:"JSONPath syntax"}),", ",(0,s.jsx)(e.code,{children:"--nested-path $.path.to.field"}),".\nIf ",(0,s.jsx)(e.code,{children:"--nested-path"})," is not specified, the output will contain the list of nested fields and their types, the global\nvalue dictionaries, and the list of null rows."]}),"\n",(0,s.jsx)(e.p,{children:"Sample output:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-json",children:'{\n  "nest": {\n    "fields": [\n      {\n        "path": "$.x",\n        "types": [\n          "LONG"\n        ]\n      },\n      {\n        "path": "$.y",\n        "types": [\n          "DOUBLE"\n        ]\n      },\n      {\n        "path": "$.z",\n        "types": [\n          "STRING"\n        ]\n      }\n    ],\n    "dictionaries": {\n      "strings": [\n        {\n          "globalId": 0,\n          "value": null\n        },\n        {\n          "globalId": 1,\n          "value": "a"\n        },\n        {\n          "globalId": 2,\n          "value": "b"\n        }\n      ],\n      "longs": [\n        {\n          "globalId": 3,\n          "value": 100\n        },\n        {\n          "globalId": 4,\n          "value": 200\n        },\n        {\n          "globalId": 5,\n          "value": 400\n        }\n      ],\n      "doubles": [\n        {\n          "globalId": 6,\n          "value": 1.1\n        },\n        {\n          "globalId": 7,\n          "value": 2.2\n        },\n        {\n          "globalId": 8,\n          "value": 3.3\n        }\n      ],\n      "nullRows": []\n    }\n  }\n}\n'})}),"\n",(0,s.jsxs)(e.p,{children:["If ",(0,s.jsx)(e.code,{children:"--nested-path"})," is specified, the output will instead contain the types of the nested field, the local value\ndictionary, including the 'global' dictionary id and value, the uncompressed bitmap index for each value (list of row\nnumbers which contain the value), and a dump of the column itself, which contains the row number, raw JSON form of the\nnested column itself, the local dictionary id of the field for that row, and the value for the field for the row."]}),"\n",(0,s.jsx)(e.p,{children:"Sample output:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-json",children:'{\n  "bitmapSerdeFactory": {\n    "type": "roaring"\n  },\n  "nest": {\n    "$.x": {\n      "types": [\n        "LONG"\n      ],\n      "dictionary": [\n        {\n          "localId": 0,\n          "globalId": 0,\n          "value": null,\n          "rows": [\n            4\n          ]\n        },\n        {\n          "localId": 1,\n          "globalId": 3,\n          "value": "100",\n          "rows": [\n            3\n          ]\n        },\n        {\n          "localId": 2,\n          "globalId": 4,\n          "value": "200",\n          "rows": [\n            0,\n            2\n          ]\n        },\n        {\n          "localId": 3,\n          "globalId": 5,\n          "value": "400",\n          "rows": [\n            1\n          ]\n        }\n      ],\n      "column": [\n        {\n          "row": 0,\n          "raw": {\n            "x": 200,\n            "y": 2.2\n          },\n          "fieldId": 2,\n          "fieldValue": "200"\n        },\n        {\n          "row": 1,\n          "raw": {\n            "x": 400,\n            "y": 1.1,\n            "z": "a"\n          },\n          "fieldId": 3,\n          "fieldValue": "400"\n        },\n        {\n          "row": 2,\n          "raw": {\n            "x": 200,\n            "z": "b"\n          },\n          "fieldId": 2,\n          "fieldValue": "200"\n        },\n        {\n          "row": 3,\n          "raw": {\n            "x": 100,\n            "y": 1.1,\n            "z": "a"\n          },\n          "fieldId": 1,\n          "fieldValue": "100"\n        },\n        {\n          "row": 4,\n          "raw": {\n            "y": 3.3,\n            "z": "b"\n          },\n          "fieldId": 0,\n          "fieldValue": null\n        }\n      ]\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"command-line-arguments",children:"Command line arguments"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"argument"}),(0,s.jsx)(e.th,{children:"description"}),(0,s.jsx)(e.th,{children:"required?"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"--directory file"}),(0,s.jsx)(e.td,{children:'Directory containing segment data. This could be generated by unzipping an "index.zip" from deep storage.'}),(0,s.jsx)(e.td,{children:"yes"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"--output file"}),(0,s.jsx)(e.td,{children:"File to write to, or omit to write to stdout."}),(0,s.jsx)(e.td,{children:"yes"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"--dump TYPE"}),(0,s.jsx)(e.td,{children:"Dump either 'rows' (default), 'metadata', 'bitmaps', or 'nested' for examining nested columns."}),(0,s.jsx)(e.td,{children:"no"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"--column columnName"}),(0,s.jsx)(e.td,{children:"Column to include. Specify multiple times for multiple columns, or omit to include all columns."}),(0,s.jsx)(e.td,{children:"no"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"--filter json"}),(0,s.jsxs)(e.td,{children:["JSON-encoded ",(0,s.jsx)(e.a,{href:"/docs/33.0.0/querying/filters",children:"query filter"}),". Omit to include all rows. Only used if dumping rows."]}),(0,s.jsx)(e.td,{children:"no"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"--time-iso8601"}),(0,s.jsx)(e.td,{children:"Format __time column in ISO8601 format rather than long. Only used if dumping rows."}),(0,s.jsx)(e.td,{children:"no"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"--decompress-bitmaps"}),(0,s.jsx)(e.td,{children:"Dump bitmaps as arrays rather than base64-encoded compressed bitmaps. Only used if dumping bitmaps."}),(0,s.jsx)(e.td,{children:"no"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"--nested-path"}),(0,s.jsxs)(e.td,{children:["Specify a specific nested column field using ",(0,s.jsx)(e.a,{href:"/docs/33.0.0/querying/sql-json-functions#jsonpath-syntax",children:"JSONPath syntax"}),". Only used if dumping a nested column."]}),(0,s.jsx)(e.td,{children:"no"})]})]})]})]})}function u(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(c,{...n})}):c(n)}}}]);