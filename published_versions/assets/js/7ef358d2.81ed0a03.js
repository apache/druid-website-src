"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[635],{28453:(e,n,r)=>{r.d(n,{R:()=>d,x:()=>o});var t=r(96540);const s={},i=t.createContext(s);function d(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),t.createElement(i.Provider,{value:n},e.children)}},29323:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>a,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"development/extensions-core/k8s-jobs","title":"MM-less Druid in K8s","description":"\x3c!--","source":"@site/docs/latest/development/extensions-core/k8s-jobs.md","sourceDirName":"development/extensions-core","slug":"/development/extensions-core/k8s-jobs","permalink":"/docs/latest/development/extensions-core/k8s-jobs","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"k8s-jobs","title":"MM-less Druid in K8s"}}');var s=r(74848),i=r(28453),d=r(65537),o=r(79329);const a={id:"k8s-jobs",title:"MM-less Druid in K8s"},l=void 0,c={},h=[{value:"How it works",id:"how-it-works",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Dynamic config",id:"dynamic-config",level:3},{value:"Get dynamic configuration",id:"get-dynamic-configuration",level:4},{value:"URL",id:"url",level:5},{value:"Responses",id:"responses",level:5},{value:"Sample request",id:"sample-request",level:5},{value:"Sample response",id:"sample-response",level:5},{value:"Update dynamic configuration",id:"update-dynamic-configuration",level:4},{value:"URL",id:"url-1",level:5},{value:"Header parameters",id:"header-parameters",level:5},{value:"Responses",id:"responses-1",level:5},{value:"Sample request",id:"sample-request-1",level:5},{value:"Sample response",id:"sample-response-1",level:5},{value:"Get dynamic configuration history",id:"get-dynamic-configuration-history",level:4},{value:"URL",id:"url-2",level:5},{value:"Query parameters",id:"query-parameters",level:5},{value:"Responses",id:"responses-2",level:5},{value:"Sample request",id:"sample-request-2",level:5},{value:"Sample response",id:"sample-response-2",level:5},{value:"Pod adapters",id:"pod-adapters",level:2},{value:"Overlord Single Container Pod Adapter/Overlord Multi Container Pod Adapter",id:"overlord-single-container-pod-adapteroverlord-multi-container-pod-adapter",level:3},{value:"Custom Template Pod Adapter",id:"custom-template-pod-adapter",level:3},{value:"Example 1: Using a Pod Template that retrieves values from a ConfigMap",id:"example-1-using-a-pod-template-that-retrieves-values-from-a-configmap",level:4},{value:"Example 2: Using a ConfigMap to upload the Pod Template file",id:"example-2-using-a-configmap-to-upload-the-pod-template-file",level:4},{value:"Lazy Loading of Pod Templates",id:"lazy-loading-of-pod-templates",level:4},{value:"Pod template selection",id:"pod-template-selection",level:4},{value:"Select based on task type",id:"select-based-on-task-type",level:5},{value:"Select based on one or more conditions",id:"select-based-on-one-or-more-conditions",level:5},{value:"Example",id:"example",level:5},{value:"Running Task Pods in Another Namespace",id:"running-task-pods-in-another-namespace",level:4},{value:"Differentiating Task Pods Created From Multiple Namespaces",id:"differentiating-task-pods-created-from-multiple-namespaces",level:5},{value:"Dealing with ZooKeeper Problems",id:"dealing-with-zookeeper-problems",level:5},{value:"Dealing with Permissions",id:"dealing-with-permissions",level:5},{value:"Properties",id:"properties",level:3},{value:"Metrics added",id:"metrics-added",level:3},{value:"Gotchas",id:"gotchas",level:3},{value:"Migration/Kubernetes and Worker Task Runner",id:"migrationkubernetes-and-worker-task-runner",level:2},{value:"Additional Configurations",id:"additional-configurations",level:3}];function u(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",h5:"h5",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components},{Details:r}=n;return r||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Apache Druid Extension to enable using Kubernetes for launching and managing tasks instead of the Middle Managers.  This extension allows you to launch tasks as kubernetes jobs removing the need for your middle manager."}),"\n",(0,s.jsxs)(n.p,{children:["Consider this an ",(0,s.jsx)(n.a,{href:"/docs/latest/development/experimental",children:"EXPERIMENTAL"})," feature mostly because it has not been tested yet on a wide variety of long-running Druid clusters."]}),"\n",(0,s.jsx)(n.h2,{id:"how-it-works",children:"How it works"}),"\n",(0,s.jsx)(n.p,{children:"The K8s extension builds a pod spec for each task using the specified pod adapter. All jobs are natively restorable, they are decoupled from the Druid deployment, thus restarting pods or doing upgrades has no effect on tasks in flight.  They will continue to run and when the overlord comes back up it will start tracking them again."}),"\n",(0,s.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,s.jsxs)(n.p,{children:["To use this extension please make sure to ",(0,s.jsx)(n.a,{href:"/docs/latest/configuration/extensions#loading-extensions",children:"include"})," ",(0,s.jsx)(n.code,{children:"druid-kubernetes-overlord-extensions"})," in the extensions load list for your overlord process."]}),"\n",(0,s.jsxs)(n.p,{children:["The extension uses ",(0,s.jsx)(n.code,{children:"druid.indexer.runner.capacity"})," to limit the number of k8s jobs in flight. A good initial value for this would be the sum of the total task slots of all the middle managers you were running before switching to K8s based ingestion. The K8s task runner uses one thread per Job that is created, so setting this number too large can cause memory issues on the overlord. Additionally set the variable ",(0,s.jsx)(n.code,{children:"druid.indexer.runner.namespace"})," to the namespace in which you are running druid."]}),"\n",(0,s.jsxs)(n.p,{children:["Other configurations required are:\n",(0,s.jsx)(n.code,{children:"druid.indexer.runner.type: k8s"})," and ",(0,s.jsx)(n.code,{children:"druid.indexer.task.encapsulatedTask: true"})]}),"\n",(0,s.jsx)(n.h3,{id:"dynamic-config",children:"Dynamic config"}),"\n",(0,s.jsx)(n.p,{children:"Druid operators can dynamically tune certain features within this extension. You don't need to restart the Overlord\nservice for these changes to take effect."}),"\n",(0,s.jsxs)(n.p,{children:["Druid can dynamically tune ",(0,s.jsx)(n.a,{href:"#pod-template-selection",children:"pod template selection"}),", which allows you to configure the pod\ntemplate based on the task to be run. To enable dynamic pod template selection, first configure the\n",(0,s.jsx)(n.a,{href:"#custom-template-pod-adapter",children:"custom template pod adapter"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Use the following APIs to view and update the dynamic configuration for the Kubernetes task runner."}),"\n",(0,s.jsxs)(n.p,{children:['To use these APIs, ensure you have read and write permissions for the CONFIG resource type with the resource name\n"CONFIG". For more information on permissions, see\n',(0,s.jsx)(n.a,{href:"/docs/latest/operations/security-user-auth#config",children:"User authentication and authorization"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"get-dynamic-configuration",children:"Get dynamic configuration"}),"\n",(0,s.jsx)(n.p,{children:"Retrieves the current dynamic execution config for the Kubernetes task runner.\nReturns a JSON object with the dynamic configuration properties."}),"\n",(0,s.jsx)(n.h5,{id:"url",children:"URL"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"GET"})," ",(0,s.jsx)(n.code,{children:"/druid/indexer/v1/k8s/taskrunner/executionconfig"})]}),"\n",(0,s.jsx)(n.h5,{id:"responses",children:"Responses"}),"\n",(0,s.jsx)(d.A,{children:(0,s.jsx)(o.A,{value:"1",label:"200 SUCCESS",children:(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Successfully retrieved dynamic configuration"})})})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h5,{id:"sample-request",children:"Sample request"}),"\n",(0,s.jsxs)(d.A,{children:[(0,s.jsx)(o.A,{value:"2",label:"cURL",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:'curl "http://ROUTER_IP:ROUTER_PORT/druid/indexer/v1/k8s/taskrunner/executionconfig"\n'})})}),(0,s.jsx)(o.A,{value:"3",label:"HTTP",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-HTTP",children:"GET /druid/indexer/v1/k8s/taskrunner/executionconfig HTTP/1.1\nHost: http://ROUTER_IP:ROUTER_PORT\n"})})})]}),"\n",(0,s.jsx)(n.h5,{id:"sample-response",children:"Sample response"}),"\n",(0,s.jsxs)(r,{children:[(0,s.jsx)("summary",{children:"View the response"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "type": "default",\n  "podTemplateSelectStrategy":\n  {\n    "type": "selectorBased",\n    "selectors": [\n      {\n        "selectionKey": "podSpec1",\n        "context.tags": {\n          "userProvidedTag": ["tag1", "tag2"]\n        },\n        "dataSource": ["wikipedia"]\n      },\n      {\n        "selectionKey": "podSpec2",\n        "type": ["index_kafka"]\n      }\n    ]\n  }\n}\n'})})]}),"\n",(0,s.jsx)(n.h4,{id:"update-dynamic-configuration",children:"Update dynamic configuration"}),"\n",(0,s.jsx)(n.p,{children:"Updates the dynamic configuration for the Kubernetes Task Runner"}),"\n",(0,s.jsx)(n.h5,{id:"url-1",children:"URL"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"POST"})," ",(0,s.jsx)(n.code,{children:"/druid/indexer/v1/k8s/taskrunner/executionconfig"})]}),"\n",(0,s.jsx)(n.h5,{id:"header-parameters",children:"Header parameters"}),"\n",(0,s.jsxs)(n.p,{children:["The endpoint supports the following optional header parameters to populate the ",(0,s.jsx)(n.code,{children:"author"})," and ",(0,s.jsx)(n.code,{children:"comment"})," fields in the configuration history."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"X-Druid-Author"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Type: String"}),"\n",(0,s.jsx)(n.li,{children:"Author of the configuration change."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"X-Druid-Comment"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Type: String"}),"\n",(0,s.jsx)(n.li,{children:"Description for the update."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h5,{id:"responses-1",children:"Responses"}),"\n",(0,s.jsx)(d.A,{children:(0,s.jsx)(o.A,{value:"4",label:"200 SUCCESS",children:(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Successfully updated dynamic configuration"})})})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h5,{id:"sample-request-1",children:"Sample request"}),"\n",(0,s.jsxs)(d.A,{children:[(0,s.jsx)(o.A,{value:"5",label:"cURL",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:'curl "http://ROUTER_IP:ROUTER_PORT/druid/indexer/v1/k8s/taskrunner/executionconfig" \\\n--header \'Content-Type: application/json\' \\\n--data \'{\n  "type": "default",\n  "podTemplateSelectStrategy":\n  {\n    "type": "selectorBased",\n    "selectors": [\n      {\n        "selectionKey": "podSpec1",\n        "context.tags":\n        {\n          "userProvidedTag": ["tag1", "tag2"]\n        },\n        "dataSource": ["wikipedia"]\n      },\n      {\n        "selectionKey": "podSpec2",\n        "type": ["index_kafka"]\n      }\n    ]\n  }\n}\'\n'})})}),(0,s.jsx)(o.A,{value:"6",label:"HTTP",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-HTTP",children:'POST /druid/indexer/v1/k8s/taskrunner/executionconfig HTTP/1.1\nHost: http://ROUTER_IP:ROUTER_PORT\nContent-Type: application/json\n\n{\n  "type": "default",\n  "podTemplateSelectStrategy":\n  {\n    "type": "selectorBased",\n    "selectors": [\n      {\n        "selectionKey": "podSpec1",\n        "context.tags":\n        {\n          "userProvidedTag": ["tag1", "tag2"]\n        },\n        "dataSource": ["wikipedia"]\n      },\n      {\n        "selectionKey": "podSpec2",\n        "type": ["index_kafka"]\n      }\n    ]\n  }\n}\n'})})})]}),"\n",(0,s.jsx)(n.h5,{id:"sample-response-1",children:"Sample response"}),"\n",(0,s.jsxs)(n.p,{children:["A successful request returns an HTTP ",(0,s.jsx)(n.code,{children:"200 OK"})," message code and an empty response body."]}),"\n",(0,s.jsx)(n.h4,{id:"get-dynamic-configuration-history",children:"Get dynamic configuration history"}),"\n",(0,s.jsx)(n.p,{children:"Retrieves the history of changes to Kubernetes task runner's dynamic execution config over an interval of time. Returns\nan empty array if there are no history records available."}),"\n",(0,s.jsx)(n.h5,{id:"url-2",children:"URL"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"GET"})," ",(0,s.jsx)(n.code,{children:"/druid/indexer/v1/k8s/taskrunner/executionconfig/history"})]}),"\n",(0,s.jsx)(n.h5,{id:"query-parameters",children:"Query parameters"}),"\n",(0,s.jsx)(n.p,{children:"The endpoint supports the following optional query parameters to filter results."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"interval"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Type: String"}),"\n",(0,s.jsxs)(n.li,{children:["Limit the results to the specified time interval in ISO 8601 format delimited with ",(0,s.jsx)(n.code,{children:"/"}),". For example, ",(0,s.jsx)(n.code,{children:"2023-07-13/2023-07-19"}),". The default interval is one week. You can change this period by setting ",(0,s.jsx)(n.code,{children:"druid.audit.manager.auditHistoryMillis"})," in the ",(0,s.jsx)(n.code,{children:"runtime.properties"})," file for the Coordinator."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"count"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Type: Integer"}),"\n",(0,s.jsxs)(n.li,{children:["Limit the number of results to the last ",(0,s.jsx)(n.code,{children:"n"})," entries."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h5,{id:"responses-2",children:"Responses"}),"\n",(0,s.jsx)(d.A,{children:(0,s.jsx)(o.A,{value:"1",label:"200 SUCCESS",children:(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Successfully retrieved dynamic configuration"})})})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h5,{id:"sample-request-2",children:"Sample request"}),"\n",(0,s.jsxs)(d.A,{children:[(0,s.jsx)(o.A,{value:"2",label:"cURL",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:'curl "http://ROUTER_IP:ROUTER_PORT/druid/indexer/v1/k8s/taskrunner/executionconfig/history"\n'})})}),(0,s.jsx)(o.A,{value:"3",label:"HTTP",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-HTTP",children:"GET /druid/indexer/v1/k8s/taskrunner/executionconfig/history HTTP/1.1\nHost: http://ROUTER_IP:ROUTER_PORT\n"})})})]}),"\n",(0,s.jsx)(n.h5,{id:"sample-response-2",children:"Sample response"}),"\n",(0,s.jsxs)(r,{children:[(0,s.jsx)("summary",{children:"View the response"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'[\n  {\n    "key": "k8s.taskrunner.config",\n    "type": "k8s.taskrunner.config",\n    "auditInfo": {\n      "author": "",\n      "comment": "",\n      "ip": "127.0.0.1"\n    },\n    "payload": "{\\"type\\": \\"default\\",\\"podTemplateSelectStrategy\\":{\\"type\\": \\"taskType\\"}",\n    "auditTime": "2024-06-13T20:59:51.622Z"\n  }\n]\n'})})]}),"\n",(0,s.jsx)(n.h2,{id:"pod-adapters",children:"Pod adapters"}),"\n",(0,s.jsx)(n.p,{children:"The logic defining how the pod template is built for your Kubernetes Job depends on which pod adapter you have specified."}),"\n",(0,s.jsx)(n.h3,{id:"overlord-single-container-pod-adapteroverlord-multi-container-pod-adapter",children:"Overlord Single Container Pod Adapter/Overlord Multi Container Pod Adapter"}),"\n",(0,s.jsxs)(n.p,{children:["The overlord single container pod adapter takes the podSpec of your ",(0,s.jsx)(n.code,{children:"Overlord"})," pod and creates a kubernetes job from this podSpec.  This is the default pod adapter implementation, to explicitly enable it you can specify the runtime property ",(0,s.jsx)(n.code,{children:"druid.indexer.runner.k8s.adapter.type: overlordSingleContainer"})]}),"\n",(0,s.jsxs)(n.p,{children:["The overlord multi container pod adapter takes the podSpec of your ",(0,s.jsx)(n.code,{children:"Overlord"})," pod and creates a kubernetes job from this podSpec.  It uses kubexit to manage dependency ordering between the main container that runs your druid peon and other sidecars defined in the ",(0,s.jsx)(n.code,{children:"Overlord"})," pod spec. Thus if you have sidecars such as Splunk or Istio it will be able to handle them. To enable this pod adapter you can specify the runtime property ",(0,s.jsx)(n.code,{children:"druid.indexer.runner.k8s.adapter.type: overlordMultiContainer"})]}),"\n",(0,s.jsx)(n.p,{children:"For the sidecar support to work for the multi container pod adapter, your entry point / command in docker must be explicitly defined your spec."}),"\n",(0,s.jsxs)(n.p,{children:["You can't have something like this:\nDockerfile:\n",(0,s.jsx)(n.code,{children:'ENTRYPOINT: ["foo.sh"]'})]}),"\n",(0,s.jsx)(n.p,{children:"and in your sidecar specs:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-container:",children:"        name: foo\n        args: \n           - arg1\n           - arg2 \n"})}),"\n",(0,s.jsxs)(n.p,{children:["That will not work, because we cannot decipher what your command is, the extension needs to know it explicitly.\n*",(0,s.jsx)(n.em,{children:"Even for sidecars like Istio which are dynamically created by the service mesh, this needs to happen."})]}),"\n",(0,s.jsx)(n.p,{children:"Instead, do the following:\nYou can keep your Dockerfile the same but you must have a sidecar spec like so:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-container:",children:"        name: foo\n        command: foo.sh\n        args: \n           - arg1\n           - arg2 \n"})}),"\n",(0,s.jsxs)(n.p,{children:["For both of these adapters, you can add optional labels to your K8s jobs / pods if you need them by using the following configuration:\n",(0,s.jsx)(n.code,{children:'druid.indexer.runner.labels: \'{"key":"value"}\''}),"\nAnnotations are the same with:\n",(0,s.jsx)(n.code,{children:'druid.indexer.runner.annotations: \'{"key":"value"}\''})]}),"\n",(0,s.jsxs)(n.p,{children:["All other configurations you had for the middle manager tasks must be moved under the overlord with one caveat, you must specify javaOpts as an array:\n",(0,s.jsx)(n.code,{children:"druid.indexer.runner.javaOptsArray"}),", ",(0,s.jsx)(n.code,{children:"druid.indexer.runner.javaOpts"})," is no longer supported."]}),"\n",(0,s.jsxs)(n.p,{children:["If you are running without a middle manager you need to also use ",(0,s.jsx)(n.code,{children:"druid.processing.intermediaryData.storage.type=deepstore"})]}),"\n",(0,s.jsx)(n.h3,{id:"custom-template-pod-adapter",children:"Custom Template Pod Adapter"}),"\n",(0,s.jsxs)(n.p,{children:["The custom template pod adapter allows you to specify a pod template file per task type for more flexibility on how to define your pods. This adapter expects a ",(0,s.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/workloads/pods/#pod-templates",children:"Pod Template"})," to be available on the overlord's file system. This pod template is used as the base of the pod spec for the Kubernetes Job. You can override things like labels, environment variables, resources, annotation, or even the base image with this template. To enable this pod adapter you can specify the runtime property ",(0,s.jsx)(n.code,{children:"druid.indexer.runner.k8s.adapter.type: customTemplateAdapter"})]}),"\n",(0,s.jsxs)(n.p,{children:["The base pod template must be specified as the runtime property ",(0,s.jsx)(n.code,{children:"druid.indexer.runner.k8s.podTemplate.base: /path/to/basePodSpec.yaml"})]}),"\n",(0,s.jsx)(n.p,{children:"The below runtime properties need to be passed to the Job's peon process."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"druid.port=8100 (what port the peon should run on)\ndruid.peon.mode=remote\ndruid.service=druid/peon (for metrics reporting)\ndruid.indexer.task.baseTaskDir=/druid/data (this should match the argument to the ./peon.sh run command in the PodTemplate)\ndruid.indexer.runner.type=k8s\ndruid.indexer.task.encapsulatedTask=true\n"})}),"\n",(0,s.jsx)(n.h4,{id:"example-1-using-a-pod-template-that-retrieves-values-from-a-configmap",children:"Example 1: Using a Pod Template that retrieves values from a ConfigMap"}),"\n",(0,s.jsxs)(r,{children:[(0,s.jsx)("summary",{children:"Example Pod Template that uses the regular druid docker image"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'apiVersion: "v1"\nkind: "PodTemplate"\ntemplate:\n  metadata:\n    annotations:\n      sidecar.istio.io/proxyCPU: "512m" # to handle an injected istio sidecar\n    labels:\n      app.kubernetes.io/name: "druid-realtime-backend"\n  spec:\n    affinity: {}\n    containers:\n    - command:\n        - sh\n        - -c\n        - |\n          /peon.sh /druid/data 1\n      env:\n      - name: CUSTOM_ENV_VARIABLE\n        value: "hello"\n      image: apache/druid:33.0.0\n      name: main\n      ports:\n      - containerPort: 8091\n        name: druid-tls-port\n        protocol: TCP\n      - containerPort: 8100\n        name: druid-port\n        protocol: TCP\n      resources:\n        limits:\n          cpu: "1"\n          memory: 2400M\n        requests:\n          cpu: "1"\n          memory: 2400M\n      volumeMounts:\n      - mountPath: /opt/druid/conf/druid/cluster/master/coordinator-overlord # runtime props are still mounted in this location because that\'s where peon.sh looks for configs\n        name: nodetype-config-volume\n        readOnly: true\n      - mountPath: /druid/data\n        name: data-volume\n      - mountPath: /druid/deepstorage\n        name: deepstorage-volume\n    restartPolicy: "Never"\n    securityContext:\n      fsGroup: 1000\n      runAsGroup: 1000\n      runAsUser: 1000\n    tolerations:\n    - effect: NoExecute\n      key: node.kubernetes.io/not-ready\n      operator: Exists\n      tolerationSeconds: 300\n    - effect: NoExecute\n      key: node.kubernetes.io/unreachable\n      operator: Exists\n      tolerationSeconds: 300\n    volumes:\n    - configMap:\n        defaultMode: 420\n        name: druid-tiny-cluster-peons-config\n      name: nodetype-config-volume\n    - emptyDir: {}\n      name: data-volume\n    - emptyDir: {}\n      name: deepstorage-volume\n'})})]}),"\n",(0,s.jsxs)(n.p,{children:["Any runtime property or JVM config used by the peon process can also be passed. E.G. below is an example of a ConfigMap that can be used to generate the ",(0,s.jsx)(n.code,{children:"nodetype-config-volume"})," mount in the above template."]}),"\n",(0,s.jsxs)(r,{children:[(0,s.jsx)("summary",{children:"Example ConfigMap"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'apiVersion: v1\nkind: ConfigMap\nmetadata:\n    name: druid-tiny-cluster-peons-config\n    namespace: default\ndata:\n    jvm.config: |-\n        -server\n        -XX:MaxDirectMemorySize=1000M\n        -Duser.timezone=UTC\n        -Dfile.encoding=UTF-8\n        -Dlog4j.debug\n        -Djava.util.logging.manager=org.apache.logging.log4j.jul.LogManager\n        -Djava.io.tmpdir=/druid/data\n        -Xmx1024M\n        -Xms1024M\n    log4j2.xml: |-\n        <?xml version="1.0" encoding="UTF-8" ?>\n        <Configuration status="WARN">\n            <Appenders>\n                <Console name="Console" target="SYSTEM_OUT">\n                    <PatternLayout pattern="%d{ISO8601} %p [%t] %c - %m%n"/>\n                </Console>\n            </Appenders>\n            <Loggers>\n                <Root level="info">\n                    <AppenderRef ref="Console"/>\n                </Root>\n            </Loggers>\n        </Configuration>\n    runtime.properties: |\n        druid.port=8100\n        druid.service=druid/peon\n        druid.server.http.numThreads=5\n        druid.indexer.task.baseTaskDir=/druid/data\n        druid.indexer.runner.type=k8s\n        druid.peon.mode=remote\n        druid.indexer.task.encapsulatedTask=true\n'})})]}),"\n",(0,s.jsx)(n.h4,{id:"example-2-using-a-configmap-to-upload-the-pod-template-file",children:"Example 2: Using a ConfigMap to upload the Pod Template file"}),"\n",(0,s.jsx)(n.p,{children:"Alternatively, we can mount the ConfigMap onto Overlord services, and use the ConfigMap to generate the pod template files we want."}),"\n",(0,s.jsxs)(r,{children:[(0,s.jsx)("summary",{children:"Mounting to Overlord deployment"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"  volumeMounts:\n    - name: druid-pod-templates\n      mountPath: /path/to/podTemplate/directory\n\n  volumes:\n    - name: druid-pod-templates\n      configMap:\n        name: druid-pod-templates\n"})})]}),"\n",(0,s.jsxs)(r,{children:[(0,s.jsx)("summary",{children:"Example ConfigMap that generates the Base Pod Template"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: druid-pod-templates\ndata:\n  basePodSpec.yaml: |-\n    apiVersion: "v1"\n    kind: "PodTemplate"\n    template:\n      metadata:\n        labels:\n          app.kubernetes.io/name: "druid-realtime-backend"\n        annotations:\n          sidecar.istio.io/proxyCPU: "512m"\n      spec:\n        containers:\n        - name: main\n          image: apache/druid:33.0.0\n          command:\n            - sh\n            - -c\n            - |\n              /peon.sh /druid/data 1\n          env:\n            - name: druid_port\n              value: 8100\n            - name: druid_plaintextPort\n              value: 8100\n            - name: druid_tlsPort\n              value: 8091\n            - name: druid_peon_mode\n              value: remote\n            - name: druid_service\n              value: "druid/peon"\n            - name: druid_indexer_task_baseTaskDir\n              value: /druid/data\n            - name: druid_indexer_runner_type\n              value: k8s\n            - name: druid_indexer_task_encapsulatedTask\n              value: true\n          ports:\n            - containerPort: 8091\n              name: druid-tls-port\n              protocol: TCP\n            - containerPort: 8100\n              name: druid-port\n              protocol: TCP\n          resources:\n            limits:\n              cpu: "1"\n              memory: 2400M\n            requests:\n              cpu: "1"\n              memory: 2400M\n          restartPolicy: "Never"\n          securityContext:\n            fsGroup: 1000\n            runAsGroup: 1000\n            runAsUser: 1000\n          tolerations:\n            - effect: NoExecute\n              key: node.kubernetes.io/not-ready\n              operator: Exists\n              tolerationSeconds: 300\n            - effect: NoExecute\n              key: node.kubernetes.io/unreachable\n              operator: Exists\n              tolerationSeconds: 300\n\n'})})]}),"\n",(0,s.jsx)(n.h4,{id:"lazy-loading-of-pod-templates",children:"Lazy Loading of Pod Templates"}),"\n",(0,s.jsx)(n.p,{children:"Whenever the Overlord wants to spin up a Kubernetes task pod, it will first read the relevant pod template file, and then create a task pod according to the specifications of the pod template file. This is helpful when you want to make configuration changes to the task pods (e.g. increase/decrease CPU limit or resources). You can edit the pod template files directly, and the next task pod spun up by the Overlord will reflect these changes in its configurations."}),"\n",(0,s.jsx)(n.h4,{id:"pod-template-selection",children:"Pod template selection"}),"\n",(0,s.jsxs)(n.p,{children:["The pod template adapter can select which pod template should be used for a task using the ",(0,s.jsx)(n.a,{href:"#dynamic-config",children:"task runner execution config"})]}),"\n",(0,s.jsx)(n.h5,{id:"select-based-on-task-type",children:"Select based on task type"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"TaskTypePodTemplateSelectStrategy"})," strategy selects pod templates based on task type for execution purposes,\nimplementing the behavior that maps templates to specific task types. This is the default pod template selection\nstrategy. To explicitly select this strategy, set the ",(0,s.jsx)(n.code,{children:"podTemplateSelectStrategy"})," in the dynamic execution config to"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{ "type": "default" }\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Task specific pod templates can be specified as the runtime property\n",(0,s.jsx)(n.code,{children:"druid.indexer.runner.k8s.podTemplate.{taskType}: /path/to/taskSpecificPodSpec.yaml"})," where ",(0,s.jsx)(n.code,{children:"{taskType}"})," is the name of the\ntask type. For example, ",(0,s.jsx)(n.code,{children:"index_parallel"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If you are trying to use the default image's environment variable parsing feature to set runtime properties, you need to add an extra escape underscore when specifying pod templates.\nFor example, set the environment variable ",(0,s.jsx)(n.code,{children:"druid_indexer_runner_k8s_podTemplate_index__kafka"})," when you set the runtime property ",(0,s.jsx)(n.code,{children:"druid.indexer.runner.k8s.podTemplate.index_kafka"})]}),"\n",(0,s.jsx)(n.p,{children:"The following example shows a configuration for task-based pod template selection:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-properties",children:"druid.indexer.runner.k8s.podTemplate.base=/path/to/basePodSpec.yaml\ndruid.indexer.runner.k8s.podTemplate.index_kafka=/path/to/kafkaPodSpec.yaml\n"})}),"\n",(0,s.jsx)(n.h5,{id:"select-based-on-one-or-more-conditions",children:"Select based on one or more conditions"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"SelectorBasedPodTemplateSelectStrategy"})," strategy evaluates a series of criteria within ",(0,s.jsx)(n.code,{children:"selectors"})," to determine\nwhich pod template to use to run the task. Pod  templates are configured in the runtime properties like\n",(0,s.jsx)(n.code,{children:"druid.indexer.runner.k8s.podTemplate.<selectionKey>=..."}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "type": "selectorBased",\n  "selectors": [\n    {\n      "selectionKey": "podSpec1", \n      "context.tags":\n      {\n        "userProvidedTag": ["tag1", "tag2"]\n      },\n      "dataSource": ["wikipedia"]\n    },\n    {\n      "selectionKey": "podSpec2",\n      "type": ["index_kafka"]\n    }\n  ]\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Selectors are processed in order. Druid selects the template based on the first matching selector. If a  task does not\nmatch any selector in the list, it will use the ",(0,s.jsx)(n.code,{children:"base"})," pod template."]}),"\n",(0,s.jsx)(n.p,{children:"For a task to match a selector, all the conditions within the selector must match. A selector can match on"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"type"}),": Type of the task"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"dataSource"}),": Destination datasource of the task."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"context.tags"}),": Tags passed in the task's context."]}),"\n"]}),"\n",(0,s.jsx)(n.h5,{id:"example",children:"Example"}),"\n",(0,s.jsx)(n.p,{children:"Set the following runtime properties to define the pod specs that can be used by Druid."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-properties",children:"druid.indexer.runner.k8s.podTemplate.base=/path/to/basePodSpec.yaml\ndruid.indexer.runner.k8s.podTemplate.podSpec1=/path/to/podSpecWithHighMemRequests.yaml\ndruid.indexer.runner.k8s.podTemplate.podSpec2=/path/to/podSpecWithLowCpuRequests.yaml\n"})}),"\n",(0,s.jsx)(n.p,{children:"Set the dynamic execution config to define the pod template selection strategy."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "type": "default",\n  "podTemplateSelectStrategy": {\n    "type": "selectorBased",\n    "selectors": [\n      {\n        "selectionKey": "podSpec1",\n        "context.tags": { "userProvidedTag": ["tag1", "tag2"] },\n        "dataSource": ["wikipedia"]\n      },\n      {\n        "selectionKey": "podSpec2",\n        "type": ["index_kafka"]\n      }\n    ]\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Druid selects the pod templates as follows:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"podSpecWithHighMemRequests.yaml"})," when both of the following conditions are met:","\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["The task context contains a tag with the key ",(0,s.jsx)(n.code,{children:"userProvidedTag"})," that has the value ",(0,s.jsx)(n.code,{children:"tag1"})," or ",(0,s.jsx)(n.code,{children:"tag2"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["The task targets the ",(0,s.jsx)(n.code,{children:"wikipedia"})," datasource."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"podSpecWithLowCpuRequests.yaml"})," when the task type is ",(0,s.jsx)(n.code,{children:"index_kafka"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Use the ",(0,s.jsx)(n.code,{children:"basePodSpec.yaml"})," for all other tasks."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["In this example, if there is an ",(0,s.jsx)(n.code,{children:"index_kafka"})," task for the ",(0,s.jsx)(n.code,{children:"wikipedia"})," datasource with the tag ",(0,s.jsx)(n.code,{children:"userProvidedTag: tag1"}),",\nDruid selects the pod template ",(0,s.jsx)(n.code,{children:"podSpecWithHighMemRequests.yaml"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["In the above example, for selection key ",(0,s.jsx)(n.code,{children:"podSpec1"})," we didn't specify task ",(0,s.jsx)(n.code,{children:"type"}),". This is equivalent to setting ",(0,s.jsx)(n.code,{children:"type"})," to ",(0,s.jsx)(n.code,{children:"null"})," or an empty array.\nAll three examples below are equivalent."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Not setting ",(0,s.jsx)(n.code,{children:"type"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "selectionKey": "podSpec1",\n  "context.tags": { "userProvidedTag": ["tag1", "tag2"] },\n  "dataSource": ["wikipedia"]\n}\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Setting ",(0,s.jsx)(n.code,{children:"type"})," to ",(0,s.jsx)(n.code,{children:"null"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "selectionKey": "podSpec1",\n  "context.tags": { "userProvidedTag": ["tag1", "tag2"] },\n  "dataSource": ["wikipedia"],\n  "type": null\n}\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Setting ",(0,s.jsx)(n.code,{children:"type"})," to an empty array"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "selectionKey": "podSpec1",\n  "context.tags": { "userProvidedTag": ["tag1", "tag2"] },\n  "dataSource": ["wikipedia"],\n  "type": []\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["In all the above cases, Druid will match the selector to any value of task type. Druid applies similar logic for ",(0,s.jsx)(n.code,{children:"dataSource"}),". For ",(0,s.jsx)(n.code,{children:"context.tags"})," setting ",(0,s.jsx)(n.code,{children:"null"})," or an empty object ",(0,s.jsx)(n.code,{children:"{}"})," is equivalent."]}),"\n",(0,s.jsx)(n.h4,{id:"running-task-pods-in-another-namespace",children:"Running Task Pods in Another Namespace"}),"\n",(0,s.jsx)(n.p,{children:"It is possible to run task pods in a different namespace from the rest of your Druid cluster."}),"\n",(0,s.jsx)(n.p,{children:"If you are running multiple Druid clusters and would like to have a dedicated namespace for all your task pods, you can make the following changes to the runtime properties for your Overlord deployment:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"druid.indexer.runner.namespace"}),": The namespace where the task pods will run. It can be the same as the namespace where your Druid cluster is deployed, or different from it. In the latter case, you need to define the following ",(0,s.jsx)(n.code,{children:"overlordNamespace"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"druid.indexer.runner.overlordNamespace"}),": The namespace where the Overlord resides. This must be defined when tasks are scheduled in different namespace."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"druid.indexer.runner.k8sTaskPodNamePrefix"})," (Optional):  Self-defined field to differentiate which task pods are created from which namespace. More information ",(0,s.jsx)(n.a,{href:"#differentiating-task-pods-created-from-multiple-namespaces",children:"here"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Warning: When ",(0,s.jsx)(n.code,{children:"druid.indexer.runner.overlordNamespace"})," and ",(0,s.jsx)(n.code,{children:"druid.indexer.runner.k8sTaskPodNamePrefix"})," is configured, users should ensure that all running tasks are stopped when changing these values. Failure to do so will cause the Overlord to lose track of running tasks, and re-launch them. This may lead to duplicate data and possibly metadata inconsistency issues."]}),"\n",(0,s.jsxs)(n.p,{children:["Druid will tag Kubernetes jobs with a ",(0,s.jsx)(n.code,{children:"druid.overlord.namespace"})," label. This label helps Druid filter out Kubernetes jobs belonging to other namespaces. Should you need to deploy a Druid cluster on a namespace ",(0,s.jsx)(n.code,{children:"N1"})," that is already running tasks from another namespace ",(0,s.jsx)(n.code,{children:"N2"}),", take note to set ",(0,s.jsx)(n.code,{children:"druid.indexer.runner.overlordNamespace"})," to ",(0,s.jsx)(n.code,{children:"druid.indexer.runner.namespace"})," (which is ",(0,s.jsx)(n.code,{children:"N1"}),"). Failure to do so will result in the cluster in ",(0,s.jsx)(n.code,{children:"N1"})," detecting task pods created from both ",(0,s.jsx)(n.code,{children:"N1"})," and ",(0,s.jsx)(n.code,{children:"N2"}),"."]}),"\n",(0,s.jsx)(n.h5,{id:"differentiating-task-pods-created-from-multiple-namespaces",children:"Differentiating Task Pods Created From Multiple Namespaces"}),"\n",(0,s.jsxs)(n.p,{children:["When we have task pods started by Overlord servers of different Druid clusters, running in different K8S namespaces, it will be difficult to tell which task pods are being started by which overlord or Druid cluster. You can specify a task name prefix, ",(0,s.jsx)(n.code,{children:"druid.indexer.runner.k8sTaskPodNamePrefix"}),", to apply your specified prefix to all task pods created by your cluster."]}),"\n",(0,s.jsxs)(n.p,{children:["After configuration, you can witness the change from ",(0,s.jsx)(n.code,{children:"coordinatorissuedcompactdataso-0e74d5132781cc950eecf04--1-vbx6t"})," to ",(0,s.jsx)(n.code,{children:"yourtaskprefix-0e74d5132781cc950eecf04--1-vbx6t"})," by either doing ",(0,s.jsx)(n.code,{children:"kubectl get pods"}),' or by viewing the "Location" column under the web console.']}),"\n",(0,s.jsxs)(n.p,{children:["When configuring the ",(0,s.jsx)(n.code,{children:"druid.indexer.runner.k8sTaskPodNamePrefix"}),", you should note that:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The prefix will cut off at 30 characters, as the task pod names must respect a character limit of 63 in Kubernetes."}),"\n",(0,s.jsxs)(n.li,{children:["Special characters ",(0,s.jsx)(n.code,{children:": - . _"})," will be ignored."]}),"\n",(0,s.jsx)(n.li,{children:"The prefix will be converted to lowercase."}),"\n",(0,s.jsx)(n.li,{children:"All running tasks must be stopped during configuration. Failure to do so will cause the Overlord to lose track of running tasks, and re-launch them. This may lead to duplicate data and possibly metadata inconsistency issues."}),"\n"]}),"\n",(0,s.jsx)(n.h5,{id:"dealing-with-zookeeper-problems",children:"Dealing with ZooKeeper Problems"}),"\n",(0,s.jsxs)(n.p,{children:["Ensure that when you are running task pods in another namespace, your task pods are able to communicate with ZooKeeper which might be deployed in the same namespace with overlord. If you are using custom pod templates as described below, you can configure ",(0,s.jsx)(n.code,{children:"druid.zk.service.host"})," to your tasks."]}),"\n",(0,s.jsx)(n.h5,{id:"dealing-with-permissions",children:"Dealing with Permissions"}),"\n",(0,s.jsxs)(n.p,{children:["Should you require the needed permissions for interacting across Kubernetes namespaces, you can specify a kubeconfig file, and provided the necessary permissions. You can then use the ",(0,s.jsx)(n.code,{children:"KUBECONFIG"})," environment variable to allow your Overlord deployment to find your kubeconfig file. Refer to the ",(0,s.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/",children:"Kubernetes documentation"})," for more information."]}),"\n",(0,s.jsx)(n.h3,{id:"properties",children:"Properties"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Property"}),(0,s.jsx)(n.th,{children:"Possible Values"}),(0,s.jsx)(n.th,{children:"Description"}),(0,s.jsx)(n.th,{children:"Default"}),(0,s.jsx)(n.th,{children:"Required"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"druid.indexer.runner.namespace"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"String"})}),(0,s.jsx)(n.td,{children:"If Overlord and task pods are running in different namespaces, specify the Overlord namespace."}),(0,s.jsx)(n.td,{children:"-"}),(0,s.jsx)(n.td,{children:"Yes"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"druid.indexer.runner.overlordNamespace"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"String"})}),(0,s.jsxs)(n.td,{children:["Only applicable when using Custom Template Pod Adapter. If Overlord and task pods are running in different namespaces, specify the Overlord namespace. ",(0,s.jsx)("br",{})," Warning: You need to stop all running tasks in Druid to change this property. Failure to do so will lead to duplicate data and metadata inconsistencies."]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'""'})}),(0,s.jsx)(n.td,{children:"No"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"druid.indexer.runner.k8sTaskPodNamePrefix"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"String"})}),(0,s.jsxs)(n.td,{children:["Use this if you want to change your task name to contain a more human-readable prefix. Maximum 30 characters. Special characters ",(0,s.jsx)(n.code,{children:": - . _"})," will be ignored. ",(0,s.jsx)("br",{})," Warning: You need to stop all running tasks in Druid to change this property. Failure to do so will lead to duplicate data and metadata inconsistencies."]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'""'})}),(0,s.jsx)(n.td,{children:"No"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"druid.indexer.runner.debugJobs"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"boolean"})}),(0,s.jsx)(n.td,{children:"Clean up K8s jobs after tasks complete."}),(0,s.jsx)(n.td,{children:"False"}),(0,s.jsx)(n.td,{children:"No"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"druid.indexer.runner.sidecarSupport"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"boolean"})}),(0,s.jsxs)(n.td,{children:["Deprecated, specify adapter type as runtime property ",(0,s.jsx)(n.code,{children:"druid.indexer.runner.k8s.adapter.type: overlordMultiContainer"})," instead. If your overlord pod has sidecars, this will attempt to start the task with the same sidecars as the overlord pod."]}),(0,s.jsx)(n.td,{children:"False"}),(0,s.jsx)(n.td,{children:"No"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"druid.indexer.runner.primaryContainerName"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"String"})}),(0,s.jsxs)(n.td,{children:["If running with sidecars, the ",(0,s.jsx)(n.code,{children:"primaryContainerName"})," should be that of your druid container like ",(0,s.jsx)(n.code,{children:"druid-overlord"}),"."]}),(0,s.jsxs)(n.td,{children:["First container in ",(0,s.jsx)(n.code,{children:"podSpec"})," list"]}),(0,s.jsx)(n.td,{children:"No"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"druid.indexer.runner.kubexitImage"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"String"})}),(0,s.jsx)(n.td,{children:"Used kubexit project to help shutdown sidecars when the main pod completes. Otherwise, jobs with sidecars never terminate."}),(0,s.jsxs)(n.td,{children:["karlkfi/kubexit",":latest"]}),(0,s.jsx)(n.td,{children:"No"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"druid.indexer.runner.disableClientProxy"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"boolean"})}),(0,s.jsx)(n.td,{children:"Use this if you have a global http(s) proxy and you wish to bypass it."}),(0,s.jsx)(n.td,{children:"false"}),(0,s.jsx)(n.td,{children:"No"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"druid.indexer.runner.maxTaskDuration"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Duration"})}),(0,s.jsx)(n.td,{children:"Max time a task is allowed to run for before getting killed."}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"PT4H"})}),(0,s.jsx)(n.td,{children:"No"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"druid.indexer.runner.taskCleanupDelay"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Duration"})}),(0,s.jsx)(n.td,{children:"How long do jobs stay around before getting reaped from K8s."}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"P2D"})}),(0,s.jsx)(n.td,{children:"No"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"druid.indexer.runner.taskCleanupInterval"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Duration"})}),(0,s.jsx)(n.td,{children:"How often to check for jobs to be reaped."}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"PT10M"})}),(0,s.jsx)(n.td,{children:"No"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"druid.indexer.runner.taskJoinTimeout"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Duration"})}),(0,s.jsx)(n.td,{children:"Timeout for gathering metadata about existing tasks on startup."}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"PT1M"})}),(0,s.jsx)(n.td,{children:"No"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"druid.indexer.runner.K8sjobLaunchTimeout"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Duration"})}),(0,s.jsx)(n.td,{children:"How long to wait to launch a K8s task before marking it as failed, on a resource constrained cluster it may take some time."}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"PT1H"})}),(0,s.jsx)(n.td,{children:"No"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"druid.indexer.runner.javaOptsArray"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"JsonArray"})}),(0,s.jsx)(n.td,{children:"java opts for the task."}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"-Xmx1g"})}),(0,s.jsx)(n.td,{children:"No"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"druid.indexer.runner.labels"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"JsonObject"})}),(0,s.jsx)(n.td,{children:"Additional labels you want to add to peon pod."}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"{}"})}),(0,s.jsx)(n.td,{children:"No"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"druid.indexer.runner.annotations"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"JsonObject"})}),(0,s.jsx)(n.td,{children:"Additional annotations you want to add to peon pod."}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"{}"})}),(0,s.jsx)(n.td,{children:"No"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"druid.indexer.runner.peonMonitors"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"JsonArray"})}),(0,s.jsxs)(n.td,{children:["Overrides ",(0,s.jsx)(n.code,{children:"druid.monitoring.monitors"}),". Use this property if you don't want to inherit monitors from the Overlord."]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"[]"})}),(0,s.jsx)(n.td,{children:"No"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"druid.indexer.runner.graceTerminationPeriodSeconds"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Long"})}),(0,s.jsx)(n.td,{children:"Number of seconds you want to wait after a sigterm for container lifecycle hooks to complete. Keep at a smaller value if you want tasks to hold locks for shorter periods."}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"PT30S"})," (K8s default)"]}),(0,s.jsx)(n.td,{children:"No"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"druid.indexer.runner.capacity"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Integer"})}),(0,s.jsx)(n.td,{children:"Number of concurrent jobs that can be sent to Kubernetes."}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"2147483647"})}),(0,s.jsx)(n.td,{children:"No"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"druid.indexer.runner.cpuCoreInMicro"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Integer"})}),(0,s.jsx)(n.td,{children:"Number of CPU micro core for the task."}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"1000"})}),(0,s.jsx)(n.td,{children:"No"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"metrics-added",children:"Metrics added"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Metric"}),(0,s.jsx)(n.th,{children:"Description"}),(0,s.jsx)(n.th,{children:"Dimensions"}),(0,s.jsx)(n.th,{children:"Normal value"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"k8s/peon/startup/time"})}),(0,s.jsx)(n.td,{children:"Metric indicating the milliseconds for peon pod to startup."}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"dataSource"}),", ",(0,s.jsx)(n.code,{children:"taskId"}),", ",(0,s.jsx)(n.code,{children:"taskType"}),", ",(0,s.jsx)(n.code,{children:"groupId"}),", ",(0,s.jsx)(n.code,{children:"taskStatus"}),", ",(0,s.jsx)(n.code,{children:"tags"})]}),(0,s.jsx)(n.td,{children:"Varies"})]})})]}),"\n",(0,s.jsx)(n.h3,{id:"gotchas",children:"Gotchas"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"With the exception of task pods, all Druid Pods belonging to one Druid cluster must be inside the same Kubernetes namespace."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"You must have a role binding for the overlord's service account that provides the needed permissions for interacting with Kubernetes. An example spec could be:"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'kind: Role\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\n  namespace: <druid-namespace>\n  name: druid-k8s-task-scheduler\nrules:\n  - apiGroups: ["batch"]\n    resources: ["jobs"]\n    verbs: ["get", "watch", "list", "delete", "create"]\n  - apiGroups: [""]\n    resources: ["pods", "pods/log"]\n    verbs: ["get", "watch", "list", "delete", "create"]\n---\nkind: RoleBinding\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\n  name: druid-k8s-binding\n  namespace: <druid-namespace>\nsubjects:\n  - kind: ServiceAccount\n    name: <druid-overlord-k8s-service-account>\n    namespace: <druid-namespace>\nroleRef:\n  kind: Role\n  name: druid-k8s-task-scheduler\n  apiGroup: rbac.authorization.k8s.io\n'})}),"\n",(0,s.jsx)(n.h2,{id:"migrationkubernetes-and-worker-task-runner",children:"Migration/Kubernetes and Worker Task Runner"}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsx)(n.p,{children:"This feature is only available starting in Druid 28. If you require a rolling update to enable Kubernetes-based ingestion, first update your cluster to Druid 28 then apply the overlord configurations mentioned in this section."})}),"\n",(0,s.jsx)(n.p,{children:"If you are running a cluster with tasks running on middle managers or indexers and want to do a zero downtime migration to mm-less ingestion, the mm-less ingestion system is capable of running in migration mode by reading tasks from middle managers/indexers and Kubernetes and writing tasks to either middle managers or to Kubernetes."}),"\n",(0,s.jsxs)(n.p,{children:["To do this, set the following property.\n",(0,s.jsx)(n.code,{children:"druid.indexer.runner.type: k8sAndWorker"})," (instead of ",(0,s.jsx)(n.code,{children:"druid.indexer.runner.type: k8s"}),")"]}),"\n",(0,s.jsx)(n.h3,{id:"additional-configurations",children:"Additional Configurations"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Property"}),(0,s.jsx)(n.th,{children:"Possible Values"}),(0,s.jsx)(n.th,{children:"Description"}),(0,s.jsx)(n.th,{children:"Default"}),(0,s.jsx)(n.th,{children:"required"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"druid.indexer.runner.k8sAndWorker.runnerStrategy.type"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"String"})," (e.g., ",(0,s.jsx)(n.code,{children:"k8s"}),", ",(0,s.jsx)(n.code,{children:"worker"}),", ",(0,s.jsx)(n.code,{children:"taskType"}),")"]}),(0,s.jsx)(n.td,{children:"Defines the strategy for task runner selection."}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"k8s"})}),(0,s.jsx)(n.td,{children:"No"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"druid.indexer.runner.k8sAndWorker.runnerStrategy.workerType"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"String"})," (e.g., ",(0,s.jsx)(n.code,{children:"httpRemote"}),", ",(0,s.jsx)(n.code,{children:"remote"}),")"]}),(0,s.jsx)(n.td,{children:"Specifies the variant of the worker task runner to be utilized."}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"httpRemote"})}),(0,s.jsx)(n.td,{children:"No"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsxs)(n.strong,{children:["For ",(0,s.jsx)(n.code,{children:"taskType"})," runner strategy:"]})}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"druid.indexer.runner.k8sAndWorker.runnerStrategy.taskType.default"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"String"})," (e.g., ",(0,s.jsx)(n.code,{children:"k8s"}),", ",(0,s.jsx)(n.code,{children:"worker"}),")"]}),(0,s.jsx)(n.td,{children:"Specifies the default runner to use if no overrides apply. This setting ensures there is always a fallback runner available."}),(0,s.jsx)(n.td,{children:"None"}),(0,s.jsx)(n.td,{children:"No"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"druid.indexer.runner.k8sAndWorker.runnerStrategy.taskType.overrides"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"JsonObject"}),"(e.g., ",(0,s.jsx)(n.code,{children:'{"index_kafka": "worker"}'}),")"]}),(0,s.jsx)(n.td,{children:"Defines task-specific overrides for runner types. Each entry sets a task type to a specific runner, allowing fine control."}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"{}"})}),(0,s.jsx)(n.td,{children:"No"})]})]})]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},65537:(e,n,r)=>{r.d(n,{A:()=>b});var t=r(96540),s=r(18215),i=r(65627),d=r(56347),o=r(50372),a=r(30604),l=r(11861),c=r(78749);function h(e){var n,r;return null!=(n=null==(r=t.Children.toArray(e).filter((function(e){return"\n"!==e})).map((function(e){if(!e||(0,t.isValidElement)(e)&&((n=e.props)&&"object"==typeof n&&"value"in n))return e;var n;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:r.filter(Boolean))?n:[]}function u(e){var n=e.values,r=e.children;return(0,t.useMemo)((function(){var e=null!=n?n:function(e){return h(e).map((function(e){var n=e.props;return{value:n.value,label:n.label,attributes:n.attributes,default:n.default}}))}(r);return function(e){var n=(0,l.XI)(e,(function(e,n){return e.value===n.value}));if(n.length>0)throw new Error('Docusaurus error: Duplicate values "'+n.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[n,r])}function p(e){var n=e.value;return e.tabValues.some((function(e){return e.value===n}))}function x(e){var n=e.queryString,r=void 0!==n&&n,s=e.groupId,i=(0,d.W6)(),o=function(e){var n=e.queryString,r=void 0!==n&&n,t=e.groupId;if("string"==typeof r)return r;if(!1===r)return null;if(!0===r&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=t?t:null}({queryString:r,groupId:s});return[(0,a.aZ)(o),(0,t.useCallback)((function(e){if(o){var n=new URLSearchParams(i.location.search);n.set(o,e),i.replace(Object.assign({},i.location,{search:n.toString()}))}}),[o,i])]}function m(e){var n,r,s,i,d=e.defaultValue,a=e.queryString,l=void 0!==a&&a,h=e.groupId,m=u(e),j=(0,t.useState)((function(){return function(e){var n,r=e.defaultValue,t=e.tabValues;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(r){if(!p({value:r,tabValues:t}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+r+'" but none of its children has the corresponding value. Available values are: '+t.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return r}var s=null!=(n=t.find((function(e){return e.default})))?n:t[0];if(!s)throw new Error("Unexpected error: 0 tabValues");return s.value}({defaultValue:d,tabValues:m})})),f=j[0],g=j[1],y=x({queryString:l,groupId:h}),v=y[0],k=y[1],b=(n=function(e){return e?"docusaurus.tab."+e:null}({groupId:h}.groupId),r=(0,c.Dv)(n),s=r[0],i=r[1],[s,(0,t.useCallback)((function(e){n&&i.set(e)}),[n,i])]),T=b[0],w=b[1],S=function(){var e=null!=v?v:T;return p({value:e,tabValues:m})?e:null}();return(0,o.A)((function(){S&&g(S)}),[S]),{selectedValue:f,selectValue:(0,t.useCallback)((function(e){if(!p({value:e,tabValues:m}))throw new Error("Can't select invalid tab value="+e);g(e),k(e),w(e)}),[k,w,m]),tabValues:m}}var j=r(9136);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var g=r(74848);function y(e){var n=e.className,r=e.block,t=e.selectedValue,d=e.selectValue,o=e.tabValues,a=[],l=(0,i.a_)().blockElementScrollPositionUntilNextRender,c=function(e){var n=e.currentTarget,r=a.indexOf(n),s=o[r].value;s!==t&&(l(n),d(s))},h=function(e){var n,r=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":var t,s=a.indexOf(e.currentTarget)+1;r=null!=(t=a[s])?t:a[0];break;case"ArrowLeft":var i,d=a.indexOf(e.currentTarget)-1;r=null!=(i=a[d])?i:a[a.length-1]}null==(n=r)||n.focus()};return(0,g.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":r},n),children:o.map((function(e){var n=e.value,r=e.label,i=e.attributes;return(0,g.jsx)("li",Object.assign({role:"tab",tabIndex:t===n?0:-1,"aria-selected":t===n,ref:function(e){a.push(e)},onKeyDown:h,onClick:c},i,{className:(0,s.A)("tabs__item",f.tabItem,null==i?void 0:i.className,{"tabs__item--active":t===n}),children:null!=r?r:n}),n)}))})}function v(e){var n=e.lazy,r=e.children,i=e.selectedValue,d=(Array.isArray(r)?r:[r]).filter(Boolean);if(n){var o=d.find((function(e){return e.props.value===i}));return o?(0,t.cloneElement)(o,{className:(0,s.A)("margin-top--md",o.props.className)}):null}return(0,g.jsx)("div",{className:"margin-top--md",children:d.map((function(e,n){return(0,t.cloneElement)(e,{key:n,hidden:e.props.value!==i})}))})}function k(e){var n=m(e);return(0,g.jsxs)("div",{className:(0,s.A)("tabs-container",f.tabList),children:[(0,g.jsx)(y,Object.assign({},n,e)),(0,g.jsx)(v,Object.assign({},n,e))]})}function b(e){var n=(0,j.A)();return(0,g.jsx)(k,Object.assign({},e,{children:h(e.children)}),String(n))}},79329:(e,n,r)=>{r.d(n,{A:()=>d});r(96540);var t=r(18215);const s={tabItem:"tabItem_Ymn6"};var i=r(74848);function d(e){var n=e.children,r=e.hidden,d=e.className;return(0,i.jsx)("div",{role:"tabpanel",className:(0,t.A)(s.tabItem,d),hidden:r,children:n})}}}]);