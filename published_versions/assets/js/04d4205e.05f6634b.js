"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[3943],{28453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>r});var o=t(96540);const s={},i=o.createContext(s);function c(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),o.createElement(i.Provider,{value:n},e.children)}},40528:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>c,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"ingestion/concurrent-append-replace","title":"Concurrent append and replace","description":"\x3c!--","source":"@site/docs/latest/ingestion/concurrent-append-replace.md","sourceDirName":"ingestion","slug":"/ingestion/concurrent-append-replace","permalink":"/docs/latest/ingestion/concurrent-append-replace","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"concurrent-append-replace","title":"Concurrent append and replace"},"sidebar":"docs","previous":{"title":"Schema design tips","permalink":"/docs/latest/ingestion/schema-design"},"next":{"title":"Troubleshooting FAQ","permalink":"/docs/latest/ingestion/faq"}}');var s=t(74848),i=t(28453);const c={id:"concurrent-append-replace",title:"Concurrent append and replace"},r=void 0,a={},l=[{value:"Update compaction config to use concurrent locks",id:"update-compaction-config-to-use-concurrent-locks",level:2},{value:"Update compaction config from the Druid web-console",id:"update-compaction-config-from-the-druid-web-console",level:3},{value:"Update compaction config using REST API",id:"update-compaction-config-using-rest-api",level:3},{value:"Use concurrent locks in ingestion jobs",id:"use-concurrent-locks-in-ingestion-jobs",level:2},{value:"Use concurrent locks in the Druid web-console",id:"use-concurrent-locks-in-the-druid-web-console",level:3},{value:"Use concurrent locks in the REST APIs",id:"use-concurrent-locks-in-the-rest-apis",level:3},{value:"Update Overlord properties to use concurrent locks for all ingestion and compaction jobs",id:"update-overlord-properties-to-use-concurrent-locks-for-all-ingestion-and-compaction-jobs",level:2},{value:"Task lock types",id:"task-lock-types",level:2},{value:"Add a task lock type to your ingestion job",id:"add-a-task-lock-type-to-your-ingestion-job",level:4},{value:"Add a task lock using the Druid console",id:"add-a-task-lock-using-the-druid-console",level:5},{value:"Add the task lock type through the API",id:"add-the-task-lock-type-through-the-api",level:5},{value:"Known limitations",id:"known-limitations",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",h5:"h5",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Concurrent append and replace safely replaces the existing data in an interval of a datasource while new data is being appended to that interval. One of the most common applications of this feature is appending new data (such as with streaming ingestion) to an interval while compaction of that interval is already in progress. Druid partitions the data ingested during this time using ",(0,s.jsx)(n.code,{children:"dynamic"})," partitioning. The subsequent compaction run would partition the data into the granularity you specified in the compaction config."]}),"\n",(0,s.jsxs)(n.p,{children:["To set up concurrent append and replace, use the context flag ",(0,s.jsx)(n.code,{children:"useConcurrentLocks"}),". Druid will then determine the correct lock type for you, either append or replace. Although you can set the type of lock manually, we don't recommend it."]}),"\n",(0,s.jsx)(n.h2,{id:"update-compaction-config-to-use-concurrent-locks",children:"Update compaction config to use concurrent locks"}),"\n",(0,s.jsx)(n.p,{children:"If you want to append data to a datasource while compaction is running, you need to enable concurrent append and replace for the datasource by updating the compaction settings."}),"\n",(0,s.jsx)(n.h3,{id:"update-compaction-config-from-the-druid-web-console",children:"Update compaction config from the Druid web-console"}),"\n",(0,s.jsxs)(n.p,{children:["In the ",(0,s.jsx)(n.strong,{children:"Compaction config"})," for a datasource, enable  ",(0,s.jsx)(n.strong,{children:"Use concurrent locks"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["For details on accessing the compaction config in the UI, see ",(0,s.jsx)(n.a,{href:"/docs/latest/data-management/automatic-compaction#manage-auto-compaction-using-the-web-console",children:"Enable automatic compaction with the web console"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"update-compaction-config-using-rest-api",children:"Update compaction config using REST API"}),"\n",(0,s.jsxs)(n.p,{children:["Add the ",(0,s.jsx)(n.code,{children:"taskContext"})," like you would any other automatic compaction setting through the API:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:'curl --location --request POST \'http://localhost:8081/druid/coordinator/v1/config/compaction\' \\\n--header \'Content-Type: application/json\' \\\n--data-raw \'{\n    "dataSource": "YOUR_DATASOURCE",\n    "taskContext": {\n        "useConcurrentLocks": true\n    }\n}\'\n'})}),"\n",(0,s.jsx)(n.h2,{id:"use-concurrent-locks-in-ingestion-jobs",children:"Use concurrent locks in ingestion jobs"}),"\n",(0,s.jsx)(n.p,{children:"You also need to configure the ingestion job to allow concurrent locks."}),"\n",(0,s.jsx)(n.p,{children:"You can provide the context parameter like any other parameter for ingestion jobs through the API or the UI."}),"\n",(0,s.jsx)(n.h3,{id:"use-concurrent-locks-in-the-druid-web-console",children:"Use concurrent locks in the Druid web-console"}),"\n",(0,s.jsxs)(n.p,{children:["As part of the  ",(0,s.jsx)(n.strong,{children:"Load data"})," wizard for classic batch (JSON-based) ingestion and streaming ingestion, enable the following config on the ",(0,s.jsx)(n.strong,{children:"Publish"})," step: ",(0,s.jsx)(n.strong,{children:"Use concurrent locks"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"use-concurrent-locks-in-the-rest-apis",children:"Use concurrent locks in the REST APIs"}),"\n",(0,s.jsx)(n.p,{children:"Add the following JSON snippet to your supervisor or ingestion spec if you're using the API:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'"context": {\n   "useConcurrentLocks": true\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"update-overlord-properties-to-use-concurrent-locks-for-all-ingestion-and-compaction-jobs",children:"Update Overlord properties to use concurrent locks for all ingestion and compaction jobs"}),"\n",(0,s.jsxs)(n.p,{children:["Updating the compaction config and ingestion job for each data source can be cumbersome if you have several data sources in your cluster. You can instead set the following config in the ",(0,s.jsx)(n.code,{children:"runtime.properties"})," of the Overlord service to use concurrent locks across all ingestion and compaction jobs."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'druid.indexer.task.default.context={"useConcurrentLocks":true}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"task-lock-types",children:"Task lock types"}),"\n",(0,s.jsxs)(n.p,{children:["We recommend that you use the ",(0,s.jsx)(n.code,{children:"useConcurrentLocks"})," context parameter so that Druid automatically determines the task lock types for you. If, for some reason, you need to manually set the task lock types explicitly, you can read more about them in this section."]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Click here to read more about the lock types."}),(0,s.jsxs)(n.p,{children:["Druid uses task locks to make sure that multiple conflicting operations don't happen at once.\nThere are two task lock types: ",(0,s.jsx)(n.code,{children:"APPEND"})," and ",(0,s.jsx)(n.code,{children:"REPLACE"}),". The type of lock you use is determined by what you're trying to accomplish."]}),(0,s.jsx)(n.p,{children:"When setting task lock types manually, be aware of the following:"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The segment granularity of the append task must be equal to or finer than the segment granularity of the replace task."}),"\n",(0,s.jsxs)(n.li,{children:["Concurrent append and replace fails if the task with ",(0,s.jsx)(n.code,{children:"APPEND"})," lock uses a coarser segment granularity than the task with the ",(0,s.jsx)(n.code,{children:"REPLACE"})," lock. For example, if the ",(0,s.jsx)(n.code,{children:"APPEND"})," task uses a segment granularity of YEAR and the ",(0,s.jsx)(n.code,{children:"REPLACE"})," task uses a segment granularity of MONTH, you should not use concurrent append and replace."]}),"\n",(0,s.jsxs)(n.li,{children:["Only a single task can hold a ",(0,s.jsx)(n.code,{children:"REPLACE"})," lock on a given interval of a datasource."]}),"\n",(0,s.jsxs)(n.li,{children:["Multiple tasks can hold ",(0,s.jsx)(n.code,{children:"APPEND"})," locks on a given interval of a datasource and append data to that interval simultaneously."]}),"\n"]}),(0,s.jsx)(n.h4,{id:"add-a-task-lock-type-to-your-ingestion-job",children:"Add a task lock type to your ingestion job"}),(0,s.jsx)(n.p,{children:"You configure the task lock type for your ingestion job as follows:"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["For streaming jobs, the ",(0,s.jsx)(n.code,{children:"taskLockType"})," context parameter goes in your supervisor spec, and the lock type is always ",(0,s.jsx)(n.code,{children:"APPEND"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["For classic JSON-based batch ingestion, the ",(0,s.jsx)(n.code,{children:"taskLockType"})," context parameter goes in your ingestion spec, and the lock type can be either ",(0,s.jsx)(n.code,{children:"APPEND"})," or ",(0,s.jsx)(n.code,{children:"REPLACE"}),"."]}),"\n"]}),(0,s.jsx)(n.p,{children:"You can provide the context parameter through the API like any other parameter for ingestion job or through the UI."}),(0,s.jsx)(n.h5,{id:"add-a-task-lock-using-the-druid-console",children:"Add a task lock using the Druid console"}),(0,s.jsxs)(n.p,{children:["As part of the  ",(0,s.jsx)(n.strong,{children:"Load data"})," wizard for classic batch (JSON-based ingestion) and streaming ingestion, you can configure the task lock type for the ingestion during the ",(0,s.jsx)(n.strong,{children:"Publish"})," step:"]}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If you set ",(0,s.jsx)(n.strong,{children:"Append to existing"})," to ",(0,s.jsx)(n.strong,{children:"True"}),", you can then set ",(0,s.jsx)(n.strong,{children:"Allow concurrent append tasks (experimental)"})," to ",(0,s.jsx)(n.strong,{children:"True"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["If you set ",(0,s.jsx)(n.strong,{children:"Append to existing"})," to ",(0,s.jsx)(n.strong,{children:"False"}),", you can then set ",(0,s.jsx)(n.strong,{children:"Allow concurrent replace tasks (experimental)"})," to ",(0,s.jsx)(n.strong,{children:"True"}),"."]}),"\n"]}),(0,s.jsx)(n.h5,{id:"add-the-task-lock-type-through-the-api",children:"Add the task lock type through the API"}),(0,s.jsx)(n.p,{children:"Add the following JSON snippet to your supervisor or ingestion spec if you're using the API:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'"context": {\n   "taskLockType": LOCK_TYPE\n}   \n'})}),(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"LOCK_TYPE"})," depends on what you're trying to accomplish."]}),(0,s.jsxs)(n.p,{children:["Set ",(0,s.jsx)(n.code,{children:"taskLockType"})," to  ",(0,s.jsx)(n.code,{children:"APPEND"})," if either of the following are true:"]}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Dynamic partitioning with append to existing is set to ",(0,s.jsx)(n.code,{children:"true"})]}),"\n",(0,s.jsx)(n.li,{children:"The ingestion job is a streaming ingestion job"}),"\n"]}),(0,s.jsx)(n.p,{children:"If you have multiple ingestion jobs that append all targeting the same datasource and want them to run simultaneously, you need to also include the following context parameter:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'"useSharedLock": "true"\n'})}),(0,s.jsxs)(n.p,{children:["Keep in mind that ",(0,s.jsx)(n.code,{children:"taskLockType"})," takes precedence over ",(0,s.jsx)(n.code,{children:"useSharedLock"}),". Do not use ",(0,s.jsx)(n.code,{children:"useSharedLock"})," with ",(0,s.jsx)(n.code,{children:"REPLACE"})," task locks."]}),(0,s.jsxs)(n.p,{children:["Set  ",(0,s.jsx)(n.code,{children:"taskLockType"})," to ",(0,s.jsx)(n.code,{children:"REPLACE"})," if you're replacing data. For example, if you use any of the following partitioning types, use ",(0,s.jsx)(n.code,{children:"REPLACE"}),":"]}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"hash partitioning"}),"\n",(0,s.jsx)(n.li,{children:"range partitioning"}),"\n",(0,s.jsxs)(n.li,{children:["dynamic partitioning with append to existing set to ",(0,s.jsx)(n.code,{children:"false"})]}),"\n"]})]}),"\n",(0,s.jsx)(n.h2,{id:"known-limitations",children:"Known limitations"}),"\n",(0,s.jsx)(n.p,{children:"Do not use concurrent append and replace on a datasource if any one of the following is true:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The datasource has mixed granularity of data in any interval. For example, if an interval has both DAY and WEEK granularity data, using concurrent append and replace may result in data loss or duplication."}),"\n",(0,s.jsx)(n.li,{children:"The datasource has a compaction config which compacts data into more granular chunks. For example, a datasource that has MONTH data ingested into it and is configured to compact it into DAY granularity might suffer data losses or duplication."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);