"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[3583],{28453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>a});var s=t(96540);const r={},i=s.createContext(r);function l(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(i.Provider,{value:n},e.children)}},91892:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"querying/segmentmetadataquery","title":"SegmentMetadata queries","description":"\x3c!--","source":"@site/docs/33.0.0/querying/segmentmetadataquery.md","sourceDirName":"querying","slug":"/querying/segmentmetadataquery","permalink":"/docs/33.0.0/querying/segmentmetadataquery","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"segmentmetadataquery","title":"SegmentMetadata queries","sidebar_label":"SegmentMetadata"},"sidebar":"docs","previous":{"title":"TimeBoundary","permalink":"/docs/33.0.0/querying/timeboundaryquery"},"next":{"title":"DatasourceMetadata","permalink":"/docs/33.0.0/querying/datasourcemetadataquery"}}');var r=t(74848),i=t(28453);const l={id:"segmentmetadataquery",title:"SegmentMetadata queries",sidebar_label:"SegmentMetadata"},a=void 0,d={},o=[{value:"intervals",id:"intervals",level:2},{value:"toInclude",id:"toinclude",level:2},{value:"All",id:"all",level:3},{value:"None",id:"none",level:3},{value:"List",id:"list",level:3},{value:"analysisTypes",id:"analysistypes",level:2},{value:"cardinality",id:"cardinality",level:3},{value:"minmax",id:"minmax",level:3},{value:"size",id:"size",level:3},{value:"interval",id:"interval",level:3},{value:"timestampSpec",id:"timestampspec",level:3},{value:"queryGranularity",id:"querygranularity",level:3},{value:"aggregators",id:"aggregators",level:3},{value:"rollup",id:"rollup",level:3},{value:"aggregatorMergeStrategy",id:"aggregatormergestrategy",level:3},{value:"lenientAggregatorMerge (deprecated)",id:"lenientaggregatormerge-deprecated",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["Apache Druid supports two query languages: ",(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/sql",children:"Druid SQL"})," and ",(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/",children:"native queries"}),".\nThis document describes a query\ntype that is only available in the native language. However, Druid SQL contains similar functionality in\nits ",(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/sql-metadata-tables",children:"metadata tables"}),"."]})}),"\n",(0,r.jsx)(n.p,{children:"Segment metadata queries return per-segment information about:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Number of rows stored inside the segment"}),"\n",(0,r.jsx)(n.li,{children:"Interval the segment covers"}),"\n",(0,r.jsx)(n.li,{children:"Estimated total segment byte size in if it was stored in a 'flat format' (e.g. a csv file)"}),"\n",(0,r.jsx)(n.li,{children:"Segment id"}),"\n",(0,r.jsx)(n.li,{children:"Is the segment rolled up"}),"\n",(0,r.jsxs)(n.li,{children:["Detailed per column information such as:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"type"}),"\n",(0,r.jsx)(n.li,{children:"cardinality"}),"\n",(0,r.jsx)(n.li,{children:"min/max values"}),"\n",(0,r.jsx)(n.li,{children:"presence of null values"}),"\n",(0,r.jsx)(n.li,{children:"estimated 'flat format' byte size"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "queryType":"segmentMetadata",\n  "dataSource":"sample_datasource",\n  "intervals":["2013-01-01/2014-01-01"]\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"There are several main parts to a segment metadata query:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"property"}),(0,r.jsx)(n.th,{children:"description"}),(0,r.jsx)(n.th,{children:"required?"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"queryType"}),(0,r.jsx)(n.td,{children:'This String should always be "segmentMetadata"; this is the first thing Apache Druid looks at to figure out how to interpret the query'}),(0,r.jsx)(n.td,{children:"yes"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"dataSource"}),(0,r.jsxs)(n.td,{children:["A String or Object defining the data source to query, very similar to a table in a relational database. See ",(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/datasource",children:"DataSource"})," for more information."]}),(0,r.jsx)(n.td,{children:"yes"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"intervals"}),(0,r.jsx)(n.td,{children:"A JSON Object representing ISO-8601 Intervals. This defines the time ranges to run the query over."}),(0,r.jsx)(n.td,{children:"no"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"toInclude"}),(0,r.jsx)(n.td,{children:'A JSON Object representing what columns should be included in the result. Defaults to "all".'}),(0,r.jsx)(n.td,{children:"no"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"merge"}),(0,r.jsx)(n.td,{children:"Merge all individual segment metadata results into a single result"}),(0,r.jsx)(n.td,{children:"no"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"context"}),(0,r.jsxs)(n.td,{children:["See ",(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/query-context",children:"Context"})]}),(0,r.jsx)(n.td,{children:"no"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"analysisTypes"}),(0,r.jsxs)(n.td,{children:['A list of Strings specifying what column properties (e.g. cardinality, size) should be calculated and returned in the result. Defaults to ["cardinality", "interval", "minmax"], but can be overridden with using the ',(0,r.jsx)(n.a,{href:"/docs/33.0.0/configuration/#segmentmetadata-query-config",children:"segment metadata query config"}),". See section ",(0,r.jsx)(n.a,{href:"#analysistypes",children:"analysisTypes"})," for more details."]}),(0,r.jsx)(n.td,{children:"no"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"aggregatorMergeStrategy"}),(0,r.jsxs)(n.td,{children:["The strategy Druid uses to merge aggregators across segments. If true and if the ",(0,r.jsx)(n.code,{children:"aggregators"})," analysis type is enabled, ",(0,r.jsx)(n.code,{children:"aggregatorMergeStrategy"})," defaults to ",(0,r.jsx)(n.code,{children:"strict"}),". Possible values include ",(0,r.jsx)(n.code,{children:"strict"}),", ",(0,r.jsx)(n.code,{children:"lenient"}),", ",(0,r.jsx)(n.code,{children:"earliest"}),", and ",(0,r.jsx)(n.code,{children:"latest"}),". See ",(0,r.jsx)(n.a,{href:"#aggregatormergestrategy",children:(0,r.jsx)(n.code,{children:"aggregatorMergeStrategy"})})," for details."]}),(0,r.jsx)(n.td,{children:"no"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"lenientAggregatorMerge"}),(0,r.jsxs)(n.td,{children:["Deprecated. Use ",(0,r.jsx)(n.code,{children:"aggregatorMergeStrategy"})," property instead. If true, and if the ",(0,r.jsx)(n.code,{children:"aggregators"})," analysis type is enabled, Druid merges aggregators leniently."]}),(0,r.jsx)(n.td,{children:"no"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:"The format of the result is:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'[ {\n  "id" : "some_id",\n  "intervals" : [ "2013-05-13T00:00:00.000Z/2013-05-14T00:00:00.000Z" ],\n  "columns" : {\n    "__time" : { "type" : "LONG", "hasMultipleValues" : false, "hasNulls": false, "size" : 407240380, "cardinality" : null, "errorMessage" : null },\n    "dim1" : { "type" : "STRING", "hasMultipleValues" : false, "hasNulls": false, "size" : 100000, "cardinality" : 1944, "errorMessage" : null },\n    "dim2" : { "type" : "STRING", "hasMultipleValues" : true, "hasNulls": true, "size" : 100000, "cardinality" : 1504, "errorMessage" : null },\n    "metric1" : { "type" : "FLOAT", "hasMultipleValues" : false, "hasNulls": false, "size" : 100000, "cardinality" : null, "errorMessage" : null }\n  },\n  "aggregators" : {\n    "metric1" : { "type" : "longSum", "name" : "metric1", "fieldName" : "metric1" }\n  },\n  "queryGranularity" : {\n    "type": "none"\n  },\n  "size" : 300000,\n  "numRows" : 5000000\n} ]\n'})}),"\n",(0,r.jsxs)(n.p,{children:["All columns contain a ",(0,r.jsx)(n.code,{children:"typeSignature"})," that Druid uses to represent the column type information internally. The ",(0,r.jsx)(n.code,{children:"typeSignature"})," is typically the same value used to identify the JSON type information at query or ingest time. One of: ",(0,r.jsx)(n.code,{children:"STRING"}),", ",(0,r.jsx)(n.code,{children:"FLOAT"}),", ",(0,r.jsx)(n.code,{children:"DOUBLE"}),", ",(0,r.jsx)(n.code,{children:"LONG"}),", or ",(0,r.jsx)(n.code,{children:"COMPLEX<typeName>"}),", e.g. ",(0,r.jsx)(n.code,{children:"COMPLEX<hyperUnique>"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Columns also have a legacy ",(0,r.jsx)(n.code,{children:"type"})," name. For some column types, the value may match the ",(0,r.jsx)(n.code,{children:"typeSignature"}),"  (",(0,r.jsx)(n.code,{children:"STRING"}),", ",(0,r.jsx)(n.code,{children:"FLOAT"}),", ",(0,r.jsx)(n.code,{children:"DOUBLE"}),", or ",(0,r.jsx)(n.code,{children:"LONG"}),"). For ",(0,r.jsx)(n.code,{children:"COMPLEX"})," columns, the ",(0,r.jsx)(n.code,{children:"type"})," only contains the name of the underlying complex type such as ",(0,r.jsx)(n.code,{children:"hyperUnique"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["New applications should use ",(0,r.jsx)(n.code,{children:"typeSignature"}),", not ",(0,r.jsx)(n.code,{children:"type"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["If the ",(0,r.jsx)(n.code,{children:"errorMessage"})," field is non-null, you should not trust the other fields in the response. Their contents are\nundefined."]}),"\n",(0,r.jsxs)(n.p,{children:["Only columns which are dictionary encoded (i.e., have type ",(0,r.jsx)(n.code,{children:"STRING"}),") will have any cardinality. Rest of the columns (timestamp and metric columns) will show cardinality as ",(0,r.jsx)(n.code,{children:"null"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"intervals",children:"intervals"}),"\n",(0,r.jsx)(n.p,{children:"If an interval is not specified, the query will use a default interval that spans a configurable period before the end time of the most recent segment."}),"\n",(0,r.jsx)(n.p,{children:"The length of this default time period is set in the Broker configuration via:\ndruid.query.segmentMetadata.defaultHistory"}),"\n",(0,r.jsx)(n.h2,{id:"toinclude",children:"toInclude"}),"\n",(0,r.jsx)(n.p,{children:"There are 3 types of toInclude objects."}),"\n",(0,r.jsx)(n.h3,{id:"all",children:"All"}),"\n",(0,r.jsx)(n.p,{children:"The grammar is as follows:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'"toInclude": { "type": "all"}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"none",children:"None"}),"\n",(0,r.jsx)(n.p,{children:"The grammar is as follows:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'"toInclude": { "type": "none"}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"list",children:"List"}),"\n",(0,r.jsx)(n.p,{children:"The grammar is as follows:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'"toInclude": { "type": "list", "columns": [<string list of column names>]}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"analysistypes",children:"analysisTypes"}),"\n",(0,r.jsx)(n.p,{children:"This is a list of properties that determines the amount of information returned about the columns, i.e. analyses to be performed on the columns."}),"\n",(0,r.jsx)(n.p,{children:'By default, the "cardinality", "interval", and "minmax" types will be used. If a property is not needed, omitting it from this list will result in a more efficient query.'}),"\n",(0,r.jsxs)(n.p,{children:["The default analysis types can be set in the Broker configuration via:\n",(0,r.jsx)(n.code,{children:"druid.query.segmentMetadata.defaultAnalysisTypes"})]}),"\n",(0,r.jsx)(n.p,{children:"Types of column analyses are described below:"}),"\n",(0,r.jsx)(n.h3,{id:"cardinality",children:"cardinality"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"cardinality"})," is the number of unique values present in string columns. It is null for other column types."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Druid examines the size of string column dictionaries to compute the cardinality value. There is one dictionary per column per\nsegment. If ",(0,r.jsx)(n.code,{children:"merge"})," is off (false), this reports the cardinality of each column of each segment individually. If\n",(0,r.jsx)(n.code,{children:"merge"})," is on (true), this reports the highest cardinality encountered for a particular column across all relevant\nsegments."]}),"\n",(0,r.jsx)(n.h3,{id:"minmax",children:"minmax"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Estimated min/max values for each column. Only reported for string columns."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"size",children:"size"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"size"})," is the estimated total byte size as if the data were stored in text format. This is ",(0,r.jsx)(n.em,{children:"not"})," the actual storage\nsize of the column in Druid. If you want the actual storage size in bytes of a segment, look elsewhere. Some pointers:"]}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["To get the storage size in bytes of an entire segment, check the ",(0,r.jsx)(n.code,{children:"size"})," field in the\n",(0,r.jsxs)(n.a,{href:"/docs/33.0.0/querying/sql-metadata-tables#segments-table",children:[(0,r.jsx)(n.code,{children:"sys.segments"})," table"]}),". This is the size of the memory-mappable content."]}),"\n",(0,r.jsxs)(n.li,{children:["To get the storage size in bytes of a particular column in a particular segment, unpack the segment and look at the\n",(0,r.jsx)(n.code,{children:"meta.smoosh"})," file inside the archive. The difference between the third and fourth columns is the size in bytes.\nCurrently, there is no API for retrieving this information."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"interval",children:"interval"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"intervals"})," in the result will contain the list of intervals associated with the queried segments."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"timestampspec",children:"timestampSpec"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"timestampSpec"})," in the result will contain timestampSpec of data stored in segments. this can be null if timestampSpec of segments was unknown or unmergeable (if merging is enabled)."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"querygranularity",children:"queryGranularity"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"queryGranularity"})," in the result will contain query granularity of data stored in segments. this can be null if query granularity of segments was unknown or unmergeable (if merging is enabled)."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"aggregators",children:"aggregators"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"aggregators"})," in the result will contain the list of aggregators usable for querying metric columns. This may be\nnull if the aggregators are unknown or unmergeable (if merging is enabled)."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Merging can be ",(0,r.jsx)(n.code,{children:"strict"}),", ",(0,r.jsx)(n.code,{children:"lenient"}),", ",(0,r.jsx)(n.code,{children:"earliest"}),", or ",(0,r.jsx)(n.code,{children:"latest"}),". See ",(0,r.jsx)(n.a,{href:"#aggregatormergestrategy",children:(0,r.jsx)(n.code,{children:"aggregatorMergeStrategy"})})," for details."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"The form of the result is a map of column name to aggregator."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"rollup",children:"rollup"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"rollup"})," in the result is true/false/null."]}),"\n",(0,r.jsx)(n.li,{children:"When merging is enabled, if some are rollup, others are not, result is null."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"aggregatormergestrategy",children:"aggregatorMergeStrategy"}),"\n",(0,r.jsxs)(n.p,{children:["Conflicts between aggregator metadata across segments can occur if some segments have unknown aggregators, or if\ntwo segments use incompatible aggregators for the same column, such as ",(0,r.jsx)(n.code,{children:"longSum"})," changed to ",(0,r.jsx)(n.code,{children:"doubleSum"}),".\nDruid supports the following aggregator merge strategies:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"strict"}),": If there are any segments with unknown aggregators or any conflicts of any kind, the merged aggregators\nlist is ",(0,r.jsx)(n.code,{children:"null"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"lenient"}),": Druid ignores segments with unknown aggregators. Conflicts between aggregators set the aggregator for\nthat particular column to null."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"earliest"}),": In the event of conflicts between segments, Druid selects the aggregator from the earliest segment\nfor that particular column."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"latest"}),": In the event of conflicts between segments, Druid selects the aggregator from the most recent segment\nfor that particular column."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"lenientaggregatormerge-deprecated",children:"lenientAggregatorMerge (deprecated)"}),"\n",(0,r.jsxs)(n.p,{children:["Deprecated. Use ",(0,r.jsx)(n.a,{href:"#aggregatormergestrategy",children:(0,r.jsx)(n.code,{children:"aggregatorMergeStrategy"})})," instead."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);