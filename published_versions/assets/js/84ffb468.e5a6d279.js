"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6195],{28453:(e,r,n)=>{n.d(r,{R:()=>o,x:()=>a});var i=n(96540);const s={},t=i.createContext(s);function o(e){const r=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(t.Provider,{value:r},e.children)}},56352:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>o,metadata:()=>i,toc:()=>u});const i=JSON.parse('{"id":"querying/tips-good-queries","title":"Tips for writing good queries in Druid","description":"\x3c!--","source":"@site/docs/33.0.0/querying/tips-good-queries.md","sourceDirName":"querying","slug":"/querying/tips-good-queries","permalink":"/docs/33.0.0/querying/tips-good-queries","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"tips-good-queries","title":"Tips for writing good queries in Druid","sidebar_label":"Tips for writing good queries"},"sidebar":"docs","previous":{"title":"All functions","permalink":"/docs/33.0.0/querying/sql-functions"},"next":{"title":"Query from deep storage","permalink":"/docs/33.0.0/querying/query-deep-storage"}}');var s=n(74848),t=n(28453);const o={id:"tips-good-queries",title:"Tips for writing good queries in Druid",sidebar_label:"Tips for writing good queries"},a=void 0,l={},u=[{value:"Investigate query performance",id:"investigate-query-performance",level:2},{value:"Analyze query metrics",id:"analyze-query-metrics",level:3},{value:"Generate an explain plan",id:"generate-an-explain-plan",level:3},{value:"Improve query performance",id:"improve-query-performance",level:2},{value:"Adjust Druid settings",id:"adjust-druid-settings",level:3},{value:"Turn on query caching",id:"turn-on-query-caching",level:4},{value:"Use approximation",id:"use-approximation",level:4},{value:"Manually tune your queries",id:"manually-tune-your-queries",level:3},{value:"Query one table at a time",id:"query-one-table-at-a-time",level:4},{value:"Select specific columns",id:"select-specific-columns",level:4},{value:"Use filters",id:"use-filters",level:4},{value:"Shorten your queries",id:"shorten-your-queries",level:4},{value:"Minimize or remove subqueries",id:"minimize-or-remove-subqueries",level:4},{value:"Consider alternatives to GroupBy",id:"consider-alternatives-to-groupby",level:4},{value:"Query over smaller intervals",id:"query-over-smaller-intervals",level:4},{value:"Reduce the computation in your queries",id:"reduce-the-computation-in-your-queries",level:4},{value:"Druid SQL query example",id:"druid-sql-query-example",level:2}];function d(e){const r={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.p,{children:["This topic includes tips and examples that can help you investigate and improve query performance and accuracy using ",(0,s.jsx)(r.a,{href:"/docs/33.0.0/querying/sql",children:"Apache Druid SQL"}),"."]}),"\n",(0,s.jsxs)(r.p,{children:["For an interactive tutorial on Druid SQL, see ",(0,s.jsx)(r.a,{href:"https://github.com/implydata/learn-druid/tree/main/notebooks",children:"Learn the basics of Druid SQL"})," within the ",(0,s.jsx)(r.a,{href:"https://github.com/implydata/learn-druid",children:"Learn Druid repo"}),"."]}),"\n",(0,s.jsxs)(r.p,{children:["Your ability to effectively query your data depends in large part on the way you've ingested and stored the data in Apache Druid. This document assumes that you've followed the best practices described in ",(0,s.jsx)(r.a,{href:"/docs/33.0.0/ingestion/schema-design#general-tips-and-best-practices",children:"Schema design tips and best practices"})," when modeling your data."]}),"\n",(0,s.jsx)(r.h2,{id:"investigate-query-performance",children:"Investigate query performance"}),"\n",(0,s.jsx)(r.p,{children:"If your queries run slower than anticipated, you can use the following tools to investigate query performance issues."}),"\n",(0,s.jsx)(r.h3,{id:"analyze-query-metrics",children:"Analyze query metrics"}),"\n",(0,s.jsxs)(r.p,{children:["You can configure Druid processes to emit metrics that are essential for monitoring query execution. See ",(0,s.jsx)(r.a,{href:"/docs/33.0.0/operations/metrics#query-metrics",children:"Query metrics"})," for more information."]}),"\n",(0,s.jsx)(r.h3,{id:"generate-an-explain-plan",children:"Generate an explain plan"}),"\n",(0,s.jsx)(r.p,{children:"An explain plan shows the full query details and all of the operations Druid performs to execute it. You can use the information in the plan to identify possible areas of query improvement."}),"\n",(0,s.jsxs)(r.p,{children:["See ",(0,s.jsx)(r.a,{href:"/docs/33.0.0/querying/sql#explain-plan",children:"Explain plan"})," and ",(0,s.jsx)(r.a,{href:"/docs/33.0.0/querying/sql-translation#interpreting-explain-plan-output",children:"Interpreting explain plan output"})," for more information."]}),"\n",(0,s.jsxs)(r.p,{children:["You can follow the ",(0,s.jsx)(r.a,{href:"/docs/33.0.0/tutorials/tutorial-sql-query-view",children:"Get to know Query view tutorial"})," to create an example explain plan in the Druid console."]}),"\n",(0,s.jsx)(r.h2,{id:"improve-query-performance",children:"Improve query performance"}),"\n",(0,s.jsx)(r.p,{children:"In most cases, you can improve query performance by adjusting Druid settings and by manually tuning your queries."}),"\n",(0,s.jsx)(r.h3,{id:"adjust-druid-settings",children:"Adjust Druid settings"}),"\n",(0,s.jsx)(r.p,{children:"This section outlines Druid settings that can help to improve query performance."}),"\n",(0,s.jsx)(r.h4,{id:"turn-on-query-caching",children:"Turn on query caching"}),"\n",(0,s.jsx)(r.p,{children:"You can enable caching in Druid to improve query times for frequently accessed data. Caching enables increased concurrency on the same system, leading to noticeable performance improvements for queries handling throughput for concurrent, mixed workloads."}),"\n",(0,s.jsxs)(r.p,{children:["The largest performance gains from caching tend to apply to TopN and timeseries queries. For GroupBy queries, if the bottleneck is in the merging phase on the Broker, enabling caching results in little noticeable query improvement. See ",(0,s.jsx)(r.a,{href:"/docs/33.0.0/querying/caching#performance-considerations-for-caching",children:"Performance considerations for caching"})," for more information."]}),"\n",(0,s.jsx)(r.h4,{id:"use-approximation",children:"Use approximation"}),"\n",(0,s.jsx)(r.p,{children:"When possible, design your SQL queries in such a way that they match the rules for TopN approximation, so that Druid enables TopN by default. For Druid to automatically optimize for TopN, your SQL query must include the following:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"GROUP BY on one dimension, and"}),"\n",(0,s.jsx)(r.li,{children:"ORDER BY on one aggregate."}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:["See ",(0,s.jsx)(r.a,{href:"/docs/33.0.0/querying/topnquery",children:"TopN queries"})," for more information."]}),"\n",(0,s.jsx)(r.p,{children:"Note that TopN queries are approximate in that each data process ranks its top K results and only returns those top K results to the Broker."}),"\n",(0,s.jsxs)(r.p,{children:["You can follow the tutorial ",(0,s.jsx)(r.a,{href:"https://github.com/implydata/learn-druid/tree/main/notebooks",children:"Using TopN approximation in Druid queries"})," within the ",(0,s.jsx)(r.a,{href:"https://github.com/implydata/learn-druid",children:"Learn Druid repo"})," to work through some examples with approximation turned on and off.\nThe tutorial ",(0,s.jsx)(r.a,{href:"/docs/33.0.0/tutorials/tutorial-sql-query-view",children:"Get to know Query view"})," demonstrates running aggregate queries in the Druid console."]}),"\n",(0,s.jsx)(r.h3,{id:"manually-tune-your-queries",children:"Manually tune your queries"}),"\n",(0,s.jsx)(r.p,{children:"This section outlines techniques you can use to improve your query accuracy and performance."}),"\n",(0,s.jsx)(r.h4,{id:"query-one-table-at-a-time",children:"Query one table at a time"}),"\n",(0,s.jsx)(r.p,{children:"Query a single table at a time to minimize the load on the Druid processor."}),"\n",(0,s.jsx)(r.h4,{id:"select-specific-columns",children:"Select specific columns"}),"\n",(0,s.jsx)(r.p,{children:"Only select the columns needed for the query instead of retrieving all columns from the table. This reduces the amount of data retrieved from the database, which improves query performance."}),"\n",(0,s.jsx)(r.h4,{id:"use-filters",children:"Use filters"}),"\n",(0,s.jsx)(r.p,{children:"Use filters, for example the WHERE clause, and filter on time. Try to minimize the use of inequality filters, because they're very resource-intensive."}),"\n",(0,s.jsxs)(r.p,{children:["The following example query filters on ",(0,s.jsx)(r.code,{children:"__time"})," and ",(0,s.jsx)(r.code,{children:"product"}),":"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"SELECT\n  FLOOR(__time to day),\n  product,\n  sum(quantity * price) as revenue\nFROM \"orders\"\nWHERE\n  __time > '2023-08-20' and product = 'product 1'\nGROUP BY 1, 2\n"})}),"\n",(0,s.jsxs)(r.p,{children:["The following example uses a wildcard filter on the ",(0,s.jsx)(r.code,{children:"diffUrl"})," column:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"SELECT * from Wikipedia\nWHERE diffUrl LIKE 'https://en.wikipedia%'\nAND TIME_IN_INTERVAL(__time, '2016-06-27T01:00:00/2016-06-27T02:00:00')\n"})}),"\n",(0,s.jsx)(r.h4,{id:"shorten-your-queries",children:"Shorten your queries"}),"\n",(0,s.jsx)(r.p,{children:"Make your queries shorter where possible\u2014Druid processes shorter queries faster. You might also be able to divide a single query into multiple queries."}),"\n",(0,s.jsx)(r.p,{children:"For example, the following query aggregates over multiple datasources using UNION ALL:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"SELECT id, SUM(revenue) FROM\n   (SELECT id, revenue from datasource_1\nUNION ALL\n  SELECT id, revenue FROM datasource_2)\n...\nUNION ALL\n   SELECT id, revenue FROM datasource_n)\nGROUP BY id\n"})}),"\n",(0,s.jsx)(r.p,{children:"To simplify this query, you could split it into several queries, for example:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"SELECT id, SUM(revenue) FROM datasource_1\n\nSELECT id, SUM(revenue) FROM datasource_2\n...\nSELECT id, SUM(revenue) FROM datasource_n\n"})}),"\n",(0,s.jsx)(r.p,{children:"You could then manually aggregate the results of the individual queries."}),"\n",(0,s.jsx)(r.h4,{id:"minimize-or-remove-subqueries",children:"Minimize or remove subqueries"}),"\n",(0,s.jsxs)(r.p,{children:["Consider whether you can pre-compute a subquery task and store it as a join or make it a part of the datasource. See ",(0,s.jsx)(r.a,{href:"/docs/33.0.0/querying/datasource#join",children:"Datasources: join"})," and ",(0,s.jsx)(r.a,{href:"/docs/33.0.0/querying/sql-translation#joins",children:"SQL query translation: Joins"})," for more information and examples."]}),"\n",(0,s.jsx)(r.h4,{id:"consider-alternatives-to-groupby",children:"Consider alternatives to GroupBy"}),"\n",(0,s.jsxs)(r.p,{children:["Consider using Timeseries and TopN as alternatives to GroupBy. See ",(0,s.jsx)(r.a,{href:"/docs/33.0.0/querying/groupbyquery#alternatives",children:"GroupBy queries: alternatives"})," for more information."]}),"\n",(0,s.jsx)(r.p,{children:"Avoid grouping on high cardinality columns, for example user ID. Investigate whether you can apply a filter first, to reduce the number of results for grouping."}),"\n",(0,s.jsx)(r.h4,{id:"query-over-smaller-intervals",children:"Query over smaller intervals"}),"\n",(0,s.jsx)(r.p,{children:"Consider whether you can query a smaller time interval to return a smaller results set."}),"\n",(0,s.jsx)(r.p,{children:"For example, the following query doesn't limit on time and could be resource-intensive:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"SELECT cust_id, sum(revenue) FROM myDatasource\nGROUP BY cust_id\n"})}),"\n",(0,s.jsx)(r.p,{children:"This query could be split into multiple queries over smaller time spans, with the results combined client-side. For example:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"SELECT cust_id, sum(revenue) FROM myDatasource\nGROUP BY cust_id\nWHERE __time BETWEEN '2023-07-01' AND '2023-07-31'\n\nSELECT cust_id, sum(revenue) FROM myDatasource\nGROUP BY cust_id\nWHERE __time BETWEEN '2023-08-01' AND '2023-08-31'\n"})}),"\n",(0,s.jsx)(r.h4,{id:"reduce-the-computation-in-your-queries",children:"Reduce the computation in your queries"}),"\n",(0,s.jsx)(r.p,{children:"Examine your query to see if it uses a lot of transformations, functions, and expressions. Consider whether you could rewrite the query to reduce the level of computation."}),"\n",(0,s.jsx)(r.h2,{id:"druid-sql-query-example",children:"Druid SQL query example"}),"\n",(0,s.jsx)(r.p,{children:"The following example query demonstrates many of the tips outlined in this topic.\nThe query:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"selects specific dimensions and metrics"}),"\n",(0,s.jsx)(r.li,{children:"uses approximation"}),"\n",(0,s.jsx)(r.li,{children:"selects from a single table"}),"\n",(0,s.jsx)(r.li,{children:"groups by low cardinality columns"}),"\n",(0,s.jsx)(r.li,{children:"filters on both dimensions and time"}),"\n",(0,s.jsx)(r.li,{children:"orders by a dimension and a measure"}),"\n",(0,s.jsx)(r.li,{children:"includes a limit"}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"SELECT\n   FLOOR() AS month,\n   country,\n   SUM(price),\n   APPROX_COUNT_DISTINCT_DS_HLL(userid)\nFROM sales\nGROUP BY month, country\nWHERE artist = 'Madonna' AND TIME_IN_INTERVAL(__time, '2023-08-01/P1M')\nORDER BY country, SUM(price) DESC\nLIMIT 100\n"})})]})}function c(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);