"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6182],{28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var s=n(96540);const o={},r=s.createContext(o);function i(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(r.Provider,{value:t},e.children)}},58518:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"operations/insert-segment-to-db","title":"insert-segment-to-db tool","description":"\x3c!--","source":"@site/docs/33.0.0/operations/insert-segment-to-db.md","sourceDirName":"operations","slug":"/operations/insert-segment-to-db","permalink":"/docs/33.0.0/operations/insert-segment-to-db","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"insert-segment-to-db","title":"insert-segment-to-db tool"},"sidebar":"docs","previous":{"title":"reset-cluster tool","permalink":"/docs/33.0.0/operations/reset-cluster"},"next":{"title":"pull-deps tool","permalink":"/docs/33.0.0/operations/pull-deps"}}');var o=n(74848),r=n(28453);const i={id:"insert-segment-to-db",title:"insert-segment-to-db tool"},a=void 0,d={},l=[];function c(e){const t={a:"a",code:"code",em:"em",li:"li",ol:"ol",p:"p",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["In older versions of Apache Druid, ",(0,o.jsx)(t.code,{children:"insert-segment-to-db"})," was a tool that could scan deep storage and\ninsert data from there into Druid metadata storage. It was intended to be used to update the segment table in the\nmetadata storage after manually migrating segments from one place to another, or even to recover lost metadata storage\nby telling it where the segments are stored."]}),"\n",(0,o.jsxs)(t.p,{children:["In Druid 0.14.x and earlier, Druid wrote segment metadata to two places: the metadata store's ",(0,o.jsx)(t.code,{children:"druid_segments"})," table, and\n",(0,o.jsx)(t.code,{children:"descriptor.json"})," files in deep storage. This practice was stopped in Druid 0.15.0 as part of\n",(0,o.jsx)(t.a,{href:"https://github.com/apache/druid/issues/6849",children:"consolidated metadata management"}),", for the following reasons:"]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"If any segments are manually dropped or re-enabled by cluster operators, this information is not reflected in\ndeep storage. Restoring metadata from deep storage would undo any such drops or re-enables."}),"\n",(0,o.jsxs)(t.li,{children:["Ingestion methods that allocate segments optimistically (such as native Kafka or Kinesis stream ingestion, or native\nbatch ingestion in 'append' mode) can write segments to deep storage that are not meant to actually be used by the\nDruid cluster. There is no way, while purely looking at deep storage, to differentiate the segments that made it into\nthe metadata store originally (and therefore ",(0,o.jsx)(t.em,{children:"should"})," be used) from the segments that did not (and therefore\n",(0,o.jsx)(t.em,{children:"should not"})," be used)."]}),"\n",(0,o.jsxs)(t.li,{children:["Nothing in Druid other than the ",(0,o.jsx)(t.code,{children:"insert-segment-to-db"})," tool read the ",(0,o.jsx)(t.code,{children:"descriptor.json"})," files."]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["After this change, Druid stopped writing ",(0,o.jsx)(t.code,{children:"descriptor.json"})," files to deep storage, and now only writes segment metadata\nto the metadata store. This meant the ",(0,o.jsx)(t.code,{children:"insert-segment-to-db"})," tool is no longer useful, so it was removed in Druid 0.15.0."]}),"\n",(0,o.jsx)(t.p,{children:"It is highly recommended that you take regular backups of your metadata store, since it is difficult to recover Druid\nclusters properly without it."})]})}function m(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}}}]);