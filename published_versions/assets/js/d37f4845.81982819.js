"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7790],{28453:(e,n,i)=>{i.d(n,{R:()=>d,x:()=>s});var o=i(96540);const r={},t=o.createContext(r);function d(e){const n=o.useContext(t);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),o.createElement(t.Provider,{value:n},e.children)}},66284:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>d,metadata:()=>o,toc:()=>a});const o=JSON.parse('{"id":"release-info/migr-front-coded-dict","title":"Migration guide: front-coded dictionaries","description":"\x3c!--","source":"@site/docs/33.0.0/release-info/migr-front-coded-dict.md","sourceDirName":"release-info","slug":"/release-info/migr-front-coded-dict","permalink":"/docs/33.0.0/release-info/migr-front-coded-dict","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"migr-front-coded-dict","title":"Migration guide: front-coded dictionaries","sidebar_label":"Front-coded dictionaries"},"sidebar":"docs","previous":{"title":"MVDs to arrays","permalink":"/docs/33.0.0/release-info/migr-mvd-array"},"next":{"title":"Subquery limit","permalink":"/docs/33.0.0/release-info/migr-subquery-limit"}}');var r=i(74848),t=i(28453);const d={id:"migr-front-coded-dict",title:"Migration guide: front-coded dictionaries",sidebar_label:"Front-coded dictionaries"},s=void 0,c={},a=[{value:"Enable front coding",id:"enable-front-coding",level:2},{value:"Upgrade from Druid 25.0.0",id:"upgrade-from-druid-2500",level:2},{value:"Downgrade to Druid 25.0.0",id:"downgrade-to-druid-2500",level:2},{value:"Downgrade to a version preceding Druid 25.0.0",id:"downgrade-to-a-version-preceding-druid-2500",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["Front coding is an ",(0,r.jsx)(n.a,{href:"/docs/33.0.0/development/experimental",children:"experimental feature"})," introduced in Druid 25.0.0."]})}),"\n",(0,r.jsxs)(n.p,{children:["Apache Druid encodes string columns into dictionaries for better compression.\nFront coding is an incremental encoding strategy that lets you store STRING and ",(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/nested-columns",children:"COMPLEX<json>"})," columns in Druid with minimal performance impact.\nFront-coded dictionaries reduce storage and improve performance by optimizing for strings where the front part looks similar.\nFor example, if you are tracking website visits, most URLs start with ",(0,r.jsx)(n.code,{children:"https://domain.xyz/"}),", and front coding is able to exploit this pattern for more optimal compression when storing such datasets.\nDruid performs the optimization automatically, which means that the performance of string columns is generally not affected when they don't match the front-coded pattern.\nConsequently, you can enable this feature universally without having to know the underlying data shapes of the columns."]}),"\n",(0,r.jsx)(n.p,{children:"You can use front coding with all types of ingestion."}),"\n",(0,r.jsx)(n.h2,{id:"enable-front-coding",children:"Enable front coding"}),"\n",(0,r.jsxs)(n.p,{children:["To enable front coding, set ",(0,r.jsx)(n.code,{children:"indexSpec.stringDictionaryEncoding.type"})," to ",(0,r.jsx)(n.code,{children:"frontCoded"})," in the ",(0,r.jsx)(n.code,{children:"tuningConfig"})," object of your ",(0,r.jsx)(n.a,{href:"/docs/33.0.0/ingestion/ingestion-spec",children:"ingestion spec"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"You can specify the following optional properties:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"bucketSize"}),": Number of values to place in a bucket to perform delta encoding. Setting this property instructs indexing tasks to write segments using compressed dictionaries of the specified bucket size. You can set it to any power of 2 less than or equal to 128. ",(0,r.jsx)(n.code,{children:"bucketSize"})," defaults to 4."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"formatVersion"}),": Specifies which front coding version to use. Options are 0 and 1 (supported for Druid versions 26.0.0 and higher). ",(0,r.jsx)(n.code,{children:"formatVersion"})," defaults to 0."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"For example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'"tuningConfig": {\n  "indexSpec": {\n    "stringDictionaryEncoding": {\n      "type":"frontCoded",\n      "bucketSize": 4,\n      "formatVersion": 0\n    }\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["For SQL based ingestion, you can add the ",(0,r.jsx)(n.code,{children:"indexSpec"})," to your query context.\nIn the Web Console, select ",(0,r.jsx)(n.em,{children:"Edit context"})," from the context from the ",(0,r.jsx)(n.em,{children:"Engine:"})," menu and enter the ",(0,r.jsx)(n.code,{children:"indexSpec"}),". For example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n...\n"indexSpec": {\n  "stringDictionaryEncoding": {\n  "type": "frontCoded",\n  "bucketSize": 4,\n  "formatVersion": 1\n  }\n}\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["For API calls to the SQL-based ingestion API, include the ",(0,r.jsx)(n.code,{children:"indexSpec"})," in the context in the request payload. For example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n"query": ...\n"context": {\n  "maxNumTasks": 3\n  "indexSpec": {\n  "stringDictionaryEncoding": {\n    "type": "frontCoded",\n    "bucketSize": 4,\n    "formatVersion": 1}\n    }\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"upgrade-from-druid-2500",children:"Upgrade from Druid 25.0.0"}),"\n",(0,r.jsx)(n.p,{children:"Druid 26.0.0 introduced a new version of the front-coded dictionary, version 1, offering typically faster read speeds and smaller storage sizes.\nWhen upgrading to versions Druid 26.0.0 and higher, Druid continues to default front coding settings to version 0.\nThis default enables seamless downgrades to Druid 25.0.0."}),"\n",(0,r.jsxs)(n.p,{children:["To use the newer version, set the ",(0,r.jsx)(n.code,{children:"formatVersion"})," property to 1:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'"tuningConfig": {\n  "indexSpec": {\n    "stringDictionaryEncoding": {\n      "type":"frontCoded",\n      "bucketSize": 4,\n      "formatVersion": 1\n    }\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"downgrade-to-druid-2500",children:"Downgrade to Druid 25.0.0"}),"\n",(0,r.jsxs)(n.p,{children:["After upgrading to version 1, you can no longer downgrade to Druid 25.0.0 seamlessly.\nTo downgrade to Druid 25.0.0, re-ingest your data with the ",(0,r.jsx)(n.code,{children:"stringDictionaryEncoding.formatVersion"})," property set to 0."]}),"\n",(0,r.jsx)(n.h2,{id:"downgrade-to-a-version-preceding-druid-2500",children:"Downgrade to a version preceding Druid 25.0.0"}),"\n",(0,r.jsxs)(n.p,{children:["Druid versions preceding 25.0.0 can't read segments with front-coded dictionaries. To downgrade to an older version, you must either delete the segments containing front-coded dictionaries or re-ingest them with ",(0,r.jsx)(n.code,{children:"stringDictionaryEncoding.type"})," set to ",(0,r.jsx)(n.code,{children:"utf8"}),"."]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}}}]);