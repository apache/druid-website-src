"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4485],{3669:(e,r,i)=>{i.r(r),i.d(r,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>s,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"operations/mixed-workloads","title":"Configure Druid for mixed workloads","description":"\x3c!--","source":"@site/docs/32.0.0/operations/mixed-workloads.md","sourceDirName":"operations","slug":"/operations/mixed-workloads","permalink":"/docs/32.0.0/operations/mixed-workloads","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"mixed-workloads","title":"Configure Druid for mixed workloads","sidebar_label":"Mixed workloads"},"sidebar":"docs","previous":{"title":"Segment size optimization","permalink":"/docs/32.0.0/operations/segment-optimization"},"next":{"title":"HTTP compression","permalink":"/docs/32.0.0/operations/http-compression"}}');var t=i(74848),o=i(28453);const s={id:"mixed-workloads",title:"Configure Druid for mixed workloads",sidebar_label:"Mixed workloads"},a=void 0,l={},d=[{value:"Query laning",id:"query-laning",level:2},{value:"General properties",id:"general-properties",level:3},{value:"Lane-specific properties",id:"lane-specific-properties",level:3},{value:"Example",id:"example",level:3},{value:"Service tiering",id:"service-tiering",level:2},{value:"Historical tiering",id:"historical-tiering",level:3},{value:"Configure segment loading",id:"configure-segment-loading",level:4},{value:"Assign Historicals to tiers",id:"assign-historicals-to-tiers",level:4},{value:"Broker tiering",id:"broker-tiering",level:3},{value:"Assign Brokers to tiers",id:"assign-brokers-to-tiers",level:4},{value:"Configure query routing",id:"configure-query-routing",level:4},{value:"Learn more",id:"learn-more",level:2}];function u(e){const r={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.p,{children:"If you frequently run concurrent, heterogeneous workloads on your Apache Druid cluster, configure Druid to properly allocate cluster resources to optimize your overall query performance."}),"\n",(0,t.jsx)(r.p,{children:'Each Druid query consumes a certain amount of cluster resources, such as processing threads, memory buffers for intermediate query results, and HTTP threads for communicating between Brokers and data servers.\n"Heavy" queries that return large results are more resource-intensive than short-running, "light" queries.\nYou typically do not want these long resource-intensive queries to throttle the performance of short interactive queries.\nFor example, if you run both sets of queries in the same Druid cluster, heavy queries may employ all available HTTP threads.\nThis situation slows down subsequent queries\u2014heavy and light\u2014and may trigger timeout errors for those queries.\nWith proper resource isolation, you can execute long-running, low priority queries without interfering with short-running, high priority queries.'}),"\n",(0,t.jsx)(r.p,{children:"Druid provides the following strategies to isolate resources and improve query concurrency:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Query laning"})," where you set a limit on the maximum number of long-running queries executed on each Broker."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Service tiering"})," which defines separate groups of Historicals and Brokers to receive different query assignments based on query priority."]}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"You can profile Druid queries using normal performance profiling techniques such as Druid query metrics analysis, thread dumps of JVM, or flame graphs to identify what resources are affected by mixed workloads.\nThe largest bottleneck will likely be in the Broker HTTP threads.\nMitigate resource contention of the Broker HTTP threads with query laning.\nHowever, mixed workloads also affect other resources, including processing threads and merge buffers.\nTo reduce the burden on these resources, apply both service tiering and query laning."}),"\n",(0,t.jsx)(r.h2,{id:"query-laning",children:"Query laning"}),"\n",(0,t.jsx)(r.p,{children:"When you need to run many concurrent queries having heterogeneous workloads, start with query laning to optimize your query performance.\nQuery laning restricts resource usage for less urgent queries to ensure dedicated resources for high priority queries."}),"\n",(0,t.jsx)(r.p,{children:"Query lanes are analogous to carpool and normal lanes on the freeway. With query laning, Druid sets apart prioritized lanes from other general lanes.\nDruid restricts low priority queries to the general lanes and allows high priority queries to run wherever possible, whether in a VIP or general lane."}),"\n",(0,t.jsxs)(r.p,{children:["In Druid, query lanes reserve resources for Broker HTTP threads. Each Druid query requires one Broker thread. The number of threads on a Broker is defined by the ",(0,t.jsx)(r.code,{children:"druid.server.http.numThreads"})," parameter. Broker threads may be occupied by tasks other than queries, such as health checks. You can use query laning to limit the number of HTTP threads designated for resource-intensive queries, leaving other threads available for short-running queries and other tasks."]}),"\n",(0,t.jsx)(r.h3,{id:"general-properties",children:"General properties"}),"\n",(0,t.jsxs)(r.p,{children:["Set the following query laning properties in the ",(0,t.jsx)(r.code,{children:"broker/runtime.properties"})," file."]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"druid.query.scheduler.laning.strategy"})," \u2013 The strategy used to assign queries to lanes.\nYou can use the built-in ",(0,t.jsx)(r.a,{href:"/docs/32.0.0/configuration/#highlow-laning-strategy",children:"\u201chigh/low\u201d laning strategy"}),", or ",(0,t.jsx)(r.a,{href:"/docs/32.0.0/configuration/#manual-laning-strategy",children:"define your own laning strategy manually"}),"."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"druid.query.scheduler.numThreads"})," \u2013 The total number of queries that can be served per Broker. We recommend setting this value to 1-2 less than ",(0,t.jsx)(r.code,{children:"druid.server.http.numThreads"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:["The query scheduler by default does not limit the number of queries that a Broker can serve. Setting this property to a bounded number limits the thread count. If the allocated threads are all occupied, any incoming query, including interactive queries, will be queued on the broker and will timeout after the request stays in the queue for more than the configured timeout. This configured timeout is equal to ",(0,t.jsx)(r.code,{children:"MIN(Integer.MAX_VALUE, druid.server.http.maxQueryTimeout)"}),". If the value of ",(0,t.jsx)(r.code,{children:"druid.server.http.maxQueryTimeout"})," is negative, the request is queued forever."]}),"\n",(0,t.jsx)(r.h3,{id:"lane-specific-properties",children:"Lane-specific properties"}),"\n",(0,t.jsxs)(r.p,{children:["If you use the ",(0,t.jsx)(r.strong,{children:"high/low laning strategy"}),", set the following:"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"druid.query.scheduler.laning.maxLowPercent"})," \u2013 The maximum percent of query threads to handle low priority queries. The remaining query threads are dedicated to high priority queries."]}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:["Consider also defining a ",(0,t.jsx)(r.a,{href:"/docs/32.0.0/configuration/#prioritization-strategies",children:"prioritization strategy"})," for the Broker to label queries as high or low priority. Otherwise, manually set the priority for incoming queries on the ",(0,t.jsx)(r.a,{href:"/docs/32.0.0/querying/query-context",children:"query context"}),"."]}),"\n",(0,t.jsxs)(r.p,{children:["If you use a ",(0,t.jsx)(r.strong,{children:"manual laning strategy"}),", set the following:"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"druid.query.scheduler.laning.lanes.{name}"})," \u2013 The limit for how many queries can run in the ",(0,t.jsx)(r.code,{children:"name"})," lane. Define as many named lanes as needed."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"druid.query.scheduler.laning.isLimitPercent"})," \u2013 Whether to treat the lane limit as an exact number or a percent of the minimum of ",(0,t.jsx)(r.code,{children:"druid.server.http.numThreads"})," or ",(0,t.jsx)(r.code,{children:"druid.query.scheduler.numThreads"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:["With manual laning, incoming queries can be labeled with the desired lane in the ",(0,t.jsx)(r.code,{children:"lane"})," parameter of the ",(0,t.jsx)(r.a,{href:"/docs/32.0.0/querying/query-context",children:"query context"}),"."]}),"\n",(0,t.jsxs)(r.p,{children:["See ",(0,t.jsx)(r.a,{href:"/docs/32.0.0/configuration/#query-prioritization-and-laning",children:"Query prioritization and laning"})," for additional details on query laning configuration."]}),"\n",(0,t.jsx)(r.h3,{id:"example",children:"Example"}),"\n",(0,t.jsx)(r.p,{children:"Example config for query laning with the high/low laning strategy:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"# Laning strategy\ndruid.query.scheduler.laning.strategy=hilo\ndruid.query.scheduler.laning.maxLowPercent=20\n\n# Limit the number of HTTP threads for query processing\n# This value should be less than druid.server.http.numThreads\ndruid.query.scheduler.numThreads=40\n"})}),"\n",(0,t.jsx)(r.h2,{id:"service-tiering",children:"Service tiering"}),"\n",(0,t.jsx)(r.p,{children:"In service tiering, you define separate groups of Historicals and Brokers to manage queries based on the segments and resource requirements of the query.\nYou can limit the resources that are set aside for certain types of queries.\nMany heavy queries involving complex subqueries or large result sets can hog resources away from high priority, interactive queries.\nMinimize the impact of these heavy queries by limiting them to a separate Broker tier.\nWhen all Brokers set aside for heavy queries are occupied, subsequent heavy queries must wait until the designated resources become available.\nA prolonged wait results in the later queries failing with a timeout error."}),"\n",(0,t.jsx)(r.p,{children:"Note that you can separate Historical processes into tiers without having separate Broker tiers.\nHistorical-only tiering is not sufficient to meet the demands of mixed workloads on a Druid cluster.\nHowever, it is useful when you query certain segments more frequently than others, such as often analyzing the most recent data.\nHistorical tiering assigns data from specific time intervals to specific tiers in order to support higher concurrency on hot data."}),"\n",(0,t.jsx)(r.p,{children:"The examples below demonstrate two tiers\u2014hot and cold\u2014for both the Historicals and Brokers. The Brokers will serve short-running, light queries before long-running, heavy queries. Light queries will be routed to the hot tiers, and heavy queries will be routed to the cold tiers."}),"\n",(0,t.jsx)(r.h3,{id:"historical-tiering",children:"Historical tiering"}),"\n",(0,t.jsx)(r.p,{children:"This section describes how to configure segment loading and how to assign Historical services into tiers."}),"\n",(0,t.jsx)(r.h4,{id:"configure-segment-loading",children:"Configure segment loading"}),"\n",(0,t.jsxs)(r.p,{children:["The Coordinator service assigns segments to different tiers of Historicals using load rules.\nDefine a ",(0,t.jsx)(r.a,{href:"/docs/32.0.0/operations/rule-configuration#load-rules",children:"load rule"})," to indicate how segment replicas should be assigned to different Historical tiers. For example, you may store segments of more recent data on more powerful hardware for better performance."]}),"\n",(0,t.jsxs)(r.p,{children:["There are several types of load rules: forever, interval, and period. Select the load rule that matches your use case for each Historical, whether you want all segments to be loaded, segments within a certain time interval, or segments within a certain time period.\nInterval and period load rules must be accompanied by corresponding ",(0,t.jsx)(r.a,{href:"/docs/32.0.0/operations/rule-configuration#drop-rules",children:"drop rules"}),"."]}),"\n",(0,t.jsxs)(r.p,{children:["In the load rule, define tiers in the ",(0,t.jsx)(r.code,{children:"tieredReplicants"})," property. Provide descriptive names for your tiers, and specify how many replicas each tier should have. You can designate a higher number of replicas for the hot tier to increase the concurrency for processing queries."]}),"\n",(0,t.jsx)(r.p,{children:"The following example shows a period load rule with two Historical tiers, named \u201chot\u201d and \u201c_default_tier\u201d.\nFor the most recent month of data, Druid loads three replicas in the hot tier and one replica in the default cold tier.\nIncoming queries that rely on this month of data can use the single replica in the cold Historical tier or any of the three replicas in the hot Historical tier."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:'{\n  "type" : "loadByPeriod",\n  "period" : "P1M",\n  "includeFuture" : true,\n  "tieredReplicants": {\n    "hot": 3,\n    "_default_tier" : 1\n  }\n}\n'})}),"\n",(0,t.jsxs)(r.p,{children:["See ",(0,t.jsx)(r.a,{href:"/docs/32.0.0/operations/rule-configuration#load-rules",children:"Load rules"})," for more information on segment load rules. Visit ",(0,t.jsx)(r.a,{href:"/docs/32.0.0/tutorials/tutorial-retention",children:"Tutorial: Configuring data retention"})," for an example of setting retention rules from the Druid web console."]}),"\n",(0,t.jsx)(r.h4,{id:"assign-historicals-to-tiers",children:"Assign Historicals to tiers"}),"\n",(0,t.jsxs)(r.p,{children:["To assign a Historical to a tier, add a label for the tier name and set the priority value in the  ",(0,t.jsx)(r.code,{children:"historical/runtime.properties"})," for the Historical."]}),"\n",(0,t.jsx)(r.p,{children:"Example Historical in the hot tier:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"druid.server.tier=hot\ndruid.server.priority=1\n"})}),"\n",(0,t.jsx)(r.p,{children:"Example Historical in the cold tier:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"druid.server.tier=_default_tier\ndruid.server.priority=0\n"})}),"\n",(0,t.jsxs)(r.p,{children:["See ",(0,t.jsx)(r.a,{href:"/docs/32.0.0/configuration/#historical-general-configuration",children:"Historical general configuration"})," for more details on these properties."]}),"\n",(0,t.jsx)(r.h3,{id:"broker-tiering",children:"Broker tiering"}),"\n",(0,t.jsx)(r.p,{children:"You must set up Historical tiering before you can use Broker tiering.\nTo set up Broker tiering, assign Brokers to tiers, and configure query routing by the Router."}),"\n",(0,t.jsx)(r.h4,{id:"assign-brokers-to-tiers",children:"Assign Brokers to tiers"}),"\n",(0,t.jsxs)(r.p,{children:["For each of the Brokers, define the Broker group in the ",(0,t.jsx)(r.code,{children:"broker/runtime.properties"})," files."]}),"\n",(0,t.jsx)(r.p,{children:"Example config for a Broker in the hot tier:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"druid.service=druid:broker-hot\n"})}),"\n",(0,t.jsx)(r.p,{children:"Example config for a Broker in the cold tier:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"druid.service=druid:broker-cold\n"})}),"\n",(0,t.jsxs)(r.p,{children:["Also in the ",(0,t.jsx)(r.code,{children:"broker/runtime.properties"})," files, instruct the Broker to select Historicals by priority so that the Broker will select Historicals in the hot tier before Historicals in the cold tier."]}),"\n",(0,t.jsx)(r.p,{children:"Example Broker config to prioritize hot tier Historicals:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"druid.broker.select.tier=highestPriority\n"})}),"\n",(0,t.jsxs)(r.p,{children:["See ",(0,t.jsx)(r.a,{href:"/docs/32.0.0/configuration/#broker-process-configs",children:"Broker configuration"})," for more details on these properties."]}),"\n",(0,t.jsx)(r.h4,{id:"configure-query-routing",children:"Configure query routing"}),"\n",(0,t.jsxs)(r.p,{children:["Direct the Router to route queries appropriately by setting the default Broker tier and the map of Historical tier to Broker tier in the ",(0,t.jsx)(r.code,{children:"router/runtime.properties"})," file."]}),"\n",(0,t.jsx)(r.p,{children:"Example Router config to map hot/cold tier Brokers to hot/cold tier Historicals, respectively:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:'druid.router.defaultBrokerServiceName=druid:broker-cold\ndruid.router.tierToBrokerMap={"hot":"druid:broker-hot","_default_tier":"druid:broker-cold"}\n'})}),"\n",(0,t.jsxs)(r.p,{children:["If you plan to run Druid SQL queries, also ",(0,t.jsx)(r.a,{href:"/docs/32.0.0/design/router#routing-of-sql-queries-using-strategies",children:"enable routing of SQL queries"})," by setting the following:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"druid.router.sql.enable=true\n"})}),"\n",(0,t.jsxs)(r.p,{children:["See ",(0,t.jsx)(r.a,{href:"/docs/32.0.0/design/router#example-production-configuration",children:"Router process"})," for an example production configuration."]}),"\n",(0,t.jsx)(r.h2,{id:"learn-more",children:"Learn more"}),"\n",(0,t.jsxs)(r.p,{children:["See ",(0,t.jsx)(r.a,{href:"/docs/32.0.0/querying/multitenancy",children:"Multitenancy considerations"})," for applying query concurrency to multitenant workloads."]})]})}function c(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},28453:(e,r,i)=>{i.d(r,{R:()=>s,x:()=>a});var n=i(96540);const t={},o=n.createContext(t);function s(e){const r=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),n.createElement(o.Provider,{value:r},e.children)}}}]);