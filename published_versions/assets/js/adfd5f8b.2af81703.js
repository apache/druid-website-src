"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6385],{28453:(e,s,n)=>{n.d(s,{R:()=>a,x:()=>d});var i=n(96540);const t={},r=i.createContext(t);function a(e){const s=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function d(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(r.Provider,{value:s},e.children)}},60108:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"querying/sql-data-types","title":"SQL data types","description":"\x3c!--","source":"@site/docs/33.0.0/querying/sql-data-types.md","sourceDirName":"querying","slug":"/querying/sql-data-types","permalink":"/docs/33.0.0/querying/sql-data-types","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"sql-data-types","title":"SQL data types","sidebar_label":"SQL data types"},"sidebar":"docs","previous":{"title":"Query from deep storage","permalink":"/docs/33.0.0/querying/query-deep-storage"},"next":{"title":"Operators","permalink":"/docs/33.0.0/querying/sql-operators"}}');var t=n(74848),r=n(28453);const a={id:"sql-data-types",title:"SQL data types",sidebar_label:"SQL data types"},d=void 0,l={},o=[{value:"Standard types",id:"standard-types",level:2},{value:"Arrays",id:"arrays",level:2},{value:"Multi-value strings",id:"multi-value-strings",level:2},{value:"Multi-value strings behavior",id:"multi-value-strings-behavior",level:2},{value:"NULL values",id:"null-values",level:2},{value:"Boolean logic",id:"boolean-logic",level:2},{value:"Nested columns",id:"nested-columns",level:2}];function c(e){const s={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.admonition,{type:"info",children:(0,t.jsxs)(s.p,{children:["Apache Druid supports two query languages: Druid SQL and ",(0,t.jsx)(s.a,{href:"/docs/33.0.0/querying/",children:"native queries"}),".\nThis document describes the SQL language."]})}),"\n",(0,t.jsxs)(s.p,{children:["Druid associates each column with a specific data type. This topic describes supported data types in ",(0,t.jsx)(s.a,{href:"/docs/33.0.0/querying/sql",children:"Druid SQL"}),"."]}),"\n",(0,t.jsx)(s.h2,{id:"standard-types",children:"Standard types"}),"\n",(0,t.jsx)(s.p,{children:"Druid natively supports the following basic column types:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"LONG: 64-bit signed int"}),"\n",(0,t.jsx)(s.li,{children:"FLOAT: 32-bit float"}),"\n",(0,t.jsx)(s.li,{children:"DOUBLE: 64-bit float"}),"\n",(0,t.jsx)(s.li,{children:"STRING: UTF-8 encoded strings and string arrays"}),"\n",(0,t.jsx)(s.li,{children:"COMPLEX: non-standard data types, such as nested JSON, hyperUnique and approxHistogram, and DataSketches"}),"\n",(0,t.jsx)(s.li,{children:"ARRAY: arrays composed of any of these types"}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["Druid treats timestamps (including the ",(0,t.jsx)(s.code,{children:"__time"})," column) as LONG, with the value being the number of\nmilliseconds since 1970-01-01 00:00:00 UTC, not counting leap seconds. Therefore, timestamps in Druid do not carry any\ntimezone information. They only carry information about the exact moment in time they represent. See\n",(0,t.jsx)(s.a,{href:"/docs/33.0.0/querying/sql-scalar#date-and-time-functions",children:"Time functions"})," for more information about timestamp handling."]}),"\n",(0,t.jsx)(s.p,{children:"The following table describes how Druid maps SQL types onto native types when running queries:"}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"SQL type"}),(0,t.jsx)(s.th,{children:"Druid runtime type"}),(0,t.jsxs)(s.th,{children:["Default value",(0,t.jsx)("sup",{children:"*"})]}),(0,t.jsx)(s.th,{children:"Notes"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"CHAR"}),(0,t.jsx)(s.td,{children:"STRING"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"''"})}),(0,t.jsx)(s.td,{})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"VARCHAR"}),(0,t.jsx)(s.td,{children:"STRING"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"''"})}),(0,t.jsxs)(s.td,{children:["Druid STRING columns are reported as VARCHAR. Can include ",(0,t.jsx)(s.a,{href:"#multi-value-strings",children:"multi-value strings"})," as well."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"DECIMAL"}),(0,t.jsx)(s.td,{children:"DOUBLE"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"0.0"})}),(0,t.jsx)(s.td,{children:"DECIMAL uses floating point, not fixed point math"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"FLOAT"}),(0,t.jsx)(s.td,{children:"FLOAT"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"0.0"})}),(0,t.jsx)(s.td,{children:"Druid FLOAT columns are reported as FLOAT"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"REAL"}),(0,t.jsx)(s.td,{children:"DOUBLE"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"0.0"})}),(0,t.jsx)(s.td,{})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"DOUBLE"}),(0,t.jsx)(s.td,{children:"DOUBLE"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"0.0"})}),(0,t.jsx)(s.td,{children:"Druid DOUBLE columns are reported as DOUBLE"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"BOOLEAN"}),(0,t.jsx)(s.td,{children:"LONG"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"false"})}),(0,t.jsx)(s.td,{})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"TINYINT"}),(0,t.jsx)(s.td,{children:"LONG"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"0"})}),(0,t.jsx)(s.td,{})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"SMALLINT"}),(0,t.jsx)(s.td,{children:"LONG"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"0"})}),(0,t.jsx)(s.td,{})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"INTEGER"}),(0,t.jsx)(s.td,{children:"LONG"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"0"})}),(0,t.jsx)(s.td,{})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"BIGINT"}),(0,t.jsx)(s.td,{children:"LONG"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"0"})}),(0,t.jsxs)(s.td,{children:["Druid LONG columns (except ",(0,t.jsx)(s.code,{children:"__time"}),") are reported as BIGINT"]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"TIMESTAMP"}),(0,t.jsx)(s.td,{children:"LONG"}),(0,t.jsxs)(s.td,{children:[(0,t.jsx)(s.code,{children:"0"}),", meaning 1970-01-01 00:00:00 UTC"]}),(0,t.jsxs)(s.td,{children:["Druid's ",(0,t.jsx)(s.code,{children:"__time"})," column is reported as TIMESTAMP. Casts between string and timestamp types assume standard SQL formatting, such as ",(0,t.jsx)(s.code,{children:"2000-01-02 03:04:05"}),", not ISO 8601 formatting. For handling other formats, use one of the ",(0,t.jsx)(s.a,{href:"/docs/33.0.0/querying/sql-scalar#date-and-time-functions",children:"time functions"}),"."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"DATE"}),(0,t.jsx)(s.td,{children:"LONG"}),(0,t.jsxs)(s.td,{children:[(0,t.jsx)(s.code,{children:"0"}),", meaning 1970-01-01"]}),(0,t.jsxs)(s.td,{children:["Casting TIMESTAMP to DATE rounds down the timestamp to the nearest day. Casts between string and date types assume standard SQL formatting\u2014for example, ",(0,t.jsx)(s.code,{children:"2000-01-02"}),". For handling other formats, use one of the ",(0,t.jsx)(s.a,{href:"/docs/33.0.0/querying/sql-scalar#date-and-time-functions",children:"time functions"}),"."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"ARRAY"}),(0,t.jsx)(s.td,{children:"ARRAY"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"NULL"})}),(0,t.jsxs)(s.td,{children:["Druid native array types work as SQL arrays, and multi-value strings can be converted to arrays. See ",(0,t.jsx)(s.a,{href:"#arrays",children:"Arrays"})," for more information."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"OTHER"}),(0,t.jsx)(s.td,{children:"COMPLEX"}),(0,t.jsx)(s.td,{children:"none"}),(0,t.jsx)(s.td,{children:"May represent various Druid column types such as hyperUnique, approxHistogram, etc."})]})]})]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)("sup",{children:"*"}),"\nThe default value is ",(0,t.jsx)("code",{children:"NULL"})," for all types."]}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(s.p,{children:"For casts between two SQL types, the behavior depends on the runtime type:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.p,{children:"Casts between two SQL types with the same Druid runtime type have no effect other than the exceptions noted in the table."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.p,{children:"Casts between two SQL types that have different Druid runtime types generate a runtime cast in Druid."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["If a value cannot be cast to the target type, as in ",(0,t.jsx)(s.code,{children:"CAST('foo' AS BIGINT)"}),", Druid a substitutes ",(0,t.jsx)(s.a,{href:"#null-values",children:"NULL"}),"."]}),"\n",(0,t.jsx)(s.h2,{id:"arrays",children:"Arrays"}),"\n",(0,t.jsxs)(s.p,{children:["Druid supports ",(0,t.jsxs)(s.a,{href:"/docs/33.0.0/querying/arrays",children:[(0,t.jsx)(s.code,{children:"ARRAY"})," types"]}),", which behave as standard SQL arrays, where results are grouped by matching entire arrays. The ",(0,t.jsxs)(s.a,{href:"/docs/33.0.0/querying/sql#unnest",children:[(0,t.jsx)(s.code,{children:"UNNEST"})," operator"]})," can be used to perform operations on individual array elements, translating each element into a separate row."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"ARRAY"})," typed columns can be stored in segments with JSON-based ingestion using the 'auto' typed dimension schema shared with ",(0,t.jsx)(s.a,{href:"/docs/33.0.0/ingestion/schema-design#schema-auto-discovery-for-dimensions",children:"schema auto-discovery"})," to detect and ingest arrays as ARRAY typed columns. For ",(0,t.jsx)(s.a,{href:"/docs/33.0.0/multi-stage-query/",children:"SQL based ingestion"}),", the query context parameter ",(0,t.jsx)(s.code,{children:"arrayIngestMode"})," must be specified as ",(0,t.jsx)(s.code,{children:'"array"'})," to ingest ARRAY types. In Druid 28, the default mode for this parameter is ",(0,t.jsx)(s.code,{children:'"mvd"'})," for backwards compatibility, which instead can only handle ",(0,t.jsx)(s.code,{children:"ARRAY<STRING>"})," which it stores in ",(0,t.jsx)(s.a,{href:"#multi-value-strings",children:"multi-value string columns"}),"."]}),"\n",(0,t.jsxs)(s.p,{children:["You can convert multi-value dimensions to standard SQL arrays explicitly with ",(0,t.jsx)(s.code,{children:"MV_TO_ARRAY"})," or implicitly using ",(0,t.jsx)(s.a,{href:"/docs/33.0.0/querying/sql-array-functions",children:"array functions"}),". You can also use the array functions to construct arrays from multiple columns."]}),"\n",(0,t.jsxs)(s.p,{children:["Druid serializes ",(0,t.jsx)(s.code,{children:"ARRAY"})," results as a JSON string of the array by default, which can be controlled by the context parameter\n",(0,t.jsx)(s.a,{href:"/docs/33.0.0/querying/sql-query-context",children:(0,t.jsx)(s.code,{children:"sqlStringifyArrays"})}),". When set to ",(0,t.jsx)(s.code,{children:"false"})," and using JSON ",(0,t.jsx)(s.a,{href:"/docs/33.0.0/api-reference/sql-api#responses",children:"result formats"}),", the arrays will instead be returned as regular JSON arrays instead of in stringified form."]}),"\n",(0,t.jsx)(s.h2,{id:"multi-value-strings",children:"Multi-value strings"}),"\n",(0,t.jsxs)(s.p,{children:["Druid's native type system allows strings to have multiple values. These ",(0,t.jsx)(s.a,{href:"/docs/33.0.0/querying/multi-value-dimensions",children:"multi-value string dimensions"})," are reported in SQL as type VARCHAR and can be\nsyntactically used like any other VARCHAR. Regular string functions that refer to multi-value string dimensions are applied to all values for each row individually."]}),"\n",(0,t.jsxs)(s.p,{children:["You can treat multi-value string dimensions as arrays using special\n",(0,t.jsx)(s.a,{href:"/docs/33.0.0/querying/sql-multivalue-string-functions",children:"multi-value string functions"}),", which perform powerful array-aware operations, but retain their VARCHAR type and behavior."]}),"\n",(0,t.jsxs)(s.p,{children:["Grouping by multi-value dimensions observes the native Druid multi-value aggregation behavior, which is similar to an implicit SQL UNNEST. See ",(0,t.jsx)(s.a,{href:"/docs/33.0.0/querying/multi-value-dimensions#grouping",children:"Grouping"})," for more information."]}),"\n",(0,t.jsxs)(s.admonition,{type:"info",children:[(0,t.jsxs)(s.p,{children:["Because the SQL planner treats multi-value dimensions as VARCHAR, there are some inconsistencies between how they are handled in Druid SQL and in native queries. For instance, expressions involving multi-value dimensions may be incorrectly optimized by the Druid SQL planner. For example, ",(0,t.jsx)(s.code,{children:"multi_val_dim = 'a' AND multi_val_dim = 'b'"})," is optimized to\n",(0,t.jsx)(s.code,{children:"false"}),", even though it is possible for a single row to have both ",(0,t.jsx)(s.code,{children:"'a'"})," and ",(0,t.jsx)(s.code,{children:"'b'"})," as values for ",(0,t.jsx)(s.code,{children:"multi_val_dim"}),"."]}),(0,t.jsxs)(s.p,{children:["The SQL behavior of multi-value dimensions may change in a future release to more closely align with their behavior in native queries, but the ",(0,t.jsx)(s.a,{href:"/docs/33.0.0/querying/sql-multivalue-string-functions",children:"multi-value string functions"})," should be able to provide nearly all possible native functionality."]})]}),"\n",(0,t.jsx)(s.h2,{id:"multi-value-strings-behavior",children:"Multi-value strings behavior"}),"\n",(0,t.jsxs)(s.p,{children:["The behavior of Druid ",(0,t.jsx)(s.a,{href:"/docs/33.0.0/querying/multi-value-dimensions",children:"multi-value string dimensions"})," varies depending on the context of\ntheir usage."]}),"\n",(0,t.jsxs)(s.p,{children:["When used with standard VARCHAR functions which expect a single input value per row, such as CONCAT, Druid will map\nthe function across all values in the row. If the row is null or empty, the function receives ",(0,t.jsx)(s.code,{children:"NULL"})," as its input."]}),"\n",(0,t.jsxs)(s.p,{children:["When used with the explicit ",(0,t.jsx)(s.a,{href:"/docs/33.0.0/querying/sql-multivalue-string-functions",children:"multi-value string functions"}),", Druid processes the\nrow values as if they were ARRAY typed. Any operations which produce null and empty rows are distinguished as\nseparate values (unlike implicit mapping behavior). These multi-value string functions, typically denoted with an ",(0,t.jsx)(s.code,{children:"MV_"}),"\nprefix, retain their VARCHAR type after the computation is complete. Note that Druid multi-value columns do ",(0,t.jsx)(s.em,{children:"not"}),"\ndistinguish between empty and null rows. An empty row will never appear natively as input to a multi-valued function,\nbut any multi-value function which manipulates the array form of the value may produce an empty array, which is handled\nseparately while processing."]}),"\n",(0,t.jsx)(s.admonition,{type:"info",children:(0,t.jsx)(s.p,{children:"Do not mix the usage of multi-value functions and normal scalar functions within the same expression, as the planner will be unable\nto determine how to properly process the value given its ambiguous usage. A multi-value string must be treated consistently within\nan expression."})}),"\n",(0,t.jsxs)(s.p,{children:["When converted to ARRAY or used with ",(0,t.jsx)(s.a,{href:"/docs/33.0.0/querying/sql-array-functions",children:"array functions"}),", multi-value strings behave as standard SQL arrays and can no longer\nbe manipulated with non-array functions."]}),"\n",(0,t.jsxs)(s.p,{children:["By default Druid serializes multi-value VARCHAR results as a JSON string of the array, if grouping was not applied on the value.\nIf the value was grouped, due to the implicit UNNEST behavior, all results will always be standard single value\nVARCHAR. ARRAY typed results serialization is controlled with the context parameter ",(0,t.jsx)(s.a,{href:"/docs/33.0.0/querying/sql-query-context",children:(0,t.jsx)(s.code,{children:"sqlStringifyArrays"})}),". When set\nto ",(0,t.jsx)(s.code,{children:"false"})," and using JSON ",(0,t.jsx)(s.a,{href:"/docs/33.0.0/api-reference/sql-api#responses",children:"result formats"}),", the arrays will instead be returned\nas regular JSON arrays instead of in stringified form."]}),"\n",(0,t.jsx)(s.h2,{id:"null-values",children:"NULL values"}),"\n",(0,t.jsx)(s.p,{children:"By default, Druid treats NULL values similarly to the ANSI SQL standard."}),"\n",(0,t.jsxs)(s.p,{children:["For examples of null handling, see the ",(0,t.jsx)(s.a,{href:"/docs/33.0.0/tutorials/tutorial-sql-null",children:"null handling tutorial"}),"."]}),"\n",(0,t.jsx)(s.h2,{id:"boolean-logic",children:"Boolean logic"}),"\n",(0,t.jsxs)(s.p,{children:["Druid uses ",(0,t.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Three-valued_logic#SQL",children:"SQL three-valued logic"})," for filter processing and boolean expression evaluation."]}),"\n",(0,t.jsx)(s.h2,{id:"nested-columns",children:"Nested columns"}),"\n",(0,t.jsxs)(s.p,{children:["Druid supports storing nested data structures in segments using the native ",(0,t.jsx)(s.code,{children:"COMPLEX<json>"})," type. See ",(0,t.jsx)(s.a,{href:"/docs/33.0.0/querying/nested-columns",children:"Nested columns"})," for more information."]}),"\n",(0,t.jsxs)(s.p,{children:["You can interact with nested data using ",(0,t.jsx)(s.a,{href:"/docs/33.0.0/querying/sql-json-functions",children:"JSON functions"}),", which can extract nested values, parse from string, serialize to string, and create new ",(0,t.jsx)(s.code,{children:"COMPLEX<json>"})," structures."]}),"\n",(0,t.jsx)(s.p,{children:"COMPLEX types have limited functionality outside the specialized functions that use them, so their behavior is undefined when:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Grouping on complex values."}),"\n",(0,t.jsx)(s.li,{children:"Filtering directly on complex values."}),"\n",(0,t.jsx)(s.li,{children:"Used as inputs to aggregators without specialized handling for a specific complex type."}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"In many cases, functions are provided to translate COMPLEX value types to STRING, which serves as a workaround solution until COMPLEX type functionality can be improved."})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);