"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7873],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>m});var o=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var u=o.createContext({}),p=function(e){var t=o.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},s=function(e){var t=p(e.components);return o.createElement(u.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},k=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,u=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),d=p(n),k=a,m=d["".concat(u,".").concat(k)]||d[k]||c[k]||r;return n?o.createElement(m,i(i({ref:t},s),{},{components:n})):o.createElement(m,i({ref:t},s))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=k;var l={};for(var u in t)hasOwnProperty.call(t,u)&&(l[u]=t[u]);l.originalType=e,l[d]="string"==typeof e?e:a,i[1]=l;for(var p=2;p<r;p++)i[p]=n[p];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}k.displayName="MDXCreateElement"},51736:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>u,default:()=>m,frontMatter:()=>l,metadata:()=>p,toc:()=>d});var o=n(87462),a=n(63366),r=(n(67294),n(3905)),i=["components"],l={id:"lookups",title:"Lookups"},u=void 0,p={unversionedId:"querying/lookups",id:"querying/lookups",title:"Lookups",description:"\x3c!--",source:"@site/docs/28.0.0/querying/lookups.md",sourceDirName:"querying",slug:"/querying/lookups",permalink:"/docs/28.0.0/querying/lookups",draft:!1,tags:[],version:"current",frontMatter:{id:"lookups",title:"Lookups"},sidebar:"docs",previous:{title:"Joins",permalink:"/docs/28.0.0/querying/joins"},next:{title:"Multi-value dimensions",permalink:"/docs/28.0.0/querying/multi-value-dimensions"}},s={},d=[{value:"Query Syntax",id:"query-syntax",level:2},{value:"Query Execution",id:"query-execution",level:2},{value:"Dynamic Configuration",id:"dynamic-configuration",level:2},{value:"Configuration propagation behavior",id:"configuration-propagation-behavior",level:2},{value:"API",id:"api",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Saving configuration across restarts",id:"saving-configuration-across-restarts",level:2},{value:"Introspect a Lookup",id:"introspect-a-lookup",level:2}],c={toc:d},k="wrapper";function m(e){var t=e.components,n=(0,a.Z)(e,i);return(0,r.kt)(k,(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Lookups are a concept in Apache Druid where dimension values are (optionally) replaced with new values, allowing join-like\nfunctionality. Applying lookups in Druid is similar to joining a dimension table in a data warehouse. See\n",(0,r.kt)("a",{parentName:"p",href:"/docs/28.0.0/querying/dimensionspecs"},"dimension specs"),' for more information. For the purpose of these documents, a "key"\nrefers to a dimension value to match, and a "value" refers to its replacement. So if you wanted to map\n',(0,r.kt)("inlineCode",{parentName:"p"},"appid-12345")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"Super Mega Awesome App")," then the key would be ",(0,r.kt)("inlineCode",{parentName:"p"},"appid-12345")," and the value would be\n",(0,r.kt)("inlineCode",{parentName:"p"},"Super Mega Awesome App"),"."),(0,r.kt)("p",null,"It is worth noting that lookups support not just use cases where keys map one-to-one to unique values, such as country\ncode and country name, but also support use cases where multiple IDs map to the same value, e.g. multiple app-ids\nmapping to a single account manager. When lookups are one-to-one, Druid is able to apply additional optimizations at\nquery time; see ",(0,r.kt)("a",{parentName:"p",href:"#query-execution"},"Query execution")," below for more details."),(0,r.kt)("p",null,"Lookups do not have history. They always use the current data. This means that if the chief account manager for a\nparticular app-id changes, and you issue a query with a lookup to store the app-id to account manager relationship,\nit will return the current account manager for that app-id REGARDLESS of the time range over which you query."),(0,r.kt)("p",null,"If you require data time range sensitive lookups, such a use case is not currently supported dynamically at query time,\nand such data belongs in the raw denormalized data for use in Druid."),(0,r.kt)("p",null,'Lookups are generally preloaded in-memory on all servers. But very small lookups (on the order of a few dozen to a few\nhundred entries) can also be passed inline in native queries time using the "map" lookup type. Refer to the\n',(0,r.kt)("a",{parentName:"p",href:"/docs/28.0.0/querying/dimensionspecs"},"dimension specs")," documentation for details."),(0,r.kt)("p",null,"Other lookup types are available as extensions, including:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Globally cached lookups from local files, remote URIs, or JDBC through ",(0,r.kt)("a",{parentName:"li",href:"/docs/28.0.0/development/extensions-core/lookups-cached-global"},"lookups-cached-global"),"."),(0,r.kt)("li",{parentName:"ul"},"Globally cached lookups from a Kafka topic through ",(0,r.kt)("a",{parentName:"li",href:"/docs/28.0.0/development/extensions-core/kafka-extraction-namespace"},"kafka-extraction-namespace"),".")),(0,r.kt)("h2",{id:"query-syntax"},"Query Syntax"),(0,r.kt)("p",null,"In ",(0,r.kt)("a",{parentName:"p",href:"/docs/28.0.0/querying/sql"},"Druid SQL"),", lookups can be queried using the ",(0,r.kt)("a",{parentName:"p",href:"/docs/28.0.0/querying/sql-scalar#string-functions"},(0,r.kt)("inlineCode",{parentName:"a"},"LOOKUP")," function"),", for example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT\n  LOOKUP(store, 'store_to_country') AS country,\n  SUM(revenue)\nFROM sales\nGROUP BY 1\n")),(0,r.kt)("p",null,"The lookup function also accepts the 3rd argument called ",(0,r.kt)("inlineCode",{parentName:"p"},"replaceMissingValueWith")," as a constant string. If your value is missing a lookup for the queried key, the lookup function returns the result value from ",(0,r.kt)("inlineCode",{parentName:"p"},"replaceMissingValueWith"),"\nFor example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"LOOKUP(store, 'store_to_country', 'NA')\n")),(0,r.kt)("p",null,"If value is missing from ",(0,r.kt)("inlineCode",{parentName:"p"},"store_to_country")," lookup for given key 'store' then it will return ",(0,r.kt)("inlineCode",{parentName:"p"},"NA"),"."),(0,r.kt)("p",null,"They can also be queried using the ",(0,r.kt)("a",{parentName:"p",href:"/docs/28.0.0/querying/datasource#join"},"JOIN operator"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT\n  store_to_country.v AS country,\n  SUM(sales.revenue) AS country_revenue\nFROM\n  sales\n  INNER JOIN lookup.store_to_country ON sales.store = store_to_country.k\nGROUP BY 1\n")),(0,r.kt)("p",null,"In native queries, lookups can be queried with ",(0,r.kt)("a",{parentName:"p",href:"/docs/28.0.0/querying/dimensionspecs"},"dimension specs or extraction functions"),"."),(0,r.kt)("h2",{id:"query-execution"},"Query Execution"),(0,r.kt)("p",null,"When executing an aggregation query involving lookup functions, like the SQL ",(0,r.kt)("a",{parentName:"p",href:"/docs/28.0.0/querying/sql-scalar#string-functions"},(0,r.kt)("inlineCode",{parentName:"a"},"LOOKUP")," function"),',\nDruid can decide to apply them while scanning and aggregating rows, or to apply them after aggregation is complete. It\nis more efficient to apply lookups after aggregation is complete, so Druid will do this if it can. Druid decides this\nby checking if the lookup is marked as "injective" or not. In general, you should set this property for any lookup that\nis naturally one-to-one, to allow Druid to run your queries as fast as possible.'),(0,r.kt)("p",null,"Injective lookups should include ",(0,r.kt)("em",{parentName:"p"},"all")," possible keys that may show up in your dataset, and should also map all keys to\n",(0,r.kt)("em",{parentName:"p"},"unique values"),". This matters because non-injective lookups may map different keys to the same value, which must be\naccounted for during aggregation, lest query results contain two result values that should have been aggregated into\none."),(0,r.kt)("p",null,"This lookup is injective (assuming it contains all possible keys from your data):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"1 -> Foo\n2 -> Bar\n3 -> Billy\n")),(0,r.kt)("p",null,'But this one is not, since both "2" and "3" map to the same value:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"1 -> Foo\n2 -> Bar\n3 -> Bar\n")),(0,r.kt)("p",null,"To tell Druid that your lookup is injective, you must specify ",(0,r.kt)("inlineCode",{parentName:"p"},'"injective" : true')," in the lookup configuration. Druid\nwill not detect this automatically."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"}," Currently, the injective lookup optimization is not triggered when lookups are inputs to a\n",(0,r.kt)("a",{parentName:"p",href:"/docs/28.0.0/querying/datasource#join"},"join datasource"),". It is only used when lookup functions are used directly, without the join\noperator.")),(0,r.kt)("h2",{id:"dynamic-configuration"},"Dynamic Configuration"),(0,r.kt)("p",null,'The following documents the behavior of the cluster-wide config which is accessible through the Coordinator.\nThe configuration is propagated through the concept of "tier" of servers.\nA "tier" is defined as a group of services which should receive a set of lookups.\nFor example, you might have all Historicals be part of ',(0,r.kt)("inlineCode",{parentName:"p"},"__default"),", and Peons be part of individual tiers for the datasources they are tasked with.\nThe tiers for lookups are completely independent of Historical tiers."),(0,r.kt)("p",null,"These configs are accessed using JSON through the following URI template"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"http://<COORDINATOR_IP>:<PORT>/druid/coordinator/v1/lookups/config/{tier}/{id}\n")),(0,r.kt)("p",null,"All URIs below are assumed to have ",(0,r.kt)("inlineCode",{parentName:"p"},"http://<COORDINATOR_IP>:<PORT>")," prepended."),(0,r.kt)("p",null,"If you have NEVER configured lookups before, you MUST post an empty json object ",(0,r.kt)("inlineCode",{parentName:"p"},"{}")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"/druid/coordinator/v1/lookups/config")," to initialize the configuration."),(0,r.kt)("p",null,"These endpoints will return one of the following results:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"404 if the resource is not found"),(0,r.kt)("li",{parentName:"ul"},"400 if there is a problem in the formatting of the request"),(0,r.kt)("li",{parentName:"ul"},"202 if the request was accepted asynchronously (",(0,r.kt)("inlineCode",{parentName:"li"},"POST")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"DELETE"),")"),(0,r.kt)("li",{parentName:"ul"},"200 if the request succeeded (",(0,r.kt)("inlineCode",{parentName:"li"},"GET")," only)")),(0,r.kt)("h2",{id:"configuration-propagation-behavior"},"Configuration propagation behavior"),(0,r.kt)("p",null,"The configuration is propagated to the query serving processes (Broker / Router / Peon / Historical) by the Coordinator.\nThe query serving processes have an internal API for managing lookups on the process and those are used by the Coordinator.\nThe Coordinator periodically checks if any of the processes need to load/drop lookups and updates them appropriately."),(0,r.kt)("p",null,"Please note that only 2 simultaneous lookup configuration propagation requests can be concurrently handled by a single query serving process. This limit is applied to prevent lookup handling from consuming too many server HTTP connections."),(0,r.kt)("h2",{id:"api"},"API"),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"/docs/28.0.0/api-reference/lookups-api"},"Lookups API")," for reference on configuring lookups and lookup status. "),(0,r.kt)("h2",{id:"configuration"},"Configuration"),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"/docs/28.0.0/configuration/#lookups-dynamic-configuration"},"Lookups Dynamic Configuration")," for Coordinator configuration."),(0,r.kt)("p",null,"To configure a Broker / Router / Historical / Peon to announce itself as part of a lookup tier, use following properties."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Property"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"druid.lookup.lookupTier")),(0,r.kt)("td",{parentName:"tr",align:null},"The tier for ",(0,r.kt)("strong",{parentName:"td"},"lookups")," for this process. This is independent of other tiers."),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"__default"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"druid.lookup.lookupTierIsDatasource")),(0,r.kt)("td",{parentName:"tr",align:null},"For some things like indexing service tasks, the datasource is passed in the runtime properties of a task. This option fetches the tierName from the same value as the datasource for the task. It is suggested to only use this as Peon options for the indexing service, if at all. If true, ",(0,r.kt)("inlineCode",{parentName:"td"},"druid.lookup.lookupTier")," MUST NOT be specified"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'"false"'))))),(0,r.kt)("p",null,"To configure the behavior of the dynamic configuration manager, use the following properties on the Coordinator:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Property"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"druid.manager.lookups.hostTimeout")),(0,r.kt)("td",{parentName:"tr",align:null},"Timeout (in ms) PER HOST for processing request"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"2000"),"(2 seconds)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"druid.manager.lookups.allHostTimeout")),(0,r.kt)("td",{parentName:"tr",align:null},"Timeout (in ms) to finish lookup management on all the processes."),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"900000"),"(15 mins)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"druid.manager.lookups.period")),(0,r.kt)("td",{parentName:"tr",align:null},"How long to pause between management cycles"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"120000"),"(2 mins)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"druid.manager.lookups.threadPoolSize")),(0,r.kt)("td",{parentName:"tr",align:null},"Number of service processes that can be managed concurrently"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"10"))))),(0,r.kt)("h2",{id:"saving-configuration-across-restarts"},"Saving configuration across restarts"),(0,r.kt)("p",null,"It is possible to save the configuration across restarts such that a process will not have to wait for Coordinator action to re-populate its lookups. To do this the following property is set:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Property"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"druid.lookup.snapshotWorkingDir")),(0,r.kt)("td",{parentName:"tr",align:null},"Working path used to store snapshot of current lookup configuration, leaving this property null will disable snapshot/bootstrap utility"),(0,r.kt)("td",{parentName:"tr",align:null},"null")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"druid.lookup.enableLookupSyncOnStartup")),(0,r.kt)("td",{parentName:"tr",align:null},"Enable the lookup synchronization process with Coordinator on startup. The queryable processes will fetch and load the lookups from the Coordinator instead of waiting for the Coordinator to load the lookups for them. Users may opt to disable this option if there are no lookups configured in the cluster."),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"druid.lookup.numLookupLoadingThreads")),(0,r.kt)("td",{parentName:"tr",align:null},"Number of threads for loading the lookups in parallel on startup. This thread pool is destroyed once startup is done. It is not kept during the lifetime of the JVM"),(0,r.kt)("td",{parentName:"tr",align:null},"Available Processors / 2")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"druid.lookup.coordinatorFetchRetries")),(0,r.kt)("td",{parentName:"tr",align:null},"How many times to retry to fetch the lookup bean list from Coordinator, during the sync on startup."),(0,r.kt)("td",{parentName:"tr",align:null},"3")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"druid.lookup.lookupStartRetries")),(0,r.kt)("td",{parentName:"tr",align:null},"How many times to retry to start each lookup, either during the sync on startup, or during the runtime."),(0,r.kt)("td",{parentName:"tr",align:null},"3")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"druid.lookup.coordinatorRetryDelay")),(0,r.kt)("td",{parentName:"tr",align:null},"How long to delay (in millis) between retries to fetch lookup list from the Coordinator during the sync on startup."),(0,r.kt)("td",{parentName:"tr",align:null},"60_000")))),(0,r.kt)("h2",{id:"introspect-a-lookup"},"Introspect a Lookup"),(0,r.kt)("p",null,"The Broker provides an API for lookup introspection if the lookup type implements a ",(0,r.kt)("inlineCode",{parentName:"p"},"LookupIntrospectHandler"),"."),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"GET")," request to ",(0,r.kt)("inlineCode",{parentName:"p"},"/druid/v1/lookups/introspect/{lookupId}")," will return the map of complete values."),(0,r.kt)("p",null,"ex: ",(0,r.kt)("inlineCode",{parentName:"p"},"GET /druid/v1/lookups/introspect/nato-phonetic")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'{\n    "A": "Alfa",\n    "B": "Bravo",\n    "C": "Charlie",\n    ...\n    "Y": "Yankee",\n    "Z": "Zulu",\n    "-": "Dash"\n}\n\n')),(0,r.kt)("p",null,"The list of keys can be retrieved via ",(0,r.kt)("inlineCode",{parentName:"p"},"GET")," to ",(0,r.kt)("inlineCode",{parentName:"p"},'/druid/v1/lookups/introspect/{lookupId}/keys"')),(0,r.kt)("p",null,"ex: ",(0,r.kt)("inlineCode",{parentName:"p"},"GET /druid/v1/lookups/introspect/nato-phonetic/keys")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'[\n    "A",\n    "B",\n    "C",\n    ...\n    "Y",\n    "Z",\n    "-"\n]\n')),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"GET")," request to ",(0,r.kt)("inlineCode",{parentName:"p"},'/druid/v1/lookups/introspect/{lookupId}/values"')," will return the list of values."),(0,r.kt)("p",null,"ex: ",(0,r.kt)("inlineCode",{parentName:"p"},"GET /druid/v1/lookups/introspect/nato-phonetic/values")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'[\n    "Alfa",\n    "Bravo",\n    "Charlie",\n    ...\n    "Yankee",\n    "Zulu",\n    "Dash"\n]\n')))}m.isMDXComponent=!0}}]);