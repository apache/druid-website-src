"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8884],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(96540);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}},50998:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>l,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"querying/multitenancy","title":"Multitenancy considerations","description":"\x3c!--","source":"@site/docs/33.0.0/querying/multitenancy.md","sourceDirName":"querying","slug":"/querying/multitenancy","permalink":"/docs/33.0.0/querying/multitenancy","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"multitenancy","title":"Multitenancy considerations","sidebar_label":"Multitenancy"},"sidebar":"docs","previous":{"title":"Nested columns","permalink":"/docs/33.0.0/querying/nested-columns"},"next":{"title":"Query caching","permalink":"/docs/33.0.0/querying/caching"}}');var s=t(74848),i=t(28453);const a={id:"multitenancy",title:"Multitenancy considerations",sidebar_label:"Multitenancy"},o=void 0,c={},d=[{value:"Shared datasources or datasource-per-tenant?",id:"shared-datasources-or-datasource-per-tenant",level:2},{value:"Partitioning shared datasources",id:"partitioning-shared-datasources",level:2},{value:"Customizing data distribution",id:"customizing-data-distribution",level:2},{value:"Supporting high query concurrency",id:"supporting-high-query-concurrency",level:2}];function u(e){const n={a:"a",code:"code",h2:"h2",li:"li",p:"p",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Apache Druid is often used to power user-facing data applications, where multitenancy is an important requirement. This\ndocument outlines Druid's multitenant storage and querying features."}),"\n",(0,s.jsx)(n.h2,{id:"shared-datasources-or-datasource-per-tenant",children:"Shared datasources or datasource-per-tenant?"}),"\n",(0,s.jsx)(n.p,{children:'A datasource is the Druid equivalent of a database table. Multitenant workloads can either use a separate datasource\nfor each tenant, or can share one or more datasources between tenants using a "tenant_id" dimension. When deciding\nwhich path to go down, consider that each path has pros and cons.'}),"\n",(0,s.jsx)(n.p,{children:"Pros of datasources per tenant:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Each datasource can have its own schema, its own backfills, its own partitioning rules, and its own data loading\nand expiration rules."}),"\n",(0,s.jsx)(n.li,{children:"Queries can be faster since there will be fewer segments to examine for a typical tenant's query."}),"\n",(0,s.jsx)(n.li,{children:"You get the most flexibility."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Pros of shared datasources:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Each datasource requires its own JVMs for realtime indexing."}),"\n",(0,s.jsx)(n.li,{children:"Each datasource requires its own YARN resources for Hadoop batch jobs."}),"\n",(0,s.jsx)(n.li,{children:"Each datasource requires its own segment files on disk."}),"\n",(0,s.jsx)(n.li,{children:"For these reasons it can be wasteful to have a very large number of small datasources."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"One compromise is to use more than one datasource, but a smaller number than tenants. For example, you could have some\ntenants with partitioning rules A and some with partitioning rules B; you could use two datasources and split your\ntenants between them."}),"\n",(0,s.jsx)(n.h2,{id:"partitioning-shared-datasources",children:"Partitioning shared datasources"}),"\n",(0,s.jsx)(n.p,{children:'If your multitenant cluster uses shared datasources, most of your queries will likely filter on a "tenant_id"\ndimension. These sorts of queries perform best when data is well-partitioned by tenant. There are a few ways to\naccomplish this.'}),"\n",(0,s.jsxs)(n.p,{children:["With batch indexing, you can use ",(0,s.jsx)(n.a,{href:"/docs/33.0.0/ingestion/hadoop#single-dimension-range-partitioning",children:"single-dimension partitioning"}),"\nto partition your data by tenant_id. Druid always partitions by time first, but the secondary partition within each\ntime bucket will be on tenant_id."]}),"\n",(0,s.jsx)(n.p,{children:"With realtime indexing, you'd do this by tweaking the stream you send to Druid. For example, if you're using Kafka then\nyou can have your Kafka producer partition your topic by a hash of tenant_id."}),"\n",(0,s.jsx)(n.h2,{id:"customizing-data-distribution",children:"Customizing data distribution"}),"\n",(0,s.jsxs)(n.p,{children:["Druid additionally supports multitenancy by providing configurable means of distributing data. Druid's Historical processes\ncan be configured into ",(0,s.jsx)(n.a,{href:"/docs/33.0.0/operations/rule-configuration",children:"tiers"}),", and ",(0,s.jsx)(n.a,{href:"/docs/33.0.0/operations/rule-configuration",children:"rules"}),"\ncan be set that determines which segments go into which tiers. One use case of this is that recent data tends to be accessed\nmore frequently than older data. Tiering enables more recent segments to be hosted on more powerful hardware for better performance.\nA second copy of recent segments can be replicated on cheaper hardware (a different tier), and older segments can also be\nstored on this tier."]}),"\n",(0,s.jsx)(n.h2,{id:"supporting-high-query-concurrency",children:"Supporting high query concurrency"}),"\n",(0,s.jsxs)(n.p,{children:["Druid uses a ",(0,s.jsx)(n.a,{href:"/docs/33.0.0/design/segments",children:"segment"})," as its fundamental unit of computation. Processes scan segments in parallel and a given process can scan ",(0,s.jsx)(n.code,{children:"druid.processing.numThreads"})," concurrently. You can add more cores to a cluster to process more data in parallel and increase performance. Size your Druid segments such that any computation over any given segment should complete in at most 500ms. Use the ",(0,s.jsx)(n.a,{href:"/docs/33.0.0/operations/metrics#historical",children:(0,s.jsx)(n.code,{children:"query/segment/time"})})," metric to monitor computation times."]}),"\n",(0,s.jsx)(n.p,{children:"Druid internally stores requests to scan segments in a priority queue. If a given query requires scanning\nmore segments than the total number of available processors in a cluster, and many similarly expensive queries are concurrently\nrunning, we don't want any query to be starved out. Druid's internal processing logic will scan a set of segments from one query and release resources as soon as the scans complete.\nThis allows for a second set of segments from another query to be scanned. By keeping segment computation time very small, we ensure\nthat resources are constantly being yielded, and segments pertaining to different queries are all being processed."}),"\n",(0,s.jsxs)(n.p,{children:["Druid queries can optionally set a ",(0,s.jsx)(n.code,{children:"priority"})," flag in the ",(0,s.jsx)(n.a,{href:"/docs/33.0.0/querying/query-context",children:"query context"}),". Queries known to be\nslow (download or reporting style queries) can be de-prioritized and more interactive queries can have higher priority."]}),"\n",(0,s.jsxs)(n.p,{children:["Broker processes can also be dedicated to a given tier. For example, one set of Broker processes can be dedicated to fast interactive queries,\nand a second set of Broker processes can be dedicated to slower reporting queries. Druid also provides a ",(0,s.jsx)(n.a,{href:"/docs/33.0.0/design/router",children:"Router"}),"\nprocess that can route queries to different Brokers based on various query parameters (datasource, interval, etc.)."]})]})}function l(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}}}]);