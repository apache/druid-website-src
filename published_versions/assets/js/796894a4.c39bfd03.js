"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8057],{28453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>o});var i=s(96540);const d={},r=i.createContext(d);function t(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:t(e.components),i.createElement(r.Provider,{value:n},e.children)}},49199:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"development/extensions-core/kubernetes","title":"Kubernetes","description":"\x3c!--","source":"@site/docs/33.0.0/development/extensions-core/kubernetes.md","sourceDirName":"development/extensions-core","slug":"/development/extensions-core/kubernetes","permalink":"/docs/33.0.0/development/extensions-core/kubernetes","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"kubernetes","title":"Kubernetes"}}');var d=s(74848),r=s(28453);const t={id:"kubernetes",title:"Kubernetes"},o=void 0,l={},c=[{value:"Configuration",id:"configuration",level:2},{value:"Properties",id:"properties",level:3},{value:"Gotchas",id:"gotchas",level:3}];function a(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(n.p,{children:["Consider this an ",(0,d.jsx)(n.a,{href:"/docs/33.0.0/development/experimental",children:"EXPERIMENTAL"})," feature mostly because it has not been tested yet on a wide variety of long running Druid clusters."]}),"\n",(0,d.jsxs)(n.p,{children:["Apache Druid Extension to enable using Kubernetes API Server for node discovery and leader election. This extension allows Druid cluster deployment on Kubernetes without Zookeeper. It allows running multiple Druid clusters within same Kubernetes Cluster, See ",(0,d.jsx)(n.code,{children:"clusterIdentifier"})," config below."]}),"\n",(0,d.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,d.jsxs)(n.p,{children:["To use this extension please make sure to  ",(0,d.jsx)(n.a,{href:"/docs/33.0.0/configuration/extensions#loading-extensions",children:"include"})," ",(0,d.jsx)(n.code,{children:"druid-kubernetes-extensions"})," in the extensions load list."]}),"\n",(0,d.jsx)(n.p,{children:"This extension works together with HTTP-based segment and task management in Druid. Consequently, following configurations must be set on all Druid nodes."}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"druid.zk.service.enabled=false"}),"\n",(0,d.jsx)(n.code,{children:"druid.serverview.type=http"}),"\n",(0,d.jsx)(n.code,{children:"druid.indexer.runner.type=httpRemote"}),"\n",(0,d.jsx)(n.code,{children:"druid.discovery.type=k8s"})]}),"\n",(0,d.jsxs)(n.p,{children:['For Node Discovery, Each Druid process running inside a pod "announces" itself by adding few "labels" and "annotations" in the pod spec. Druid process needs to be aware of pod name and namespace which it reads from environment variables ',(0,d.jsx)(n.code,{children:"POD_NAME"})," and ",(0,d.jsx)(n.code,{children:"POD_NAMESPACE"}),". These variable names can be changed, see configuration below. But in the end, each pod needs to have self pod name and namespace added as environment variables."]}),"\n",(0,d.jsx)(n.p,{children:"Additionally, this extension has following configuration."}),"\n",(0,d.jsx)(n.h3,{id:"properties",children:"Properties"}),"\n",(0,d.jsxs)(n.table,{children:[(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"Property"}),(0,d.jsx)(n.th,{children:"Possible Values"}),(0,d.jsx)(n.th,{children:"Description"}),(0,d.jsx)(n.th,{children:"Default"}),(0,d.jsx)(n.th,{children:"required"})]})}),(0,d.jsxs)(n.tbody,{children:[(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"druid.discovery.k8s.clusterIdentifier"})}),(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"string that matches [a-z0-9][a-z0-9-]*[a-z0-9]"})}),(0,d.jsx)(n.td,{children:"Unique identifier for this Druid cluster in Kubernetes e.g. us-west-prod-druid."}),(0,d.jsx)(n.td,{children:"None"}),(0,d.jsx)(n.td,{children:"Yes"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"druid.discovery.k8s.podNameEnvKey"})}),(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"Pod Env Variable"})}),(0,d.jsx)(n.td,{children:"Pod Env variable whose value is that pod's name."}),(0,d.jsx)(n.td,{children:"POD_NAME"}),(0,d.jsx)(n.td,{children:"No"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"druid.discovery.k8s.podNamespaceEnvKey"})}),(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"Pod Env Variable"})}),(0,d.jsx)(n.td,{children:"Pod Env variable whose value is that pod's kubernetes namespace."}),(0,d.jsx)(n.td,{children:"POD_NAMESPACE"}),(0,d.jsx)(n.td,{children:"No"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"druid.discovery.k8s.leaseDuration"})}),(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"Duration"})}),(0,d.jsx)(n.td,{children:"Lease duration used by Leader Election algorithm. Candidates wait for this time before taking over previous Leader."}),(0,d.jsx)(n.td,{children:"PT60S"}),(0,d.jsx)(n.td,{children:"No"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"druid.discovery.k8s.renewDeadline"})}),(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"Duration"})}),(0,d.jsx)(n.td,{children:"Lease renewal period used by Leader."}),(0,d.jsx)(n.td,{children:"PT17S"}),(0,d.jsx)(n.td,{children:"No"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"druid.discovery.k8s.retryPeriod"})}),(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"Duration"})}),(0,d.jsx)(n.td,{children:"Retry wait used by Leader Election algorithm on failed operations."}),(0,d.jsx)(n.td,{children:"PT5S"}),(0,d.jsx)(n.td,{children:"No"})]})]})]}),"\n",(0,d.jsx)(n.h3,{id:"gotchas",children:"Gotchas"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"Label/Annotation path in each pod spec MUST EXIST, which is easily satisfied if there is at least one label/annotation in the pod spec already."}),"\n",(0,d.jsx)(n.li,{children:"All Druid Pods belonging to one Druid cluster must be inside same kubernetes namespace."}),"\n",(0,d.jsx)(n.li,{children:'All Druid Pods need permissions to be able to add labels to self-pod, List and Watch other Pods, create and read ConfigMap for leader election. Assuming, "default" service account is used by Druid pods, you might need to add following or something similar Kubernetes Role and Role Binding.'}),"\n"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: druid-cluster\nrules:\n- apiGroups:\n  - \"\"\n  resources:\n  - pods\n  - configmaps\n  verbs:\n  - '*'\n---\nkind: RoleBinding\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\n  name: druid-cluster\nsubjects:\n- kind: ServiceAccount\n  name: default\nroleRef:\n  kind: Role\n  name: druid-cluster\n  apiGroup: rbac.authorization.k8s.io\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(a,{...e})}):a(e)}}}]);