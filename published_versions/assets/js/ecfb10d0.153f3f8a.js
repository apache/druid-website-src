"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[5368],{28453:(e,r,s)=>{s.d(r,{R:()=>a,x:()=>t});var n=s(96540);const i={},o=n.createContext(i);function a(e){const r=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function t(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(o.Provider,{value:r},e.children)}},30210:(e,r,s)=>{s.d(r,{A:()=>n});const n=s.p+"assets/images/services-overview-626a864a11edcf4945591a35d4a3814c.png"},37609:(e,r,s)=>{s.r(r),s.d(r,{assets:()=>d,contentTitle:()=>t,default:()=>h,frontMatter:()=>a,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"design/architecture","title":"Architecture","description":"\x3c!--","source":"@site/docs/32.0.0/design/architecture.md","sourceDirName":"design","slug":"/design/architecture","permalink":"/docs/32.0.0/design/architecture","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"architecture","title":"Architecture"},"sidebar":"docs","previous":{"title":"Kerberized HDFS deep storage","permalink":"/docs/32.0.0/tutorials/tutorial-kerberos-hadoop"},"next":{"title":"Coordinator","permalink":"/docs/32.0.0/design/coordinator"}}');var i=s(74848),o=s(28453);const a={id:"architecture",title:"Architecture"},t=void 0,d={},l=[{value:"Druid services",id:"druid-services",level:2},{value:"Druid servers",id:"druid-servers",level:2},{value:"Master server",id:"master-server",level:3},{value:"Coordinator service",id:"coordinator-service",level:4},{value:"Overlord service",id:"overlord-service",level:4},{value:"Query server",id:"query-server",level:3},{value:"Broker service",id:"broker-service",level:4},{value:"Router service",id:"router-service",level:4},{value:"Data server",id:"data-server",level:3},{value:"Historical service",id:"historical-service",level:4},{value:"Middle Manager service",id:"middle-manager-service",level:4},{value:"Peon service",id:"peon-service",level:5},{value:"Indexer service (optional)",id:"indexer-service-optional",level:4},{value:"Colocation of services",id:"colocation-of-services",level:2},{value:"Coordinators and Overlords",id:"coordinators-and-overlords",level:3},{value:"Historicals and Middle Managers",id:"historicals-and-middle-managers",level:3},{value:"External dependencies",id:"external-dependencies",level:2},{value:"Deep storage",id:"deep-storage",level:3},{value:"Metadata storage",id:"metadata-storage",level:3},{value:"ZooKeeper",id:"zookeeper",level:3},{value:"Learn more",id:"learn-more",level:2}];function c(e){const r={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",h5:"h5",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.p,{children:"Druid has a distributed architecture that is designed to be cloud-friendly and easy to operate. You can configure and scale services independently for maximum flexibility over cluster operations. This design includes enhanced fault tolerance: an outage of one component does not immediately affect other components."}),"\n",(0,i.jsx)(r.p,{children:"The following diagram shows the services that make up the Druid architecture, their typical arrangement across servers, and how queries and data flow through this architecture."}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.img,{alt:"Druid architecture",src:s(55463).A+"",width:"1967",height:"873"})}),"\n",(0,i.jsx)(r.p,{children:"The following sections describe the components of this architecture."}),"\n",(0,i.jsx)(r.h2,{id:"druid-services",children:"Druid services"}),"\n",(0,i.jsx)(r.p,{children:"Druid has several types of services:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.a,{href:"/docs/32.0.0/design/coordinator",children:"Coordinator"})," manages data availability on the cluster."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.a,{href:"/docs/32.0.0/design/overlord",children:"Overlord"})," controls the assignment of data ingestion workloads."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.a,{href:"/docs/32.0.0/design/broker",children:"Broker"})," handles queries from external clients."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.a,{href:"/docs/32.0.0/design/router",children:"Router"})," routes requests to Brokers, Coordinators, and Overlords."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.a,{href:"/docs/32.0.0/design/historical",children:"Historical"})," stores queryable data."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.a,{href:"/docs/32.0.0/design/middlemanager",children:"Middle Manager"})," and ",(0,i.jsx)(r.a,{href:"/docs/32.0.0/design/peons",children:"Peon"})," ingest data."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.a,{href:"/docs/32.0.0/design/indexer",children:"Indexer"})," serves as an alternative to the Middle Manager + Peon task execution system."]}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:["You can view services in the ",(0,i.jsx)(r.strong,{children:"Services"})," tab in the web console:"]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.img,{alt:"Druid services",src:s(30210).A+"",title:"Services in the web console",width:"1250",height:"640"})}),"\n",(0,i.jsx)(r.h2,{id:"druid-servers",children:"Druid servers"}),"\n",(0,i.jsxs)(r.p,{children:["You can deploy Druid services according to your preferences. For ease of deployment, we recommend organizing them into three server types: ",(0,i.jsx)(r.a,{href:"#master-server",children:"Master"}),", ",(0,i.jsx)(r.a,{href:"#query-server",children:"Query"}),", and ",(0,i.jsx)(r.a,{href:"#data-server",children:"Data"}),"."]}),"\n",(0,i.jsx)(r.h3,{id:"master-server",children:"Master server"}),"\n",(0,i.jsxs)(r.p,{children:["A Master server manages data ingestion and availability. It is responsible for starting new ingestion jobs and coordinating availability of data on the ",(0,i.jsx)(r.a,{href:"#data-server",children:"Data server"}),"."]}),"\n",(0,i.jsx)(r.p,{children:"Master servers divide operations between Coordinator and Overlord services."}),"\n",(0,i.jsx)(r.h4,{id:"coordinator-service",children:"Coordinator service"}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.a,{href:"/docs/32.0.0/design/coordinator",children:"Coordinator"})," services watch over the Historical services on the Data servers. They are responsible for assigning segments to specific servers, and for ensuring segments are well-balanced across Historicals."]}),"\n",(0,i.jsx)(r.h4,{id:"overlord-service",children:"Overlord service"}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.a,{href:"/docs/32.0.0/design/overlord",children:"Overlord"})," services watch over the Middle Manager services on the Data servers and are the controllers of data ingestion into Druid. They are responsible for assigning ingestion tasks to Middle Managers and for coordinating segment publishing."]}),"\n",(0,i.jsx)(r.h3,{id:"query-server",children:"Query server"}),"\n",(0,i.jsx)(r.p,{children:"A Query server provides the endpoints that users and client applications interact with, routing queries to Data servers or other Query servers (and optionally proxied Master server requests)."}),"\n",(0,i.jsx)(r.p,{children:"Query servers divide operations between Broker and Router services."}),"\n",(0,i.jsx)(r.h4,{id:"broker-service",children:"Broker service"}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.a,{href:"/docs/32.0.0/design/broker",children:"Broker"})," services receive queries from external clients and forward those queries to Data servers. When Brokers receive results from those subqueries, they merge those results and return them to the caller. Typically, you query Brokers rather than querying Historical or Middle Manager services on Data servers directly."]}),"\n",(0,i.jsx)(r.h4,{id:"router-service",children:"Router service"}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.a,{href:"/docs/32.0.0/design/router",children:(0,i.jsx)(r.strong,{children:"Router"})})," services provide a unified API gateway in front of Brokers, Overlords, and Coordinators."]}),"\n",(0,i.jsxs)(r.p,{children:["The Router service also runs the ",(0,i.jsx)(r.a,{href:"/docs/32.0.0/operations/web-console",children:"web console"}),", a UI for loading data, managing datasources and tasks, and viewing server status and segment information."]}),"\n",(0,i.jsx)(r.h3,{id:"data-server",children:"Data server"}),"\n",(0,i.jsx)(r.p,{children:"A Data server executes ingestion jobs and stores queryable data."}),"\n",(0,i.jsx)(r.p,{children:"Data servers divide operations between Historical and Middle Manager services."}),"\n",(0,i.jsx)(r.h4,{id:"historical-service",children:"Historical service"}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.a,{href:"/docs/32.0.0/design/historical",children:(0,i.jsx)(r.strong,{children:"Historical"})})," services handle storage and querying on historical data, including any streaming data that has been in the system long enough to be committed. Historical services download segments from deep storage and respond to queries about these segments. They don't accept writes."]}),"\n",(0,i.jsx)(r.h4,{id:"middle-manager-service",children:"Middle Manager service"}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.a,{href:"/docs/32.0.0/design/middlemanager",children:(0,i.jsx)(r.strong,{children:"Middle Manager"})})," services handle ingestion of new data into the cluster. They are responsible\nfor reading from external data sources and publishing new Druid segments."]}),"\n",(0,i.jsx)(r.h5,{id:"peon-service",children:"Peon service"}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.a,{href:"/docs/32.0.0/design/peons",children:(0,i.jsx)(r.strong,{children:"Peon"})})," services are task execution engines spawned by Middle Managers. Each Peon runs a separate JVM and is responsible for executing a single task. Peons always run on the same host as the Middle Manager that spawned them."]}),"\n",(0,i.jsx)(r.h4,{id:"indexer-service-optional",children:"Indexer service (optional)"}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.a,{href:"/docs/32.0.0/design/indexer",children:(0,i.jsx)(r.strong,{children:"Indexer"})})," services are an alternative to Middle Managers and Peons. Instead of\nforking separate JVM processes per-task, the Indexer runs tasks as individual threads within a single JVM process."]}),"\n",(0,i.jsxs)(r.p,{children:["The Indexer is designed to be easier to configure and deploy compared to the MiddleManager + Peon system and to better enable resource sharing across tasks, which can help streaming ingestion. The Indexer is currently designated ",(0,i.jsx)(r.a,{href:"/docs/32.0.0/development/experimental",children:"experimental"}),"."]}),"\n",(0,i.jsxs)(r.p,{children:["Typically, you would deploy one of the following: MiddleManagers, ",(0,i.jsx)(r.a,{href:"/docs/32.0.0/development/extensions-core/k8s-jobs",children:"MiddleManager-less ingestion using Kubernetes"}),", or Indexers. You wouldn't deploy more than one of these options."]}),"\n",(0,i.jsx)(r.h2,{id:"colocation-of-services",children:"Colocation of services"}),"\n",(0,i.jsx)(r.p,{children:"Colocating Druid services by server type generally results in better utilization of hardware resources for most clusters.\nFor very large scale clusters, it can be desirable to split the Druid services such that they run on individual servers to avoid resource contention."}),"\n",(0,i.jsx)(r.p,{children:"This section describes guidelines and configuration parameters related to service colocation."}),"\n",(0,i.jsx)(r.h3,{id:"coordinators-and-overlords",children:"Coordinators and Overlords"}),"\n",(0,i.jsx)(r.p,{children:"The workload on the Coordinator service tends to increase with the number of segments in the cluster. The Overlord's workload also increases based on the number of segments in the cluster, but to a lesser degree than the Coordinator."}),"\n",(0,i.jsx)(r.p,{children:"In clusters with very high segment counts, it can make sense to separate the Coordinator and Overlord services to provide more resources for the Coordinator's segment balancing workload."}),"\n",(0,i.jsxs)(r.p,{children:["You can run the Coordinator and Overlord services as a single combined service by setting the ",(0,i.jsx)(r.code,{children:"druid.coordinator.asOverlord.enabled"})," property.\nFor more information, see ",(0,i.jsx)(r.a,{href:"/docs/32.0.0/configuration/#coordinator-operation",children:"Coordinator Operation"}),"."]}),"\n",(0,i.jsx)(r.h3,{id:"historicals-and-middle-managers",children:"Historicals and Middle Managers"}),"\n",(0,i.jsx)(r.p,{children:"With higher levels of ingestion or query load, it can make sense to deploy the Historical and Middle Manager services on separate hosts to to avoid CPU and memory contention."}),"\n",(0,i.jsx)(r.p,{children:"The Historical service also benefits from having free memory for memory mapped segments, which can be another reason to deploy the Historical and Middle Manager services separately."}),"\n",(0,i.jsx)(r.h2,{id:"external-dependencies",children:"External dependencies"}),"\n",(0,i.jsx)(r.p,{children:"In addition to its built-in service types, Druid also has three external dependencies. These are intended to be able to\nleverage existing infrastructure, where present."}),"\n",(0,i.jsx)(r.h3,{id:"deep-storage",children:"Deep storage"}),"\n",(0,i.jsx)(r.p,{children:"Druid uses deep storage to store any data that has been ingested into the system. Deep storage is shared file\nstorage accessible by every Druid server. In a clustered deployment, this is typically a distributed object store like S3 or\nHDFS, or a network mounted filesystem. In a single-server deployment, this is typically local disk."}),"\n",(0,i.jsx)(r.p,{children:"Druid uses deep storage for the following purposes:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["To store all the data you ingest. Segments that get loaded onto Historical services for low latency queries are also kept in deep storage for backup purposes. Additionally, segments that are only in deep storage can be used for ",(0,i.jsx)(r.a,{href:"/docs/32.0.0/querying/query-deep-storage",children:"queries from deep storage"}),"."]}),"\n",(0,i.jsxs)(r.li,{children:["As a way to transfer data in the background between Druid services. Druid stores data in files called ",(0,i.jsx)(r.em,{children:"segments"}),"."]}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"Historical services cache data segments on local disk and serve queries from that cache as well as from an in-memory cache.\nSegments on disk for Historical services provide the low latency querying performance Druid is known for."}),"\n",(0,i.jsx)(r.p,{children:"You can also query directly from deep storage. When you query segments that exist only in deep storage, you trade some performance  for the ability to query more of your data without necessarily having to scale your Historical services."}),"\n",(0,i.jsx)(r.p,{children:"When determining sizing for your storage, keep the following in mind:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Deep storage needs to be able to hold all the data that you ingest into Druid."}),"\n",(0,i.jsx)(r.li,{children:"On disk storage for Historical services need to be able to accommodate the data you want to load onto them to run queries. The data on Historical services should be data you access frequently and need to run low latency queries for."}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"Deep storage is an important part of Druid's elastic, fault-tolerant design. Druid bootstraps from deep storage even\nif every single data server is lost and re-provisioned."}),"\n",(0,i.jsxs)(r.p,{children:["For more details, please see the ",(0,i.jsx)(r.a,{href:"/docs/32.0.0/design/deep-storage",children:"Deep storage"})," page."]}),"\n",(0,i.jsx)(r.h3,{id:"metadata-storage",children:"Metadata storage"}),"\n",(0,i.jsx)(r.p,{children:"The metadata storage holds various shared system metadata such as segment usage information and task information. In a\nclustered deployment, this is typically a traditional RDBMS like PostgreSQL or MySQL. In a single-server\ndeployment, it is typically a locally-stored Apache Derby database."}),"\n",(0,i.jsxs)(r.p,{children:["For more details, please see the ",(0,i.jsx)(r.a,{href:"/docs/32.0.0/design/metadata-storage",children:"Metadata storage"})," page."]}),"\n",(0,i.jsx)(r.h3,{id:"zookeeper",children:"ZooKeeper"}),"\n",(0,i.jsx)(r.p,{children:"Used for internal service discovery, coordination, and leader election."}),"\n",(0,i.jsxs)(r.p,{children:["For more details, please see the ",(0,i.jsx)(r.a,{href:"/docs/32.0.0/design/zookeeper",children:"ZooKeeper"})," page."]}),"\n",(0,i.jsx)(r.h2,{id:"learn-more",children:"Learn more"}),"\n",(0,i.jsx)(r.p,{children:"See the following topics for more information:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.a,{href:"/docs/32.0.0/design/storage",children:"Storage components"})," to learn about data storage in Druid."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.a,{href:"/docs/32.0.0/design/segments",children:"Segments"})," to learn about segment files."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.a,{href:"/docs/32.0.0/querying/query-processing",children:"Query processing"})," for a high-level overview of how Druid processes queries."]}),"\n"]})]})}function h(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},55463:(e,r,s)=>{s.d(r,{A:()=>n});const n=s.p+"assets/images/druid-architecture-a2d14e8be60d586632471e97383e406c.svg"}}]);