"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9003],{28453:(e,i,s)=>{s.d(i,{R:()=>o,x:()=>a});var n=s(96540);const r={},t=n.createContext(r);function o(e){const i=n.useContext(t);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),n.createElement(t.Provider,{value:i},e.children)}},73749:(e,i,s)=>{s.r(i),s.d(i,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"design/historical","title":"Historical service","description":"\x3c!--","source":"@site/docs/32.0.0/design/historical.md","sourceDirName":"design","slug":"/design/historical","permalink":"/docs/32.0.0/design/historical","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"historical","title":"Historical service","sidebar_label":"Historical"},"sidebar":"docs","previous":{"title":"Router","permalink":"/docs/32.0.0/design/router"},"next":{"title":"Middle Manager","permalink":"/docs/32.0.0/design/middlemanager"}}');var r=s(74848),t=s(28453);const o={id:"historical",title:"Historical service",sidebar_label:"Historical"},a=void 0,c={},d=[{value:"Configuration",id:"configuration",level:2},{value:"HTTP endpoints",id:"http-endpoints",level:2},{value:"Running",id:"running",level:2},{value:"Loading and serving segments",id:"loading-and-serving-segments",level:2},{value:"Loading and serving segments from cache",id:"loading-and-serving-segments-from-cache",level:2},{value:"Querying segments",id:"querying-segments",level:2}];function l(e){const i={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.p,{children:"The Historical service is responsible for storing and querying historical data.\nHistorical services cache data segments on local disk and serve queries from that cache as well as from an in-memory cache."}),"\n",(0,r.jsx)(i.h2,{id:"configuration",children:"Configuration"}),"\n",(0,r.jsxs)(i.p,{children:["For Apache Druid Historical service configuration, see ",(0,r.jsx)(i.a,{href:"/docs/32.0.0/configuration/#historical",children:"Historical configuration"}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["For basic tuning guidance for the Historical service, see ",(0,r.jsx)(i.a,{href:"/docs/32.0.0/operations/basic-cluster-tuning#historical",children:"Basic cluster tuning"}),"."]}),"\n",(0,r.jsx)(i.h2,{id:"http-endpoints",children:"HTTP endpoints"}),"\n",(0,r.jsxs)(i.p,{children:["For a list of API endpoints supported by the Historical, please see the ",(0,r.jsx)(i.a,{href:"/docs/32.0.0/api-reference/service-status-api#historical",children:"Service status API reference"}),"."]}),"\n",(0,r.jsx)(i.h2,{id:"running",children:"Running"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{children:"org.apache.druid.cli.Main server historical\n"})}),"\n",(0,r.jsx)(i.h2,{id:"loading-and-serving-segments",children:"Loading and serving segments"}),"\n",(0,r.jsxs)(i.p,{children:["Each Historical service copies or pulls segment files from deep storage to local disk in an area called the segment cache. To configure the size and location of the segment cache on each Historical service, set the ",(0,r.jsx)(i.code,{children:"druid.segmentCache.locations"}),".\nFor more information, see ",(0,r.jsx)(i.a,{href:"/docs/32.0.0/operations/basic-cluster-tuning#segment-cache-size",children:"Segment cache size"}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["The ",(0,r.jsx)(i.a,{href:"/docs/32.0.0/design/coordinator",children:"Coordinator"})," controls the assignment of segments to Historicals and the balance of segments between Historicals. Historical services do not communicate directly with each other, nor do they communicate directly with the Coordinator. Instead, the Coordinator creates ephemeral entries in ZooKeeper in a ",(0,r.jsx)(i.a,{href:"/docs/32.0.0/configuration/#path-configuration",children:"load queue path"}),". Each Historical service maintains a connection to ZooKeeper, watching those paths for segment information."]}),"\n",(0,r.jsx)(i.p,{children:"When a Historical service detects a new entry in the ZooKeeper load queue, it checks its own segment cache. If no information about the segment exists there, the Historical service first retrieves metadata from ZooKeeper about the segment, including where the segment is located in deep storage and how it needs to decompress and process it."}),"\n",(0,r.jsxs)(i.p,{children:["For more information about segment metadata and Druid segments in general, see ",(0,r.jsx)(i.a,{href:"/docs/32.0.0/design/segments",children:"Segments"}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["After a Historical service pulls down and processes a segment from deep storage, Druid advertises the segment as being available for queries from the Broker. This announcement by the Historical is made via ZooKeeper, in a ",(0,r.jsx)(i.a,{href:"/docs/32.0.0/configuration/#path-configuration",children:"served segments path"}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["For more information about how the Broker determines what data is available for queries, see ",(0,r.jsx)(i.a,{href:"/docs/32.0.0/design/broker",children:"Broker"}),"."]}),"\n",(0,r.jsx)(i.p,{children:"To make data from the segment cache available for querying as soon as possible, Historical services search the local segment cache upon startup and advertise the segments found there."}),"\n",(0,r.jsx)(i.h2,{id:"loading-and-serving-segments-from-cache",children:"Loading and serving segments from cache"}),"\n",(0,r.jsxs)(i.p,{children:["The segment cache uses ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Mmap",children:"memory mapping"}),". The cache consumes memory from the underlying operating system so Historicals can hold parts of segment files in memory to increase query performance at the data level. The in-memory segment cache is affected by the size of the Historical JVM, heap / direct memory buffers, and other services on the operating system itself."]}),"\n",(0,r.jsxs)(i.p,{children:['At query time, if the required part of a segment file is available in the memory mapped cache or "page cache", the Historical re-uses it and reads it directly from memory. If it is not in the memory-mapped cache, the Historical reads that part of the segment from disk. In this case, there is potential for new data to flush other segment data from memory. This means that if free operating system memory is close to ',(0,r.jsx)(i.code,{children:"druid.server.maxSize"}),", the more likely that segment data will be available in memory and reduce query times. Conversely, the lower the free operating system memory, the more likely a Historical is to read segments from disk."]}),"\n",(0,r.jsxs)(i.p,{children:["Note that this memory-mapped segment cache is in addition to other ",(0,r.jsx)(i.a,{href:"/docs/32.0.0/querying/caching",children:"query-level caches"}),"."]}),"\n",(0,r.jsx)(i.h2,{id:"querying-segments",children:"Querying segments"}),"\n",(0,r.jsxs)(i.p,{children:["You can configure a Historical service to log and report metrics for every query it services.\nFor information on querying Historical services, see ",(0,r.jsx)(i.a,{href:"/docs/32.0.0/querying/",children:"Querying"}),"."]})]})}function h(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}}}]);