"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7837],{28453:(e,t,a)=>{a.d(t,{R:()=>r,x:()=>i});var s=a(96540);const n={},o=s.createContext(n);function r(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),s.createElement(o.Provider,{value:t},e.children)}},90090:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"design/metadata-storage","title":"Metadata storage","description":"\x3c!--","source":"@site/docs/32.0.0/design/metadata-storage.md","sourceDirName":"design","slug":"/design/metadata-storage","permalink":"/docs/32.0.0/design/metadata-storage","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"metadata-storage","title":"Metadata storage"},"sidebar":"docs","previous":{"title":"Deep storage","permalink":"/docs/32.0.0/design/deep-storage"},"next":{"title":"ZooKeeper","permalink":"/docs/32.0.0/design/zookeeper"}}');var n=a(74848),o=a(28453);const r={id:"metadata-storage",title:"Metadata storage"},i=void 0,d={},l=[{value:"Available metadata stores",id:"available-metadata-stores",level:2},{value:"MySQL",id:"mysql",level:3},{value:"PostgreSQL",id:"postgresql",level:3},{value:"Derby",id:"derby",level:3},{value:"Adding custom DBCP properties",id:"adding-custom-dbcp-properties",level:2},{value:"Metadata storage tables",id:"metadata-storage-tables",level:2},{value:"Segments table",id:"segments-table",level:3},{value:"Rule table",id:"rule-table",level:3},{value:"Config table",id:"config-table",level:3},{value:"Task-related tables",id:"task-related-tables",level:3},{value:"Audit table",id:"audit-table",level:3},{value:"Metadata storage access",id:"metadata-storage-access",level:2},{value:"Learn more",id:"learn-more",level:2}];function c(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"Apache Druid relies on an external dependency for metadata storage.\nDruid uses the metadata store to house various metadata about the system, but not to store the actual data.\nThe metadata store retains all metadata essential for a Druid cluster to work."}),"\n",(0,n.jsx)(t.p,{children:"The metadata store includes the following:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Segments records"}),"\n",(0,n.jsx)(t.li,{children:"Rule records"}),"\n",(0,n.jsx)(t.li,{children:"Configuration records"}),"\n",(0,n.jsx)(t.li,{children:"Task-related tables"}),"\n",(0,n.jsx)(t.li,{children:"Audit records"}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["Derby is the default metadata store for Druid, however, it is not suitable for production.\n",(0,n.jsx)(t.a,{href:"/docs/32.0.0/development/extensions-core/mysql",children:"MySQL"})," and ",(0,n.jsx)(t.a,{href:"/docs/32.0.0/development/extensions-core/postgresql",children:"PostgreSQL"})," are more production suitable metadata stores.\nSee ",(0,n.jsx)(t.a,{href:"/docs/32.0.0/configuration/#metadata-storage",children:"Metadata storage configuration"})," for the default configuration settings."]}),"\n",(0,n.jsx)(t.admonition,{type:"info",children:(0,n.jsx)(t.p,{children:"We also recommend you set up a high availability environment because there is no way to restore lost metadata."})}),"\n",(0,n.jsx)(t.h2,{id:"available-metadata-stores",children:"Available metadata stores"}),"\n",(0,n.jsx)(t.p,{children:"Druid supports Derby, MySQL, and PostgreSQL for storing metadata. Note that your metadata store must be ACID-compliant. If it isn't ACID-compliant, you can encounter issues, such as tasks failing sporadically."}),"\n",(0,n.jsx)(t.p,{children:"To avoid issues with upgrades that require schema changes to a large metadata table, consider a metadata store version that supports instant ADD COLUMN semantics.\nSee the database-specific docs for guidance on versions."}),"\n",(0,n.jsx)(t.h3,{id:"mysql",children:"MySQL"}),"\n",(0,n.jsxs)(t.p,{children:["See ",(0,n.jsx)(t.a,{href:"/docs/32.0.0/development/extensions-core/mysql",children:"mysql-metadata-storage extension documentation"}),"."]}),"\n",(0,n.jsx)(t.h3,{id:"postgresql",children:"PostgreSQL"}),"\n",(0,n.jsxs)(t.p,{children:["See ",(0,n.jsx)(t.a,{href:"/docs/32.0.0/development/extensions-core/postgresql",children:"postgresql-metadata-storage"}),"."]}),"\n",(0,n.jsx)(t.h3,{id:"derby",children:"Derby"}),"\n",(0,n.jsx)(t.admonition,{type:"info",children:(0,n.jsx)(t.p,{children:"For production clusters, consider using MySQL or PostgreSQL instead of Derby."})}),"\n",(0,n.jsx)(t.p,{children:"Configure metadata storage with Derby by setting the following properties in your Druid configuration."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-properties",children:"druid.metadata.storage.type=derby\ndruid.metadata.storage.connector.connectURI=jdbc:derby://localhost:1527//opt/var/druid_state/derby;create=true\n"})}),"\n",(0,n.jsx)(t.h2,{id:"adding-custom-dbcp-properties",children:"Adding custom DBCP properties"}),"\n",(0,n.jsxs)(t.p,{children:["You can add custom properties to customize the database connection pool (DBCP) for connecting to the metadata store.\nDefine these properties with a ",(0,n.jsx)(t.code,{children:"druid.metadata.storage.connector.dbcp."})," prefix.\nFor example:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-properties",children:"druid.metadata.storage.connector.dbcp.maxConnLifetimeMillis=1200000\ndruid.metadata.storage.connector.dbcp.defaultQueryTimeout=30000\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Certain properties cannot be set through ",(0,n.jsx)(t.code,{children:"druid.metadata.storage.connector.dbcp."})," and must be set with the prefix ",(0,n.jsx)(t.code,{children:"druid.metadata.storage.connector."}),":"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.code,{children:"username"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.code,{children:"password"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.code,{children:"connectURI"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.code,{children:"validationQuery"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.code,{children:"testOnBorrow"})}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["See ",(0,n.jsx)(t.a,{href:"https://commons.apache.org/proper/commons-dbcp/configuration",children:"BasicDataSource Configuration"})," for a full list of configurable properties."]}),"\n",(0,n.jsx)(t.h2,{id:"metadata-storage-tables",children:"Metadata storage tables"}),"\n",(0,n.jsx)(t.p,{children:"This section describes the various tables in metadata storage."}),"\n",(0,n.jsx)(t.h3,{id:"segments-table",children:"Segments table"}),"\n",(0,n.jsxs)(t.p,{children:["This is dictated by the ",(0,n.jsx)(t.code,{children:"druid.metadata.storage.tables.segments"})," property."]}),"\n",(0,n.jsxs)(t.p,{children:['This table stores metadata about the segments that should be available in the system. (This set of segments is called\n"used segments" elsewhere in the documentation and throughout the project.) The table is polled by the\n',(0,n.jsx)(t.a,{href:"/docs/32.0.0/design/coordinator",children:"Coordinator"})," to determine the set of segments that should be available for querying in the\nsystem. The table has two main functional columns, the other columns are for indexing purposes."]}),"\n",(0,n.jsxs)(t.p,{children:["Value 1 in the ",(0,n.jsx)(t.code,{children:"used"}),' column means that the segment should be "used" by the cluster (i.e., it should be loaded and\navailable for requests). Value 0 means that the segment should not be loaded into the cluster. We do this as a means of\nunloading segments from the cluster without actually removing their metadata (which allows for simpler rolling back if\nthat is ever an issue). The ',(0,n.jsx)(t.code,{children:"used"})," column has a corresponding ",(0,n.jsx)(t.code,{children:"used_status_last_updated"})," column which denotes the time\nwhen the ",(0,n.jsx)(t.code,{children:"used"})," status of the segment was last updated. This information can be used by the Coordinator to determine if\na segment is a candidate for deletion (if automated segment killing is enabled)."]}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"payload"})," column stores a JSON blob that has all of the metadata for the segment.\nSome of the data in the ",(0,n.jsx)(t.code,{children:"payload"})," column intentionally duplicates data from other columns in the segments table.\nAs an example, the ",(0,n.jsx)(t.code,{children:"payload"})," column may take the following form:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-json",children:'{\n "dataSource":"wikipedia",\n "interval":"2012-05-23T00:00:00.000Z/2012-05-24T00:00:00.000Z",\n "version":"2012-05-24T00:10:00.046Z",\n "loadSpec":{\n    "type":"s3_zip",\n    "bucket":"bucket_for_segment",\n    "key":"path/to/segment/on/s3"\n },\n "dimensions":"comma-delimited-list-of-dimension-names",\n "metrics":"comma-delimited-list-of-metric-names",\n "shardSpec":{"type":"none"},\n "binaryVersion":9,\n "size":size_of_segment,\n "identifier":"wikipedia_2012-05-23T00:00:00.000Z_2012-05-24T00:00:00.000Z_2012-05-23T00:10:00.046Z"\n}\n'})}),"\n",(0,n.jsx)(t.h3,{id:"rule-table",children:"Rule table"}),"\n",(0,n.jsxs)(t.p,{children:["The rule table stores the various rules about where segments should\nland. These rules are used by the ",(0,n.jsx)(t.a,{href:"/docs/32.0.0/design/coordinator",children:"Coordinator"}),"\nwhen making segment (re-)allocation decisions about the cluster."]}),"\n",(0,n.jsx)(t.h3,{id:"config-table",children:"Config table"}),"\n",(0,n.jsx)(t.p,{children:"The config table stores runtime configuration objects. We do not have\nmany of these yet and we are not sure if we will keep this mechanism going\nforward, but it is the beginnings of a method of changing some configuration\nparameters across the cluster at runtime."}),"\n",(0,n.jsx)(t.h3,{id:"task-related-tables",children:"Task-related tables"}),"\n",(0,n.jsxs)(t.p,{children:["Task-related tables are created and used by the ",(0,n.jsx)(t.a,{href:"/docs/32.0.0/design/overlord",children:"Overlord"})," and ",(0,n.jsx)(t.a,{href:"/docs/32.0.0/design/middlemanager",children:"Middle Manager"})," when managing tasks."]}),"\n",(0,n.jsx)(t.h3,{id:"audit-table",children:"Audit table"}),"\n",(0,n.jsxs)(t.p,{children:["The audit table stores the audit history for configuration changes\nsuch as rule changes done by ",(0,n.jsx)(t.a,{href:"/docs/32.0.0/design/coordinator",children:"Coordinator"})," and other\nconfig changes."]}),"\n",(0,n.jsx)(t.h2,{id:"metadata-storage-access",children:"Metadata storage access"}),"\n",(0,n.jsx)(t.p,{children:"Only the following processes access the metadata storage:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"Indexing service processes (if any)"}),"\n",(0,n.jsx)(t.li,{children:"Realtime processes (if any)"}),"\n",(0,n.jsx)(t.li,{children:"Coordinator processes"}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Thus you need to give permissions (e.g., in AWS security groups) for only these machines to access the metadata storage."}),"\n",(0,n.jsx)(t.h2,{id:"learn-more",children:"Learn more"}),"\n",(0,n.jsx)(t.p,{children:"See the following topics for more information:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"/docs/32.0.0/configuration/#metadata-storage",children:"Metadata storage configuration"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"/docs/32.0.0/operations/clean-metadata-store",children:"Automated cleanup for metadata records"})}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}}}]);