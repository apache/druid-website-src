"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7140],{28453:(e,s,i)=>{i.d(s,{R:()=>o,x:()=>r});var t=i(96540);const n={},a=t.createContext(n);function o(e){const s=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function r(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),t.createElement(a.Provider,{value:s},e.children)}},50494:(e,s,i)=>{i.r(s),i.d(s,{assets:()=>c,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"ingestion/schema-model","title":"Druid schema model","description":"Introduces concepts of datasources, primary timestamp, dimensions, and metrics.","source":"@site/docs/33.0.0/ingestion/schema-model.md","sourceDirName":"ingestion","slug":"/ingestion/schema-model","permalink":"/docs/33.0.0/ingestion/schema-model","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"schema-model","title":"Druid schema model","sidebar_label":"Schema model","description":"Introduces concepts of datasources, primary timestamp, dimensions, and metrics."},"sidebar":"docs","previous":{"title":"Input sources","permalink":"/docs/33.0.0/ingestion/input-sources"},"next":{"title":"Rollup","permalink":"/docs/33.0.0/ingestion/rollup"}}');var n=i(74848),a=i(28453);const o={id:"schema-model",title:"Druid schema model",sidebar_label:"Schema model",description:"Introduces concepts of datasources, primary timestamp, dimensions, and metrics."},r=void 0,c={},l=[{value:"Primary timestamp",id:"primary-timestamp",level:2},{value:"Dimensions",id:"dimensions",level:2},{value:"Metrics",id:"metrics",level:2}];function d(e){const s={a:"a",code:"code",h2:"h2",li:"li",p:"p",ul:"ul",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.p,{children:"Druid stores data in datasources, which are similar to tables in a traditional relational database management system (RDBMS). Druid's data model shares  similarities with both relational and timeseries data models."}),"\n",(0,n.jsx)(s.h2,{id:"primary-timestamp",children:"Primary timestamp"}),"\n",(0,n.jsxs)(s.p,{children:["Druid schemas must always include a primary timestamp. Druid uses the primary timestamp to ",(0,n.jsx)(s.a,{href:"/docs/33.0.0/ingestion/partitioning",children:"partition and sort"})," your data. Druid uses the primary timestamp to rapidly identify and retrieve data within the time range of queries. Druid also uses the primary timestamp column\nfor time-based ",(0,n.jsx)(s.a,{href:"/docs/33.0.0/data-management/",children:"data management operations"})," such as dropping time chunks, overwriting time chunks, and time-based retention rules."]}),"\n",(0,n.jsxs)(s.p,{children:["Druid parses the primary timestamp based on the ",(0,n.jsx)(s.a,{href:"/docs/33.0.0/ingestion/ingestion-spec#timestampspec",children:(0,n.jsx)(s.code,{children:"timestampSpec"})})," configuration at ingestion time. Regardless of the source field for the primary timestamp, Druid always stores the timestamp in the ",(0,n.jsx)(s.code,{children:"__time"})," column in your Druid datasource."]}),"\n",(0,n.jsxs)(s.p,{children:["You can control other important operations that are based on the primary timestamp in the\n",(0,n.jsx)(s.a,{href:"/docs/33.0.0/ingestion/ingestion-spec#granularityspec",children:(0,n.jsx)(s.code,{children:"granularitySpec"})}),". If you have more than one timestamp column, you can store the others as\n",(0,n.jsx)(s.a,{href:"/docs/33.0.0/ingestion/schema-design#secondary-timestamps",children:"secondary timestamps"}),"."]}),"\n",(0,n.jsx)(s.h2,{id:"dimensions",children:"Dimensions"}),"\n",(0,n.jsx)(s.p,{children:'Dimensions are columns that Druid stores "as-is". You can use dimensions for any purpose. For example, you can group, filter, or apply aggregators to dimensions at query time when necessary.'}),"\n",(0,n.jsxs)(s.p,{children:["If you disable ",(0,n.jsx)(s.a,{href:"/docs/33.0.0/ingestion/rollup",children:"rollup"}),", then Druid treats the set of\ndimensions like a set of columns to ingest. The dimensions behave exactly as you would expect from any database that does not support a rollup feature."]}),"\n",(0,n.jsxs)(s.p,{children:["At ingestion time, you configure dimensions in the ",(0,n.jsx)(s.a,{href:"/docs/33.0.0/ingestion/ingestion-spec#dimensionsspec",children:(0,n.jsx)(s.code,{children:"dimensionsSpec"})}),"."]}),"\n",(0,n.jsx)(s.h2,{id:"metrics",children:"Metrics"}),"\n",(0,n.jsxs)(s.p,{children:["Metrics are columns that Druid stores in an aggregated form. Metrics are most useful when you enable ",(0,n.jsx)(s.a,{href:"/docs/33.0.0/ingestion/rollup",children:"rollup"}),". If you specify a metric, you can apply an aggregation function to each row during ingestion. This\nhas the following benefits:"]}),"\n",(0,n.jsx)(s.p,{children:'Rollup is a form of aggregation that collapses dimensions while aggregating the values in the metrics, that is, it collapses rows but retains its summary information."'}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.a,{href:"/docs/33.0.0/ingestion/rollup",children:"Rollup"})," is a form of aggregation that combines multiple rows with the same timestamp value and dimension values. For example, the ",(0,n.jsx)(s.a,{href:"/docs/33.0.0/tutorials/tutorial-rollup",children:"rollup tutorial"})," demonstrates using rollup to collapse netflow data to a single row per ",(0,n.jsx)(s.code,{children:"(minute, srcIP, dstIP)"})," tuple, while retaining aggregate information about total packet and byte counts."]}),"\n",(0,n.jsx)(s.li,{children:"Druid can compute some aggregators, especially approximate ones, more quickly at query time if they are partially computed at ingestion time, including data that has not been rolled up."}),"\n"]}),"\n",(0,n.jsxs)(s.p,{children:["At ingestion time, you configure Metrics in the ",(0,n.jsx)(s.a,{href:"/docs/33.0.0/ingestion/ingestion-spec#metricsspec",children:(0,n.jsx)(s.code,{children:"metricsSpec"})}),"."]})]})}function m(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}}}]);