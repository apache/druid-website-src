"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[5350],{17193:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>c,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"querying/sql-json-functions","title":"SQL JSON functions","description":"\x3c!--","source":"@site/docs/latest/querying/sql-json-functions.md","sourceDirName":"querying","slug":"/querying/sql-json-functions","permalink":"/docs/latest/querying/sql-json-functions","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"sql-json-functions","title":"SQL JSON functions","sidebar_label":"JSON functions"},"sidebar":"docs","previous":{"title":"Multi-value string functions","permalink":"/docs/latest/querying/sql-multivalue-string-functions"},"next":{"title":"SQL query context","permalink":"/docs/latest/querying/sql-query-context"}}');var r=s(74848),i=s(28453);const c={id:"sql-json-functions",title:"SQL JSON functions",sidebar_label:"JSON functions"},d=void 0,o={},l=[{value:"JSONPath syntax",id:"jsonpath-syntax",level:3}];function a(e){const n={a:"a",code:"code",h3:"h3",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Druid supports nested columns, which provide optimized storage and indexes for nested data structures. See ",(0,r.jsx)(n.a,{href:"/docs/latest/querying/nested-columns",children:"Nested columns"})," for more information."]}),"\n",(0,r.jsxs)(n.p,{children:["You can use the following JSON functions to extract, transform, and create ",(0,r.jsx)(n.code,{children:"COMPLEX<json>"})," values."]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Function"}),(0,r.jsx)(n.th,{children:"Notes"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"JSON_KEYS(expr, path)"})}),(0,r.jsxs)(n.td,{children:["Returns an array of field names from ",(0,r.jsx)(n.code,{children:"expr"})," at the specified ",(0,r.jsx)(n.code,{children:"path"}),"."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"JSON_OBJECT(KEY expr1 VALUE expr2[, KEY expr3 VALUE expr4, ...])"})}),(0,r.jsxs)(n.td,{children:["Constructs a new ",(0,r.jsx)(n.code,{children:"COMPLEX<json>"})," object. The ",(0,r.jsx)(n.code,{children:"KEY"})," expressions must evaluate to string types. The ",(0,r.jsx)(n.code,{children:"VALUE"})," expressions can be composed of any input type, including other ",(0,r.jsx)(n.code,{children:"COMPLEX<json>"})," values. ",(0,r.jsx)(n.code,{children:"JSON_OBJECT"})," can accept colon-separated key-value pairs. The following syntax is equivalent: ",(0,r.jsx)(n.code,{children:"JSON_OBJECT(expr1:expr2[, expr3:expr4, ...])"}),"."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"JSON_MERGE(expr1, expr2[, expr3 ...])"})}),(0,r.jsxs)(n.td,{children:["Merges two or more JSON ",(0,r.jsx)(n.code,{children:"STRING"})," or ",(0,r.jsx)(n.code,{children:"COMPLEX<json>"})," into one. Preserves the rightmost value when there are key overlaps. Returning always a ",(0,r.jsx)(n.code,{children:"COMPLEX<json>"})," type."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"JSON_PATHS(expr)"})}),(0,r.jsxs)(n.td,{children:["Returns an array of all paths which refer to literal values in ",(0,r.jsx)(n.code,{children:"expr"})," in JSONPath format."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"JSON_QUERY(expr, path)"})}),(0,r.jsxs)(n.td,{children:["Extracts a ",(0,r.jsx)(n.code,{children:"COMPLEX<json>"})," value from ",(0,r.jsx)(n.code,{children:"expr"}),", at the specified ",(0,r.jsx)(n.code,{children:"path"}),"."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"JSON_QUERY_ARRAY(expr, path)"})}),(0,r.jsxs)(n.td,{children:["Extracts an ",(0,r.jsx)(n.code,{children:"ARRAY<COMPLEX<json>>"})," value from ",(0,r.jsx)(n.code,{children:"expr"})," at the specified ",(0,r.jsx)(n.code,{children:"path"}),". If value is not an ",(0,r.jsx)(n.code,{children:"ARRAY"}),", it gets translated into a single element ",(0,r.jsx)(n.code,{children:"ARRAY"})," containing the value at ",(0,r.jsx)(n.code,{children:"path"}),". The primary use of this function is to extract arrays of objects to use as inputs to other ",(0,r.jsx)(n.a,{href:"/docs/latest/querying/sql-array-functions",children:"array functions"}),"."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"JSON_VALUE(expr, path [RETURNING sqlType])"})}),(0,r.jsxs)(n.td,{children:["Extracts a literal value from ",(0,r.jsx)(n.code,{children:"expr"})," at the specified ",(0,r.jsx)(n.code,{children:"path"}),". If you specify ",(0,r.jsx)(n.code,{children:"RETURNING"})," and an SQL type name (such as ",(0,r.jsx)(n.code,{children:"VARCHAR"}),", ",(0,r.jsx)(n.code,{children:"BIGINT"}),", ",(0,r.jsx)(n.code,{children:"DOUBLE"}),", etc) the function plans the query using the suggested type. Otherwise, it attempts to infer the type based on the context. If it can't infer the type, it defaults to ",(0,r.jsx)(n.code,{children:"VARCHAR"}),"."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"PARSE_JSON(expr)"})}),(0,r.jsxs)(n.td,{children:["Parses ",(0,r.jsx)(n.code,{children:"expr"})," into a ",(0,r.jsx)(n.code,{children:"COMPLEX<json>"})," object. This operator deserializes JSON values when processing them, translating stringified JSON into a nested structure. If the input is not a ",(0,r.jsx)(n.code,{children:"VARCHAR"})," or it is invalid JSON, this function will result in an error."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TRY_PARSE_JSON(expr)"})}),(0,r.jsxs)(n.td,{children:["Parses ",(0,r.jsx)(n.code,{children:"expr"})," into a ",(0,r.jsx)(n.code,{children:"COMPLEX<json>"})," object. This operator deserializes JSON values when processing them, translating stringified JSON into a nested structure. If the input is not a ",(0,r.jsx)(n.code,{children:"VARCHAR"})," or it is invalid JSON, this function will result in a ",(0,r.jsx)(n.code,{children:"NULL"})," value."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TO_JSON_STRING(expr)"})}),(0,r.jsxs)(n.td,{children:["Serializes ",(0,r.jsx)(n.code,{children:"expr"})," into a JSON string."]})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"jsonpath-syntax",children:"JSONPath syntax"}),"\n",(0,r.jsxs)(n.p,{children:["Druid supports a subset of the ",(0,r.jsx)(n.a,{href:"https://github.com/json-path/JsonPath/blob/master/README.md",children:"JSONPath syntax"})," operators, primarily limited to extracting individual values from nested data structures."]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Operator"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$"})}),(0,r.jsx)(n.td,{children:"Root element. All JSONPath expressions start with this operator."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".<name>"})}),(0,r.jsx)(n.td,{children:"Child element in dot notation."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"['<name>']"})}),(0,r.jsx)(n.td,{children:"Child element in bracket notation."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"[<number>]"})}),(0,r.jsx)(n.td,{children:"Array index."})]})]})]}),"\n",(0,r.jsx)(n.p,{children:"Consider the following example input JSON:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{"x":1, "y":[1, 2, 3]}\n'})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["To return the entire JSON object:",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(n.code,{children:"$"}),"      -> ",(0,r.jsx)(n.code,{children:'{"x":1, "y":[1, 2, 3]}'})]}),"\n",(0,r.jsxs)(n.li,{children:['To return the value of the key "x":',(0,r.jsx)("br",{}),"\n",(0,r.jsx)(n.code,{children:"$.x"}),"    -> ",(0,r.jsx)(n.code,{children:"1"})]}),"\n",(0,r.jsxs)(n.li,{children:["For a key that contains an array, to return the entire array:",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(n.code,{children:"$['y']"})," -> ",(0,r.jsx)(n.code,{children:"[1, 2, 3]"})]}),"\n",(0,r.jsxs)(n.li,{children:["For a key that contains an array, to return an item in the array:",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(n.code,{children:"$.y[1]"})," -> ",(0,r.jsx)(n.code,{children:"2"})]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>d});var t=s(96540);const r={},i=t.createContext(r);function c(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);