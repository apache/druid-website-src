"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6063],{28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var i=n(96540);const o={},s=i.createContext(o);function a(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(s.Provider,{value:t},e.children)}},76996:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"design/coordinator","title":"Coordinator service","description":"\x3c!--","source":"@site/docs/33.0.0/design/coordinator.md","sourceDirName":"design","slug":"/design/coordinator","permalink":"/docs/33.0.0/design/coordinator","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"coordinator","title":"Coordinator service","sidebar_label":"Coordinator"},"sidebar":"docs","previous":{"title":"Architecture","permalink":"/docs/33.0.0/design/architecture"},"next":{"title":"Overlord","permalink":"/docs/33.0.0/design/overlord"}}');var o=n(74848),s=n(28453);const a={id:"coordinator",title:"Coordinator service",sidebar_label:"Coordinator"},r=void 0,c={},d=[{value:"Configuration",id:"configuration",level:2},{value:"HTTP endpoints",id:"http-endpoints",level:2},{value:"Running",id:"running",level:2},{value:"Rules",id:"rules",level:2},{value:"Clean up overshadowed segments",id:"clean-up-overshadowed-segments",level:3},{value:"Clean up non-overshadowed eternity tombstone segments",id:"clean-up-non-overshadowed-eternity-tombstone-segments",level:3},{value:"Segment availability",id:"segment-availability",level:2},{value:"Balancing segments in a tier",id:"balancing-segments-in-a-tier",level:2},{value:"Automatic compaction",id:"automatic-compaction",level:2},{value:"Segment search policy in automatic compaction",id:"segment-search-policy-in-automatic-compaction",level:2},{value:"FAQ",id:"faq",level:2}];function l(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:'The Coordinator service is primarily responsible for segment management and distribution. More specifically, the\nCoordinator service communicates to Historical services to load or drop segments based on configurations. The Coordinator is responsible for loading new segments, dropping outdated segments, ensuring that segments are "replicated" (that is, loaded on multiple different Historical nodes) proper (configured) number of times, and moving\n("balancing") segments between Historical nodes to keep the latter evenly loaded.'}),"\n",(0,o.jsxs)(t.p,{children:['The Coordinator runs its duties periodically and the time between each run is a configurable parameter. On each\nrun, the Coordinator assesses the current state of the cluster before deciding on the appropriate actions to take.\nSimilar to the Broker and Historical services, the Coordinator maintains a connection to a ZooKeeper cluster for\ncurrent cluster information. The Coordinator also maintains a connection to a database containing information about\n"used" segments (that is, the segments that ',(0,o.jsx)(t.em,{children:"should"})," be loaded in the cluster) and the loading rules."]}),"\n",(0,o.jsx)(t.p,{children:"Before any unassigned segments are serviced by Historical services, the Historical services for each tier are first\nsorted in terms of capacity, with least capacity servers having the highest priority. Unassigned segments are always\nassigned to the services with least capacity to maintain a level of balance between services. The Coordinator does not\ndirectly communicate with a Historical service when assigning it a new segment; instead the Coordinator creates some\ntemporary information about the new segment under load queue path of the Historical service. Once this request is seen,\nthe Historical service loads the segment and begins servicing it."}),"\n",(0,o.jsx)(t.h2,{id:"configuration",children:"Configuration"}),"\n",(0,o.jsxs)(t.p,{children:["For Apache Druid Coordinator service configuration, see ",(0,o.jsx)(t.a,{href:"/docs/33.0.0/configuration/#coordinator",children:"Coordinator configuration"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["For basic tuning guidance for the Coordinator service, see ",(0,o.jsx)(t.a,{href:"/docs/33.0.0/operations/basic-cluster-tuning#coordinator",children:"Basic cluster tuning"}),"."]}),"\n",(0,o.jsx)(t.h2,{id:"http-endpoints",children:"HTTP endpoints"}),"\n",(0,o.jsxs)(t.p,{children:["For a list of API endpoints supported by the Coordinator, see ",(0,o.jsx)(t.a,{href:"/docs/33.0.0/api-reference/service-status-api#coordinator",children:"Service status API reference"}),"."]}),"\n",(0,o.jsx)(t.h2,{id:"running",children:"Running"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"org.apache.druid.cli.Main server coordinator\n"})}),"\n",(0,o.jsx)(t.h2,{id:"rules",children:"Rules"}),"\n",(0,o.jsxs)(t.p,{children:["Segments can be automatically loaded and dropped from the cluster based on a set of rules. For more information on rules, see ",(0,o.jsx)(t.a,{href:"/docs/33.0.0/operations/rule-configuration",children:"Rule Configuration"}),"."]}),"\n",(0,o.jsx)(t.h3,{id:"clean-up-overshadowed-segments",children:"Clean up overshadowed segments"}),"\n",(0,o.jsx)(t.p,{children:"On each run, the Coordinator compares the set of used segments in the database with the segments served by some\nHistorical nodes in the cluster. The Coordinator sends requests to Historical nodes to unload unused segments or segments\nthat are removed from the database."}),"\n",(0,o.jsx)(t.p,{children:"Segments that are overshadowed (their versions are too old and their data has been replaced by newer segments) are\nmarked as unused. During the next Coordinator's run, they will be unloaded from Historical nodes in the cluster."}),"\n",(0,o.jsx)(t.h3,{id:"clean-up-non-overshadowed-eternity-tombstone-segments",children:"Clean up non-overshadowed eternity tombstone segments"}),"\n",(0,o.jsx)(t.p,{children:"On each run, the Coordinator determines and cleans up unneeded eternity tombstone segments for each datasource. These segments must fit all the following criteria:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["It is a tombstone segment that starts at -INF or ends at INF (for example, a tombstone with an interval of ",(0,o.jsx)(t.code,{children:"-146136543-09-08T08:23:32.096Z/2000-01-01"})," or ",(0,o.jsx)(t.code,{children:"2020-01-01/146140482-04-24T15:36:27.903Z"})," or ",(0,o.jsx)(t.code,{children:"-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z"}),")"]}),"\n",(0,o.jsx)(t.li,{children:"It does not overlap with any overshadowed segment"}),"\n",(0,o.jsx)(t.li,{children:"It has 0 core partitions"}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"segment-availability",children:"Segment availability"}),"\n",(0,o.jsx)(t.p,{children:"If a Historical service restarts or becomes unavailable for any reason, the Coordinator notices that a service has gone missing and treats all segments served by that service as being dropped. The segments are then reassigned to other Historical services in the cluster. However, each segment that is dropped is not immediately forgotten. Instead, there is a transitional data structure that stores all dropped segments with an associated lifetime. The lifetime represents a period of time in which the Coordinator will not reassign a dropped segment. Hence, if a Historical service becomes unavailable and available again within a short period of time, the Historical service will start up and serve segments from its cache without any of those segments being reassigned across the cluster."}),"\n",(0,o.jsx)(t.h2,{id:"balancing-segments-in-a-tier",children:"Balancing segments in a tier"}),"\n",(0,o.jsx)(t.p,{children:"Druid queries perform optimally when segments are distributed evenly across Historical services. An ideal distribution would ensure that all Historicals participate equally in the query load thus avoiding hot-spots in the system. To some extent, this can be achieved by keeping multiple replicas of a segment in a cluster.\nBut in a tier with several Historicals (or a low replication factor), segment replication is not sufficient to attain balance.\nThus, the Coordinator constantly monitors the set of segments present on each Historical in a tier and employs one of the following strategies to identify segments that may be moved from one Historical to another to retain balance."}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"cost"}),' (default): For a given segment in a tier, this strategy picks the server with the minimum "cost" of placing that segment. The cost is a function of the data interval of the segment and the data intervals of all the segments already present on the candidate server. In essence, this strategy tries to avoid placing segments with adjacent or overlapping data intervals on the same server. This is based on the premise that adjacent-interval segments are more likely to be used together in a query and placing them on the same server may lead to skewed CPU usages of Historicals.']}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"diskNormalized"}),": A derivative of the ",(0,o.jsx)(t.code,{children:"cost"})," strategy that weights the cost of placing a segment on a server with the disk usage ratio of the server. There are known issues with this strategy and is not recommended for a production cluster."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"random"}),": Distributes segments randomly across servers. This is an experimental strategy and is not recommended for a production cluster."]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"All of the above strategies prioritize moving segments from the Historical with the least available disk space."}),"\n",(0,o.jsx)(t.h2,{id:"automatic-compaction",children:"Automatic compaction"}),"\n",(0,o.jsxs)(t.p,{children:["The Coordinator manages the ",(0,o.jsx)(t.a,{href:"/docs/33.0.0/data-management/automatic-compaction",children:"automatic compaction system"}),".\nEach run, the Coordinator compacts segments by merging small segments or splitting a large one. This is useful when the size of your segments is not optimized which may degrade query performance.\nSee ",(0,o.jsx)(t.a,{href:"/docs/33.0.0/operations/segment-optimization",children:"Segment size optimization"})," for details."]}),"\n",(0,o.jsxs)(t.p,{children:["The Coordinator first finds the segments to compact based on the ",(0,o.jsx)(t.a,{href:"#segment-search-policy-in-automatic-compaction",children:"segment search policy"}),".\nOnce some segments are found, it issues a ",(0,o.jsx)(t.a,{href:"/docs/33.0.0/ingestion/tasks#compact",children:"compaction task"})," to compact those segments.\nThe maximum number of running compaction tasks is ",(0,o.jsx)(t.code,{children:"min(sum of worker capacity * slotRatio, maxSlots)"}),".\nNote that even if ",(0,o.jsx)(t.code,{children:"min(sum of worker capacity * slotRatio, maxSlots) = 0"}),", at least one compaction task is always submitted\nif the compaction is enabled for a dataSource.\nSee ",(0,o.jsx)(t.a,{href:"/docs/33.0.0/api-reference/automatic-compaction-api#manage-automatic-compaction",children:"Automatic compaction configuration API"})," and ",(0,o.jsx)(t.a,{href:"/docs/33.0.0/configuration/#automatic-compaction-dynamic-configuration",children:"Automatic compaction configuration"})," to enable and configure automatic compaction."]}),"\n",(0,o.jsx)(t.p,{children:"Compaction tasks might fail due to the following reasons:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"If the input segments of a compaction task are removed or overshadowed before it starts, that compaction task fails immediately."}),"\n",(0,o.jsxs)(t.li,{children:["If a task of a higher priority acquires a ",(0,o.jsx)(t.a,{href:"/docs/33.0.0/ingestion/tasks#locking",children:"time chunk lock"})," for an interval overlapping with the interval of a compaction task, the compaction task fails."]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Once a compaction task fails, the Coordinator simply checks the segments in the interval of the failed task again, and issues another compaction task in the next run."}),"\n",(0,o.jsxs)(t.p,{children:["Note that Compacting Segments Coordinator Duty is automatically enabled and run as part of the Indexing Service Duties group. However, Compacting Segments Coordinator Duty can be configured to run in isolation as a separate Coordinator duty group. This allows changing the period of Compacting Segments Coordinator Duty without impacting the period of other Indexing Service Duties. This can be done by setting the following properties. For more details, see ",(0,o.jsx)(t.a,{href:"/docs/33.0.0/development/modules#adding-your-own-custom-pluggable-coordinator-duty",children:"custom pluggable Coordinator Duty"}),"."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:'druid.coordinator.dutyGroups=[<SOME_GROUP_NAME>]\ndruid.coordinator.<SOME_GROUP_NAME>.duties=["compactSegments"]\ndruid.coordinator.<SOME_GROUP_NAME>.period=<PERIOD_TO_RUN_COMPACTING_SEGMENTS_DUTY>\n'})}),"\n",(0,o.jsx)(t.h2,{id:"segment-search-policy-in-automatic-compaction",children:"Segment search policy in automatic compaction"}),"\n",(0,o.jsx)(t.p,{children:"At every Coordinator run, this policy looks up time chunks from newest to oldest and checks whether the segments in those time chunks\nneed compaction.\nA set of segments needs compaction if all conditions below are satisfied:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["Total size of segments in the time chunk is smaller than or equal to the configured ",(0,o.jsx)(t.code,{children:"inputSegmentSizeBytes"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:["Segments have never been compacted yet or compaction spec has been updated since the last compaction: ",(0,o.jsx)(t.code,{children:"maxTotalRows"})," or ",(0,o.jsx)(t.code,{children:"indexSpec"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["Here are some details with an example. Suppose we have two dataSources (",(0,o.jsx)(t.code,{children:"foo"}),", ",(0,o.jsx)(t.code,{children:"bar"}),") as seen below:"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"foo"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.code,{children:"foo_2017-11-01T00:00:00.000Z_2017-12-01T00:00:00.000Z_VERSION"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.code,{children:"foo_2017-11-01T00:00:00.000Z_2017-12-01T00:00:00.000Z_VERSION_1"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.code,{children:"foo_2017-09-01T00:00:00.000Z_2017-10-01T00:00:00.000Z_VERSION"})}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"bar"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.code,{children:"bar_2017-10-01T00:00:00.000Z_2017-11-01T00:00:00.000Z_VERSION"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.code,{children:"bar_2017-10-01T00:00:00.000Z_2017-11-01T00:00:00.000Z_VERSION_1"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["Assuming that each segment is 10 MB and haven't been compacted yet, this policy first returns two segments of\n",(0,o.jsx)(t.code,{children:"foo_2017-11-01T00:00:00.000Z_2017-12-01T00:00:00.000Z_VERSION"})," and ",(0,o.jsx)(t.code,{children:"foo_2017-11-01T00:00:00.000Z_2017-12-01T00:00:00.000Z_VERSION_1"})," to compact together because\n",(0,o.jsx)(t.code,{children:"2017-11-01T00:00:00.000Z/2017-12-01T00:00:00.000Z"})," is the most recent time chunk."]}),"\n",(0,o.jsxs)(t.p,{children:["If the Coordinator has enough task slots for compaction, this policy will continue searching for the next segments and return\n",(0,o.jsx)(t.code,{children:"bar_2017-10-01T00:00:00.000Z_2017-11-01T00:00:00.000Z_VERSION"})," and ",(0,o.jsx)(t.code,{children:"bar_2017-10-01T00:00:00.000Z_2017-11-01T00:00:00.000Z_VERSION_1"}),".\nFinally, ",(0,o.jsx)(t.code,{children:"foo_2017-09-01T00:00:00.000Z_2017-10-01T00:00:00.000Z_VERSION"})," will be picked up even though there is only one segment in the time chunk of ",(0,o.jsx)(t.code,{children:"2017-09-01T00:00:00.000Z/2017-10-01T00:00:00.000Z"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["The search start point can be changed by setting ",(0,o.jsx)(t.code,{children:"skipOffsetFromLatest"}),".\nIf this is set, this policy will ignore the segments falling into the time chunk of (the end time of the most recent segment - ",(0,o.jsx)(t.code,{children:"skipOffsetFromLatest"}),").\nThis is to avoid conflicts between compaction tasks and realtime tasks.\nNote that realtime tasks have a higher priority than compaction tasks by default. Realtime tasks will revoke the locks of compaction tasks if their intervals overlap, resulting in the termination of the compaction task.\nFor more information, see ",(0,o.jsx)(t.a,{href:"/docs/33.0.0/data-management/automatic-compaction#avoid-conflicts-with-ingestion",children:"Avoid conflicts with ingestion"}),"."]}),"\n",(0,o.jsx)(t.admonition,{type:"info",children:(0,o.jsxs)(t.p,{children:["This policy currently cannot handle the situation when there are a lot of small segments which have the same interval,\nand their total size exceeds ",(0,o.jsx)(t.a,{href:"/docs/33.0.0/configuration/#automatic-compaction-dynamic-configuration",children:(0,o.jsx)(t.code,{children:"inputSegmentSizeBytes"})}),".\nIf it finds such segments, it simply skips them."]})}),"\n",(0,o.jsx)(t.h2,{id:"faq",children:"FAQ"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Do clients ever contact the Coordinator service?"})}),"\n",(0,o.jsx)(t.p,{children:"The Coordinator is not involved in a query."}),"\n",(0,o.jsx)(t.p,{children:"Historical services never directly contact the Coordinator service. The Coordinator tells the Historical services to load/drop data via ZooKeeper, but the Historical services are completely unaware of the Coordinator."}),"\n",(0,o.jsx)(t.p,{children:"Brokers also never contact the Coordinator. Brokers base their understanding of the data topology on metadata exposed by the Historical services via ZooKeeper and are completely unaware of the Coordinator."}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Does it matter if the Coordinator service starts up before or after other services?"})}),"\n",(0,o.jsx)(t.p,{children:"No. If the Coordinator is not started up, no new segments will be loaded in the cluster and outdated segments will not be dropped. However, the Coordinator service can be started up at any time, and after a configurable delay, will start running Coordinator tasks."}),"\n",(0,o.jsx)(t.p,{children:"This also means that if you have a working cluster and all of your Coordinators die, the cluster will continue to function, it just won\u2019t experience any changes to its data topology."}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}}}]);