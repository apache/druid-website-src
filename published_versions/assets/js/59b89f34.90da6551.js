"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6527],{28453:(e,t,s)=>{s.d(t,{R:()=>r,x:()=>i});var a=s(96540);const n={},o=a.createContext(n);function r(e){const t=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),a.createElement(o.Provider,{value:t},e.children)}},80746:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>u,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"comparisons/druid-vs-key-value","title":"Apache Druid vs. Key/Value Stores (HBase/Cassandra/OpenTSDB)","description":"\x3c!--","source":"@site/docs/32.0.0/comparisons/druid-vs-key-value.md","sourceDirName":"comparisons","slug":"/comparisons/druid-vs-key-value","permalink":"/docs/32.0.0/comparisons/druid-vs-key-value","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"druid-vs-key-value","title":"Apache Druid vs. Key/Value Stores (HBase/Cassandra/OpenTSDB)"}}');var n=s(74848),o=s(28453);const r={id:"druid-vs-key-value",title:"Apache Druid vs. Key/Value Stores (HBase/Cassandra/OpenTSDB)"},i=void 0,u={},l=[];function c(e){const t={li:"li",ol:"ol",p:"p",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"Druid is highly optimized for scans and aggregations, it supports arbitrarily deep drill downs into data sets. This same functionality\nis supported in key/value stores in 2 ways:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"Pre-compute all permutations of possible user queries"}),"\n",(0,n.jsx)(t.li,{children:"Range scans on event data"}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"When pre-computing results, the key is the exact parameters of the query, and the value is the result of the query.\nThe queries return extremely quickly, but at the cost of flexibility, as ad-hoc exploratory queries are not possible with\npre-computing every possible query permutation. Pre-computing all permutations of all ad-hoc queries leads to result sets\nthat grow exponentially with the number of columns of a data set, and pre-computing queries for complex real-world data sets\ncan require hours of pre-processing time."}),"\n",(0,n.jsx)(t.p,{children:"The other approach to using key/value stores for aggregations to use the dimensions of an event as the key and the event measures as the value.\nAggregations are done by issuing range scans on this data. Timeseries specific databases such as OpenTSDB use this approach.\nOne of the limitations here is that the key/value storage model does not have indexes for any kind of filtering other than prefix ranges,\nwhich can be used to filter a query down to a metric and time range, but cannot resolve complex predicates to narrow the exact data to scan.\nWhen the number of rows to scan gets large, this limitation can greatly reduce performance. It is also harder to achieve good\nlocality with key/value stores because most don\u2019t support pushing down aggregates to the storage layer."}),"\n",(0,n.jsx)(t.p,{children:"For arbitrary exploration of data (flexible data filtering), Druid's custom column format enables ad-hoc queries without pre-computation. The format\nalso enables fast scans on columns, which is important for good aggregation performance."})]})}function d(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}}}]);