"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[5780],{28453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>r});var t=i(96540);const s={},a=t.createContext(s);function l(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(a.Provider,{value:n},e.children)}},65103:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>u,frontMatter:()=>l,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"querying/multi-value-dimensions","title":"Multi-value dimensions","description":"\x3c!--","source":"@site/docs/32.0.0/querying/multi-value-dimensions.md","sourceDirName":"querying","slug":"/querying/multi-value-dimensions","permalink":"/docs/32.0.0/querying/multi-value-dimensions","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"multi-value-dimensions","title":"Multi-value dimensions"},"sidebar":"docs","previous":{"title":"Apache Kafka Lookups","permalink":"/docs/32.0.0/querying/kafka-extraction-namespace"},"next":{"title":"Arrays","permalink":"/docs/32.0.0/querying/arrays"}}');var s=i(74848),a=i(28453);const l={id:"multi-value-dimensions",title:"Multi-value dimensions"},r=void 0,o={},d=[{value:"Ingestion",id:"ingestion",level:2},{value:"Native batch and streaming ingestion",id:"native-batch-and-streaming-ingestion",level:3},{value:"SQL-based ingestion",id:"sql-based-ingestion",level:3},{value:"SQL-based ingestion with rollup",id:"sql-based-ingestion-with-rollup",level:3},{value:"Querying multi-value dimensions",id:"querying-multi-value-dimensions",level:2},{value:"Filtering",id:"filtering",level:3},{value:"Grouping",id:"grouping",level:3},{value:"Example: SQL grouping query with no filtering",id:"example-sql-grouping-query-with-no-filtering",level:4},{value:"Example: SQL grouping query with a filter",id:"example-sql-grouping-query-with-a-filter",level:4},{value:"Example: native GroupBy query with no filtering",id:"example-native-groupby-query-with-no-filtering",level:4},{value:"Example: native GroupBy query with a selector query filter",id:"example-native-groupby-query-with-a-selector-query-filter",level:4},{value:"Example: native GroupBy query with selector query and dimension filters",id:"example-native-groupby-query-with-selector-query-and-dimension-filters",level:4},{value:"Disable GroupBy on multi-value columns",id:"disable-groupby-on-multi-value-columns",level:2},{value:"Differences between arrays and multi-value dimensions",id:"differences-between-arrays-and-multi-value-dimensions",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:['Apache Druid supports "multi-value" string dimensions. Multi-value string dimensions result from input fields that contain an\narray of values instead of a single value, such as the ',(0,s.jsx)(n.code,{children:"tags"})," values in the following JSON array example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'{"timestamp": "2011-01-12T00:00:00.000Z", "tags": ["t1","t2","t3"]} \n'})}),"\n",(0,s.jsxs)(n.p,{children:["It is important to be aware that multi-value dimensions are distinct from ",(0,s.jsx)(n.a,{href:"/docs/32.0.0/querying/arrays",children:"array types"}),". While array types behave like standard SQL arrays, multi-value dimensions do not. This document describes the behavior of multi-value dimensions, and some additional details can be found in the ",(0,s.jsx)(n.a,{href:"/docs/32.0.0/querying/sql-data-types#multi-value-strings-behavior",children:"SQL data type documentation"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["This document describes inserting, filtering, and grouping behavior for multi-value dimensions. For information about the internal representation of multi-value dimensions, see\n",(0,s.jsx)(n.a,{href:"/docs/32.0.0/design/segments#multi-value-columns",children:"segments documentation"}),". Examples in this document\nare in the form of both ",(0,s.jsx)(n.a,{href:"/docs/32.0.0/querying/sql",children:"SQL"})," and ",(0,s.jsx)(n.a,{href:"/docs/32.0.0/querying/",children:"native Druid queries"}),". Refer to the ",(0,s.jsx)(n.a,{href:"/docs/32.0.0/querying/sql-multivalue-string-functions",children:"Druid SQL documentation"})," for details\nabout the functions available for using multi-value string dimensions in SQL."]}),"\n",(0,s.jsxs)(n.p,{children:["The following sections describe inserting, filtering, and grouping behavior based on the following example data, which includes a multi-value dimension, ",(0,s.jsx)(n.code,{children:"tags"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:"lines",children:'{"timestamp": "2011-01-12T00:00:00.000Z", "label": "row1", "tags": ["t1","t2","t3"]}\n{"timestamp": "2011-01-13T00:00:00.000Z", "label": "row2", "tags": ["t3","t4","t5"]}\n{"timestamp": "2011-01-14T00:00:00.000Z", "label": "row3", "tags": ["t5","t6","t7"]}\n{"timestamp": "2011-01-14T00:00:00.000Z", "label": "row4", "tags": []}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"ingestion",children:"Ingestion"}),"\n",(0,s.jsx)(n.h3,{id:"native-batch-and-streaming-ingestion",children:"Native batch and streaming ingestion"}),"\n",(0,s.jsxs)(n.p,{children:["When using native ",(0,s.jsx)(n.a,{href:"/docs/32.0.0/ingestion/native-batch",children:"batch"})," or streaming ingestion such as with ",(0,s.jsx)(n.a,{href:"/docs/32.0.0/ingestion/kafka-ingestion",children:"Apache Kafka"}),", the Druid web console data loader can detect multi-value dimensions and configure the ",(0,s.jsx)(n.code,{children:"dimensionsSpec"})," accordingly."]}),"\n",(0,s.jsxs)(n.p,{children:["For TSV or CSV data, you can specify the multi-value delimiters using the ",(0,s.jsx)(n.code,{children:"listDelimiter"})," field in the ",(0,s.jsx)(n.code,{children:"inputFormat"}),". JSON data must be formatted as a JSON array to be ingested as a multi-value dimension. JSON data does not require ",(0,s.jsx)(n.code,{children:"inputFormat"})," configuration."]}),"\n",(0,s.jsxs)(n.p,{children:["The following shows an example ",(0,s.jsx)(n.code,{children:"dimensionsSpec"})," for native ingestion of the data used in this document:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'"dimensions": [\n  {\n    "type": "string",\n    "name": "label"\n  },\n  {\n    "type": "string",\n    "name": "tags",\n    "multiValueHandling": "SORTED_ARRAY",\n    "createBitmapIndex": true\n  }\n],\n'})}),"\n",(0,s.jsxs)(n.p,{children:["By default, Druid sorts values in multi-value dimensions. This behavior is controlled by the ",(0,s.jsx)(n.code,{children:"SORTED_ARRAY"})," value of the ",(0,s.jsx)(n.code,{children:"multiValueHandling"})," field. Alternatively, you can specify multi-value handling as:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"SORTED_SET"}),": results in the removal of duplicate values"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ARRAY"}),": retains the original order of the values"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/docs/32.0.0/ingestion/ingestion-spec#dimension-objects",children:"Dimension Objects"})," for information on configuring multi-value handling."]}),"\n",(0,s.jsx)(n.h3,{id:"sql-based-ingestion",children:"SQL-based ingestion"}),"\n",(0,s.jsxs)(n.p,{children:["Multi-value dimensions can also be inserted with ",(0,s.jsx)(n.a,{href:"/docs/32.0.0/multi-stage-query/",children:"SQL-based ingestion"}),". The functions ",(0,s.jsx)(n.code,{children:"MV_TO_ARRAY"})," and ",(0,s.jsx)(n.code,{children:"ARRAY_TO_MV"})," can assist in converting ",(0,s.jsx)(n.code,{children:"VARCHAR"})," to ",(0,s.jsx)(n.code,{children:"VARCHAR ARRAY"})," and ",(0,s.jsx)(n.code,{children:"VARCHAR ARRAY"})," into ",(0,s.jsx)(n.code,{children:"VARCHAR"})," respectively. ",(0,s.jsx)(n.code,{children:"multiValueHandling"})," is not available when using the multi-stage query engine to insert data."]}),"\n",(0,s.jsx)(n.p,{children:"For example, to insert the data used in this document:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:'REPLACE INTO "mvd_example" OVERWRITE ALL\nWITH "ext" AS (\n  SELECT *\n  FROM TABLE(\n    EXTERN(\n      \'{"type":"inline","data":"{\\"timestamp\\": \\"2011-01-12T00:00:00.000Z\\", \\"label\\": \\"row1\\", \\"tags\\": [\\"t1\\",\\"t2\\",\\"t3\\"]}\\n{\\"timestamp\\": \\"2011-01-13T00:00:00.000Z\\", \\"label\\": \\"row2\\", \\"tags\\": [\\"t3\\",\\"t4\\",\\"t5\\"]}\\n{\\"timestamp\\": \\"2011-01-14T00:00:00.000Z\\", \\"label\\": \\"row3\\", \\"tags\\": [\\"t5\\",\\"t6\\",\\"t7\\"]}\\n{\\"timestamp\\": \\"2011-01-14T00:00:00.000Z\\", \\"label\\": \\"row4\\", \\"tags\\": []}"}\',\n      \'{"type":"json"}\',\n      \'[{"name":"timestamp", "type":"STRING"},{"name":"label", "type":"STRING"},{"name":"tags", "type":"ARRAY<STRING>"}]\'\n    )\n  )\n)\nSELECT\n  TIME_PARSE("timestamp") AS "__time",\n  "label",\n  ARRAY_TO_MV("tags") AS "tags"\nFROM "ext"\nPARTITIONED BY DAY\n'})}),"\n",(0,s.jsx)(n.h3,{id:"sql-based-ingestion-with-rollup",children:"SQL-based ingestion with rollup"}),"\n",(0,s.jsx)(n.p,{children:"These input arrays can also be grouped prior to converting into a multi-value dimension:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:'REPLACE INTO "mvd_example_rollup" OVERWRITE ALL\nWITH "ext" AS (\n  SELECT *\n  FROM TABLE(\n    EXTERN(\n      \'{"type":"inline","data":"{\\"timestamp\\": \\"2011-01-12T00:00:00.000Z\\", \\"label\\": \\"row1\\", \\"tags\\": [\\"t1\\",\\"t2\\",\\"t3\\"]}\\n{\\"timestamp\\": \\"2011-01-13T00:00:00.000Z\\", \\"label\\": \\"row2\\", \\"tags\\": [\\"t3\\",\\"t4\\",\\"t5\\"]}\\n{\\"timestamp\\": \\"2011-01-14T00:00:00.000Z\\", \\"label\\": \\"row3\\", \\"tags\\": [\\"t5\\",\\"t6\\",\\"t7\\"]}\\n{\\"timestamp\\": \\"2011-01-14T00:00:00.000Z\\", \\"label\\": \\"row4\\", \\"tags\\": []}"}\',\n      \'{"type":"json"}\',\n      \'[{"name":"timestamp", "type":"STRING"},{"name":"label", "type":"STRING"},{"name":"tags", "type":"ARRAY<STRING>"}]\'\n    )\n  )\n)\nSELECT\n  TIME_PARSE("timestamp") AS "__time",\n  "label",\n  ARRAY_TO_MV("tags") AS "tags",\n  COUNT(*) AS "count"\nFROM "ext"\nGROUP BY 1, 2, "tags"\nPARTITIONED BY DAY\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Notice that ",(0,s.jsx)(n.code,{children:"ARRAY_TO_MV"})," is not present in the ",(0,s.jsx)(n.code,{children:"GROUP BY"})," clause since we only wish to coerce the type ",(0,s.jsx)(n.em,{children:"after"})," grouping."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"EXTERN"})," is also able to refer to the ",(0,s.jsx)(n.code,{children:"tags"})," input type as ",(0,s.jsx)(n.code,{children:"VARCHAR"}),", which is also how a query on a Druid table containing a multi-value dimension would specify the type of the ",(0,s.jsx)(n.code,{children:"tags"})," column. If this is the case you must use ",(0,s.jsx)(n.code,{children:"MV_TO_ARRAY"})," since the multi-stage query engine only supports grouping on multi-value dimensions as arrays. So, they must be coerced first. These arrays must then be coerced back into ",(0,s.jsx)(n.code,{children:"VARCHAR"})," in the ",(0,s.jsx)(n.code,{children:"SELECT"})," part of the statement with ",(0,s.jsx)(n.code,{children:"ARRAY_TO_MV"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:'REPLACE INTO "mvd_example_rollup" OVERWRITE ALL\nWITH "ext" AS (\n  SELECT *\n  FROM TABLE(\n    EXTERN(\n      \'{"type":"inline","data":"{\\"timestamp\\": \\"2011-01-12T00:00:00.000Z\\", \\"label\\": \\"row1\\", \\"tags\\": [\\"t1\\",\\"t2\\",\\"t3\\"]}\\n{\\"timestamp\\": \\"2011-01-13T00:00:00.000Z\\", \\"label\\": \\"row2\\", \\"tags\\": [\\"t3\\",\\"t4\\",\\"t5\\"]}\\n{\\"timestamp\\": \\"2011-01-14T00:00:00.000Z\\", \\"label\\": \\"row3\\", \\"tags\\": [\\"t5\\",\\"t6\\",\\"t7\\"]}\\n{\\"timestamp\\": \\"2011-01-14T00:00:00.000Z\\", \\"label\\": \\"row4\\", \\"tags\\": []}"}\',\n      \'{"type":"json"}\'\n    )\n  ) EXTEND ("timestamp" VARCHAR, "label" VARCHAR, "tags" VARCHAR)\n)\nSELECT\n  TIME_PARSE("timestamp") AS "__time",\n  "label",\n  ARRAY_TO_MV(MV_TO_ARRAY("tags")) AS "tags",\n  COUNT(*) AS "count"\nFROM "ext"\nGROUP BY 1, 2, MV_TO_ARRAY("tags")\nPARTITIONED BY DAY\n'})}),"\n",(0,s.jsx)(n.h2,{id:"querying-multi-value-dimensions",children:"Querying multi-value dimensions"}),"\n",(0,s.jsx)(n.h3,{id:"filtering",children:"Filtering"}),"\n",(0,s.jsxs)(n.p,{children:["All query types, as well as ",(0,s.jsx)(n.a,{href:"/docs/32.0.0/querying/aggregations#filtered-aggregator",children:"filtered aggregators"}),", can filter on multi-value\ndimensions. Filters follow these rules on multi-value dimensions:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'Value filters (like "selector", "bound", and "in") match a row if any of the values of a multi-value dimension match\nthe filter.'}),"\n",(0,s.jsx)(n.li,{children:"The Column Comparison filter will match a row if the dimensions have any overlap."}),"\n",(0,s.jsxs)(n.li,{children:["Value filters that match ",(0,s.jsx)(n.code,{children:"null"})," or ",(0,s.jsx)(n.code,{children:'""'})," (empty string) will match empty cells in a multi-value dimension."]}),"\n",(0,s.jsx)(n.li,{children:'Logical expression filters behave the same way they do on single-value dimensions: "and" matches a row if all\nunderlying filters match that row; "or" matches a row if any underlying filters match that row; "not" matches a row\nif the underlying filter does not match the row.'}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:'The following example illustrates these rules. This query applies an "or" filter to match row1 and row2 of the dataset above, but not row3:'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SELECT *\nFROM \"mvd_example_rollup\"\nWHERE tags = 't1' OR tags = 't3'\n"})}),"\n",(0,s.jsx)(n.p,{children:"returns"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:"lines",children:'{"__time":"2011-01-12T00:00:00.000Z","label":"row1","tags":"[\\"t1\\",\\"t2\\",\\"t3\\"]","count":1}\n{"__time":"2011-01-13T00:00:00.000Z","label":"row2","tags":"[\\"t3\\",\\"t4\\",\\"t5\\"]","count":1}\n'})}),"\n",(0,s.jsx)(n.p,{children:'Native queries can also perform filtering that would be considered a "contradiction" in SQL, such as this "and" filter which would match only row1 of the dataset above:'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'{\n  "type": "and",\n  "fields": [\n    {\n      "type": "selector",\n      "dimension": "tags",\n      "value": "t1"\n    },\n    {\n      "type": "selector",\n      "dimension": "tags",\n      "value": "t3"\n    }\n  ]\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"which returns"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:"lines",children:'{"__time":"2011-01-12T00:00:00.000Z","label":"row1","tags":"[\\"t1\\",\\"t2\\",\\"t3\\"]","count":1}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Multi-value dimensions also consider an empty row as ",(0,s.jsx)(n.code,{children:"null"}),", consider:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:'SELECT *\nFROM "mvd_example_rollup"\nWHERE tags is null\n'})}),"\n",(0,s.jsx)(n.p,{children:"which results in:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:"lines",children:'{"__time":"2011-01-14T00:00:00.000Z","label":"row4","tags":null,"count":1}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"grouping",children:"Grouping"}),"\n",(0,s.jsxs)(n.p,{children:["When grouping on a multi-value dimension with SQL or a native ",(0,s.jsx)(n.a,{href:"/docs/32.0.0/querying/topnquery",children:"topN"})," or ",(0,s.jsx)(n.a,{href:"/docs/32.0.0/querying/groupbyquery",children:"groupBy"})," queries, ",(0,s.jsx)(n.em,{children:"all"})," values\nfrom matching rows will be used to generate one group per value. This behaves similarly to an implicit SQL ",(0,s.jsx)(n.code,{children:"UNNEST"}),"\noperation. This means it's possible for a query to return more groups than there are rows. For example, a topN on the\ndimension ",(0,s.jsx)(n.code,{children:"tags"})," with filter ",(0,s.jsx)(n.code,{children:'"t1" AND "t3"'})," would match only row1, and generate a result with three groups:\n",(0,s.jsx)(n.code,{children:"t1"}),", ",(0,s.jsx)(n.code,{children:"t2"}),", and ",(0,s.jsx)(n.code,{children:"t3"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If you only need to include values that match your filter, you can use the SQL functions ",(0,s.jsxs)(n.a,{href:"/docs/32.0.0/querying/sql-multivalue-string-functions",children:[(0,s.jsx)(n.code,{children:"MV_FILTER_ONLY"}),"/",(0,s.jsx)(n.code,{children:"MV_FILTER_NONE"})]}),",\n",(0,s.jsx)(n.a,{href:"/docs/32.0.0/querying/virtual-columns#list-filtered-virtual-column",children:"filtered virtual column"}),", or ",(0,s.jsx)(n.a,{href:"/docs/32.0.0/querying/dimensionspecs#filtered-dimensionspecs",children:"filtered dimensionSpec"}),". This can also improve performance."]}),"\n",(0,s.jsx)(n.h4,{id:"example-sql-grouping-query-with-no-filtering",children:"Example: SQL grouping query with no filtering"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:'SELECT label, tags\nFROM "mvd_example_rollup"\nGROUP BY 1,2\n'})}),"\n",(0,s.jsx)(n.p,{children:"results in:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:"lines",children:'{"label":"row1","tags":"t1"}\n{"label":"row1","tags":"t2"}\n{"label":"row1","tags":"t3"}\n{"label":"row2","tags":"t3"}\n{"label":"row2","tags":"t4"}\n{"label":"row2","tags":"t5"}\n{"label":"row3","tags":"t5"}\n{"label":"row3","tags":"t6"}\n{"label":"row3","tags":"t7"}\n{"label":"row4","tags":null}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"example-sql-grouping-query-with-a-filter",children:"Example: SQL grouping query with a filter"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SELECT label, tags\nFROM \"mvd_example_rollup\"\nWHERE tags = 't3'\nGROUP BY 1,2\n"})}),"\n",(0,s.jsx)(n.p,{children:"results:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:"lines",children:'{"label":"row1","tags":"t1"}\n{"label":"row1","tags":"t2"}\n{"label":"row1","tags":"t3"}\n{"label":"row2","tags":"t3"}\n{"label":"row2","tags":"t4"}\n{"label":"row2","tags":"t5"}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"example-native-groupby-query-with-no-filtering",children:"Example: native GroupBy query with no filtering"}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/docs/32.0.0/querying/groupbyquery",children:"GroupBy querying"})," for details."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "queryType": "groupBy",\n  "dataSource": "test",\n  "intervals": [\n    "1970-01-01T00:00:00.000Z/3000-01-01T00:00:00.000Z"\n  ],\n  "granularity": {\n    "type": "all"\n  },\n  "dimensions": [\n    {\n      "type": "default",\n      "dimension": "tags",\n      "outputName": "tags"\n    }\n  ],\n  "aggregations": [\n    {\n      "type": "count",\n      "name": "count"\n    }\n  ]\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"This query returns the following result:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'[\n  {\n    "timestamp": "1970-01-01T00:00:00.000Z",\n    "event": {\n      "count": 1,\n      "tags": "t1"\n    }\n  },\n  {\n    "timestamp": "1970-01-01T00:00:00.000Z",\n    "event": {\n      "count": 1,\n      "tags": "t2"\n    }\n  },\n  {\n    "timestamp": "1970-01-01T00:00:00.000Z",\n    "event": {\n      "count": 2,\n      "tags": "t3"\n    }\n  },\n  {\n    "timestamp": "1970-01-01T00:00:00.000Z",\n    "event": {\n      "count": 1,\n      "tags": "t4"\n    }\n  },\n  {\n    "timestamp": "1970-01-01T00:00:00.000Z",\n    "event": {\n      "count": 2,\n      "tags": "t5"\n    }\n  },\n  {\n    "timestamp": "1970-01-01T00:00:00.000Z",\n    "event": {\n      "count": 1,\n      "tags": "t6"\n    }\n  },\n  {\n    "timestamp": "1970-01-01T00:00:00.000Z",\n    "event": {\n      "count": 1,\n      "tags": "t7"\n    }\n  }\n]\n'})}),"\n",(0,s.jsx)(n.p,{children:'Notice that original rows are "exploded" into multiple rows and merged.'}),"\n",(0,s.jsx)(n.h4,{id:"example-native-groupby-query-with-a-selector-query-filter",children:"Example: native GroupBy query with a selector query filter"}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/docs/32.0.0/querying/filters",children:"query filters"})," for details of selector query filter."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "queryType": "groupBy",\n  "dataSource": "test",\n  "intervals": [\n    "1970-01-01T00:00:00.000Z/3000-01-01T00:00:00.000Z"\n  ],\n  "filter": {\n    "type": "selector",\n    "dimension": "tags",\n    "value": "t3"\n  },\n  "granularity": {\n    "type": "all"\n  },\n  "dimensions": [\n    {\n      "type": "default",\n      "dimension": "tags",\n      "outputName": "tags"\n    }\n  ],\n  "aggregations": [\n    {\n      "type": "count",\n      "name": "count"\n    }\n  ]\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"This query returns the following result:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'[\n  {\n    "timestamp": "1970-01-01T00:00:00.000Z",\n    "event": {\n      "count": 1,\n      "tags": "t1"\n    }\n  },\n  {\n    "timestamp": "1970-01-01T00:00:00.000Z",\n    "event": {\n      "count": 1,\n      "tags": "t2"\n    }\n  },\n  {\n    "timestamp": "1970-01-01T00:00:00.000Z",\n    "event": {\n      "count": 2,\n      "tags": "t3"\n    }\n  },\n  {\n    "timestamp": "1970-01-01T00:00:00.000Z",\n    "event": {\n      "count": 1,\n      "tags": "t4"\n    }\n  },\n  {\n    "timestamp": "1970-01-01T00:00:00.000Z",\n    "event": {\n      "count": 1,\n      "tags": "t5"\n    }\n  }\n]\n'})}),"\n",(0,s.jsx)(n.p,{children:'You might be surprised to see "t1", "t2", "t4" and "t5" included in the results. This is because the query filter is\napplied on the row before explosion. For multi-value dimensions, a filter for value "t3" would match row1 and row2,\nafter which exploding is done. For multi-value dimensions, a query filter matches a row if any individual value inside\nthe multiple values matches the query filter.'}),"\n",(0,s.jsx)(n.h4,{id:"example-native-groupby-query-with-selector-query-and-dimension-filters",children:"Example: native GroupBy query with selector query and dimension filters"}),"\n",(0,s.jsx)(n.p,{children:'To solve the problem above and to get only rows for "t3", use a "filtered dimension spec", as in the query below.'}),"\n",(0,s.jsxs)(n.p,{children:["See filtered ",(0,s.jsx)(n.code,{children:"dimensionSpecs"})," in ",(0,s.jsx)(n.a,{href:"/docs/32.0.0/querying/dimensionspecs#filtered-dimensionspecs",children:"dimensionSpecs"})," for details."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "queryType": "groupBy",\n  "dataSource": "test",\n  "intervals": [\n    "1970-01-01T00:00:00.000Z/3000-01-01T00:00:00.000Z"\n  ],\n  "filter": {\n    "type": "selector",\n    "dimension": "tags",\n    "value": "t3"\n  },\n  "granularity": {\n    "type": "all"\n  },\n  "dimensions": [\n    {\n      "type": "listFiltered",\n      "delegate": {\n        "type": "default",\n        "dimension": "tags",\n        "outputName": "tags"\n      },\n      "values": ["t3"]\n    }\n  ],\n  "aggregations": [\n    {\n      "type": "count",\n      "name": "count"\n    }\n  ]\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"This query returns the following result:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'[\n  {\n    "timestamp": "1970-01-01T00:00:00.000Z",\n    "event": {\n      "count": 2,\n      "tags": "t3"\n    }\n  }\n]\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Note that, for groupBy queries, you could get similar result with a ",(0,s.jsx)(n.a,{href:"/docs/32.0.0/querying/having",children:"having spec"})," but using a filtered\n",(0,s.jsx)(n.code,{children:"dimensionSpec"})," is much more efficient because that gets applied at the lowest level in the query processing pipeline.\nHaving specs are applied at the outermost level of groupBy query processing."]}),"\n",(0,s.jsx)(n.h2,{id:"disable-groupby-on-multi-value-columns",children:"Disable GroupBy on multi-value columns"}),"\n",(0,s.jsxs)(n.p,{children:["You can disable the implicit unnesting behavior for groupBy by setting ",(0,s.jsx)(n.code,{children:"groupByEnableMultiValueUnnesting: false"})," in your\n",(0,s.jsx)(n.a,{href:"/docs/32.0.0/querying/query-context",children:"query context"}),". In this mode, the groupBy engine will return an error instead of completing the query. This is a safety\nfeature for situations where you believe that all dimensions are singly-valued and want the engine to reject any\nmulti-valued dimensions that were inadvertently included."]}),"\n",(0,s.jsx)(n.h2,{id:"differences-between-arrays-and-multi-value-dimensions",children:"Differences between arrays and multi-value dimensions"}),"\n",(0,s.jsxs)(n.p,{children:["Avoid confusing string arrays with ",(0,s.jsx)(n.a,{href:"/docs/32.0.0/querying/multi-value-dimensions",children:"multi-value dimensions"}),". Arrays and multi-value dimensions are stored in different column types, and query behavior is different. You can use the functions ",(0,s.jsx)(n.code,{children:"MV_TO_ARRAY"})," and ",(0,s.jsx)(n.code,{children:"ARRAY_TO_MV"})," to convert between the two if needed. In general, we recommend using arrays whenever possible, since they are a newer and more powerful feature and have SQL compliant behavior."]}),"\n",(0,s.jsx)(n.p,{children:"Use care during ingestion to ensure you get the type you want."}),"\n",(0,s.jsxs)(n.p,{children:["To get arrays when performing an ingestion using JSON ingestion specs, such as ",(0,s.jsx)(n.a,{href:"/docs/32.0.0/ingestion/native-batch",children:"native batch"})," or streaming ingestion such as with ",(0,s.jsx)(n.a,{href:"/docs/32.0.0/ingestion/kafka-ingestion",children:"Apache Kafka"}),", use dimension type ",(0,s.jsx)(n.code,{children:"auto"})," or enable ",(0,s.jsx)(n.code,{children:"useSchemaDiscovery"}),". When performing a ",(0,s.jsx)(n.a,{href:"/docs/32.0.0/multi-stage-query/",children:"SQL-based ingestion"}),", write a query that generates arrays. Arrays may contain strings or numbers."]}),"\n",(0,s.jsxs)(n.p,{children:["To get multi-value dimensions when performing an ingestion using JSON ingestion specs, use dimension type ",(0,s.jsx)(n.code,{children:"string"})," and do not enable ",(0,s.jsx)(n.code,{children:"useSchemaDiscovery"}),". When performing a ",(0,s.jsx)(n.a,{href:"/docs/32.0.0/multi-stage-query/",children:"SQL-based ingestion"}),", wrap arrays in ",(0,s.jsx)(n.a,{href:"/docs/32.0.0/querying/multi-value-dimensions#sql-based-ingestion",children:(0,s.jsx)(n.code,{children:"ARRAY_TO_MV"})}),". Multi-value dimensions can only contain strings."]}),"\n",(0,s.jsxs)(n.p,{children:["You can tell which type you have by checking the ",(0,s.jsx)(n.code,{children:"INFORMATION_SCHEMA.COLUMNS"})," table, using a query like:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SELECT COLUMN_NAME, DATA_TYPE\nFROM INFORMATION_SCHEMA.COLUMNS\nWHERE TABLE_NAME = 'mytable'\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Arrays are type ",(0,s.jsx)(n.code,{children:"ARRAY"}),", multi-value strings are type ",(0,s.jsx)(n.code,{children:"VARCHAR"}),"."]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);