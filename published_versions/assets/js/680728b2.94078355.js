"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9332],{27104:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"querying/granularities","title":"Query granularities","description":"\x3c!--","source":"@site/docs/33.0.0/querying/granularities.md","sourceDirName":"querying","slug":"/querying/granularities","permalink":"/docs/33.0.0/querying/granularities","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"granularities","title":"Query granularities","sidebar_label":"Granularities"},"sidebar":"docs","previous":{"title":"Filters","permalink":"/docs/33.0.0/querying/filters"},"next":{"title":"Dimensions","permalink":"/docs/33.0.0/querying/dimensionspecs"}}');var a=i(74848),r=i(28453);const s={id:"granularities",title:"Query granularities",sidebar_label:"Granularities"},l=void 0,o={},c=[{value:"Simple Granularities",id:"simple-granularities",level:3},{value:"Example:",id:"example",level:4},{value:"Duration Granularities",id:"duration-granularities",level:3},{value:"Example:",id:"example-1",level:4},{value:"Period Granularities",id:"period-granularities",level:3},{value:"Example",id:"example-2",level:4},{value:"Supported Time Zones",id:"supported-time-zones",level:4}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.p,{children:["Apache Druid supports two query languages: ",(0,a.jsx)(n.a,{href:"/docs/33.0.0/querying/sql",children:"Druid SQL"})," and ",(0,a.jsx)(n.a,{href:"/docs/33.0.0/querying/",children:"native queries"}),".\nThis document describes the native\nlanguage. For information about time functions available in SQL, refer to the\n",(0,a.jsx)(n.a,{href:"/docs/33.0.0/querying/sql-scalar#date-and-time-functions",children:"SQL documentation"}),"."]})}),"\n",(0,a.jsxs)(n.p,{children:["Granularity determines how to bucket data across the time dimension, or how to aggregate data by hour, day, minute, etc and defines how it is stored.\nThe granularity formats here apply also to ",(0,a.jsx)(n.code,{children:"segmentGranularity"})," and ",(0,a.jsx)(n.code,{children:"queryGranularity"})," in the ",(0,a.jsx)(n.code,{children:"granularitySpec"})," section of the the ",(0,a.jsx)(n.a,{href:"/docs/33.0.0/ingestion/ingestion-spec#granularityspec",children:"ingestion spec"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["For example, use time granularities in ",(0,a.jsx)(n.a,{href:"/docs/33.0.0/querying/",children:"native queries"})," to bucket results by time, and in the ",(0,a.jsx)(n.code,{children:"dataSchema"})," \\ ",(0,a.jsx)(n.a,{href:"/docs/33.0.0/ingestion/ingestion-spec#granularityspec",children:(0,a.jsx)(n.code,{children:"granularitySpec"})})," section of ingestion specifications to segment incoming data."]}),"\n",(0,a.jsxs)(n.p,{children:["You can specify a time period as a ",(0,a.jsx)(n.a,{href:"#simple-granularities",children:"simple"})," string, as a ",(0,a.jsx)(n.a,{href:"#duration-granularities",children:"duration"})," in milliseconds, or as an arbitrary ISO8601 ",(0,a.jsx)(n.a,{href:"#period-granularities",children:"period"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"simple-granularities",children:"Simple Granularities"}),"\n",(0,a.jsx)(n.p,{children:"Simple granularities are specified as a string and bucket timestamps by their UTC time (e.g., days start at 00:00 UTC)."}),"\n",(0,a.jsx)(n.p,{children:"Druid supports the following granularity strings:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"all"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"none"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"second"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"minute"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"five_minute"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"ten_minute"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"fifteen_minute"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"thirty_minute"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"hour"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"six_hour"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"eight_hour"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"day"})}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"week"}),"*"]}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"month"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"quarter"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"year"})}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["The minimum and maximum granularities are ",(0,a.jsx)(n.code,{children:"none"})," and ",(0,a.jsx)(n.code,{children:"all"}),", described as follows:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"all"})," buckets everything into a single bucket."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"none"})," does not mean zero bucketing. It buckets data to millisecond granularity\u2014the granularity of the internal index. You can think of ",(0,a.jsx)(n.code,{children:"none"})," as equivalent to ",(0,a.jsx)(n.code,{children:"millisecond"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.p,{children:["Do not use ",(0,a.jsx)(n.code,{children:"none"})," in a ",(0,a.jsx)(n.a,{href:"/docs/33.0.0/querying/timeseriesquery",children:"timeseries query"}),"; Druid fills empty interior time buckets with zeroes, meaning the output will contain results for every single millisecond in the requested interval."]})}),"\n",(0,a.jsxs)(n.p,{children:["*Avoid using the ",(0,a.jsx)(n.code,{children:"week"})," granularity for partitioning at ingestion time, because weeks don't align neatly with months and years, making it difficult to partition by coarser granularities later."]}),"\n",(0,a.jsx)(n.h4,{id:"example",children:"Example:"}),"\n",(0,a.jsx)(n.p,{children:"Suppose you have data below stored in Apache Druid with millisecond ingestion granularity,"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{"timestamp": "2013-08-31T01:02:33Z", "page": "AAA", "language" : "en"}\n{"timestamp": "2013-09-01T01:02:33Z", "page": "BBB", "language" : "en"}\n{"timestamp": "2013-09-02T23:32:45Z", "page": "CCC", "language" : "en"}\n{"timestamp": "2013-09-03T03:32:45Z", "page": "DDD", "language" : "en"}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["After submitting a groupBy query with ",(0,a.jsx)(n.code,{children:"hour"})," granularity,"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n   "queryType":"groupBy",\n   "dataSource":"my_dataSource",\n   "granularity":"hour",\n   "dimensions":[\n      "language"\n   ],\n   "aggregations":[\n      {\n         "type":"count",\n         "name":"count"\n      }\n   ],\n   "intervals":[\n      "2000-01-01T00:00Z/3000-01-01T00:00Z"\n   ]\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"you will get"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'[ {\n  "version" : "v1",\n  "timestamp" : "2013-08-31T01:00:00.000Z",\n  "event" : {\n    "count" : 1,\n    "language" : "en"\n  }\n}, {\n  "version" : "v1",\n  "timestamp" : "2013-09-01T01:00:00.000Z",\n  "event" : {\n    "count" : 1,\n    "language" : "en"\n  }\n}, {\n  "version" : "v1",\n  "timestamp" : "2013-09-02T23:00:00.000Z",\n  "event" : {\n    "count" : 1,\n    "language" : "en"\n  }\n}, {\n  "version" : "v1",\n  "timestamp" : "2013-09-03T03:00:00.000Z",\n  "event" : {\n    "count" : 1,\n    "language" : "en"\n  }\n} ]\n'})}),"\n",(0,a.jsx)(n.p,{children:"Note that all the empty buckets are discarded."}),"\n",(0,a.jsxs)(n.p,{children:["If you change the granularity to ",(0,a.jsx)(n.code,{children:"day"}),", you will get"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'[ {\n  "version" : "v1",\n  "timestamp" : "2013-08-31T00:00:00.000Z",\n  "event" : {\n    "count" : 1,\n    "language" : "en"\n  }\n}, {\n  "version" : "v1",\n  "timestamp" : "2013-09-01T00:00:00.000Z",\n  "event" : {\n    "count" : 1,\n    "language" : "en"\n  }\n}, {\n  "version" : "v1",\n  "timestamp" : "2013-09-02T00:00:00.000Z",\n  "event" : {\n    "count" : 1,\n    "language" : "en"\n  }\n}, {\n  "version" : "v1",\n  "timestamp" : "2013-09-03T00:00:00.000Z",\n  "event" : {\n    "count" : 1,\n    "language" : "en"\n  }\n} ]\n'})}),"\n",(0,a.jsxs)(n.p,{children:["If you change the granularity to ",(0,a.jsx)(n.code,{children:"none"}),", you will get the same results as setting it to the ingestion granularity."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'[ {\n  "version" : "v1",\n  "timestamp" : "2013-08-31T01:02:33.000Z",\n  "event" : {\n    "count" : 1,\n    "language" : "en"\n  }\n}, {\n  "version" : "v1",\n  "timestamp" : "2013-09-01T01:02:33.000Z",\n  "event" : {\n    "count" : 1,\n    "language" : "en"\n  }\n}, {\n  "version" : "v1",\n  "timestamp" : "2013-09-02T23:32:45.000Z",\n  "event" : {\n    "count" : 1,\n    "language" : "en"\n  }\n}, {\n  "version" : "v1",\n  "timestamp" : "2013-09-03T03:32:45.000Z",\n  "event" : {\n    "count" : 1,\n    "language" : "en"\n  }\n} ]\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Having a query time ",(0,a.jsx)(n.code,{children:"granularity"})," that is smaller than the ",(0,a.jsx)(n.code,{children:"queryGranularity"})," parameter set at\n",(0,a.jsx)(n.a,{href:"/docs/33.0.0/ingestion/ingestion-spec#granularityspec",children:"ingestion time"})," is unreasonable because information about that\nsmaller granularity is not present in the indexed data. So, if the query time granularity is smaller than the ingestion\ntime query granularity, Druid produces results that are equivalent to having set ",(0,a.jsx)(n.code,{children:"granularity"})," to ",(0,a.jsx)(n.code,{children:"queryGranularity"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["If you change the granularity to ",(0,a.jsx)(n.code,{children:"all"}),", you will get everything aggregated in 1 bucket,"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'[ {\n  "version" : "v1",\n  "timestamp" : "2000-01-01T00:00:00.000Z",\n  "event" : {\n    "count" : 4,\n    "language" : "en"\n  }\n} ]\n'})}),"\n",(0,a.jsx)(n.h3,{id:"duration-granularities",children:"Duration Granularities"}),"\n",(0,a.jsx)(n.p,{children:"Duration granularities are specified as an exact duration in milliseconds and timestamps are returned as UTC. Duration granularity values are in millis."}),"\n",(0,a.jsx)(n.p,{children:"They also support specifying an optional origin, which defines where to start counting time buckets from (defaults to 1970-01-01T00:00:00Z)."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'{"type": "duration", "duration": 7200000}\n'})}),"\n",(0,a.jsx)(n.p,{children:"This chunks up every 2 hours."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'{"type": "duration", "duration": 3600000, "origin": "2012-01-01T00:30:00Z"}\n'})}),"\n",(0,a.jsx)(n.p,{children:"This chunks up every hour on the half-hour."}),"\n",(0,a.jsx)(n.h4,{id:"example-1",children:"Example:"}),"\n",(0,a.jsx)(n.p,{children:"Reusing the data in the previous example, after submitting a groupBy query with 24 hours duration,"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n   "queryType":"groupBy",\n   "dataSource":"my_dataSource",\n   "granularity":{"type": "duration", "duration": "86400000"},\n   "dimensions":[\n      "language"\n   ],\n   "aggregations":[\n      {\n         "type":"count",\n         "name":"count"\n      }\n   ],\n   "intervals":[\n      "2000-01-01T00:00Z/3000-01-01T00:00Z"\n   ]\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"you will get"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'[ {\n  "version" : "v1",\n  "timestamp" : "2013-08-31T00:00:00.000Z",\n  "event" : {\n    "count" : 1,\n    "language" : "en"\n  }\n}, {\n  "version" : "v1",\n  "timestamp" : "2013-09-01T00:00:00.000Z",\n  "event" : {\n    "count" : 1,\n    "language" : "en"\n  }\n}, {\n  "version" : "v1",\n  "timestamp" : "2013-09-02T00:00:00.000Z",\n  "event" : {\n    "count" : 1,\n    "language" : "en"\n  }\n}, {\n  "version" : "v1",\n  "timestamp" : "2013-09-03T00:00:00.000Z",\n  "event" : {\n    "count" : 1,\n    "language" : "en"\n  }\n} ]\n'})}),"\n",(0,a.jsxs)(n.p,{children:["if you set the origin for the granularity to ",(0,a.jsx)(n.code,{children:"2012-01-01T00:30:00Z"}),","]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'   "granularity":{"type": "duration", "duration": "86400000", "origin":"2012-01-01T00:30:00Z"}\n'})}),"\n",(0,a.jsx)(n.p,{children:"you will get"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'[ {\n  "version" : "v1",\n  "timestamp" : "2013-08-31T00:30:00.000Z",\n  "event" : {\n    "count" : 1,\n    "language" : "en"\n  }\n}, {\n  "version" : "v1",\n  "timestamp" : "2013-09-01T00:30:00.000Z",\n  "event" : {\n    "count" : 1,\n    "language" : "en"\n  }\n}, {\n  "version" : "v1",\n  "timestamp" : "2013-09-02T00:30:00.000Z",\n  "event" : {\n    "count" : 1,\n    "language" : "en"\n  }\n}, {\n  "version" : "v1",\n  "timestamp" : "2013-09-03T00:30:00.000Z",\n  "event" : {\n    "count" : 1,\n    "language" : "en"\n  }\n} ]\n'})}),"\n",(0,a.jsx)(n.p,{children:"Note that the timestamp for each bucket starts at the 30th minute."}),"\n",(0,a.jsx)(n.h3,{id:"period-granularities",children:"Period Granularities"}),"\n",(0,a.jsxs)(n.p,{children:["Period granularities are specified as arbitrary period combinations of years, months, weeks, hours, minutes and seconds (e.g. P2W, P3M, PT1H30M, PT0.750S) in ",(0,a.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/ISO_8601",children:"ISO8601"})," format. They support specifying a time zone which determines where period boundaries start as well as the timezone of the returned timestamps. By default, years start on the first of January, months start on the first of the month and weeks start on Mondays unless an origin is specified."]}),"\n",(0,a.jsx)(n.p,{children:"Time zone is optional (defaults to UTC). Origin is optional (defaults to 1970-01-01T00:00:00 in the given time zone)."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'{"type": "period", "period": "P2D", "timeZone": "America/Los_Angeles"}\n'})}),"\n",(0,a.jsx)(n.p,{children:"This will bucket by two-day chunks in the Pacific timezone."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'{"type": "period", "period": "P3M", "timeZone": "America/Los_Angeles", "origin": "2012-02-01T00:00:00-08:00"}\n'})}),"\n",(0,a.jsx)(n.p,{children:"This will bucket by 3-month chunks in the Pacific timezone where the three-month quarters are defined as starting from February."}),"\n",(0,a.jsx)(n.h4,{id:"example-2",children:"Example"}),"\n",(0,a.jsx)(n.p,{children:"Reusing the data in the previous example, if you submit a groupBy query with 1 day period in Pacific timezone,"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n   "queryType":"groupBy",\n   "dataSource":"my_dataSource",\n   "granularity":{"type": "period", "period": "P1D", "timeZone": "America/Los_Angeles"},\n   "dimensions":[\n      "language"\n   ],\n   "aggregations":[\n      {\n         "type":"count",\n         "name":"count"\n      }\n   ],\n   "intervals":[\n      "1999-12-31T16:00:00.000-08:00/2999-12-31T16:00:00.000-08:00"\n   ]\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"you will get"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'[ {\n  "version" : "v1",\n  "timestamp" : "2013-08-30T00:00:00.000-07:00",\n  "event" : {\n    "count" : 1,\n    "language" : "en"\n  }\n}, {\n  "version" : "v1",\n  "timestamp" : "2013-08-31T00:00:00.000-07:00",\n  "event" : {\n    "count" : 1,\n    "language" : "en"\n  }\n}, {\n  "version" : "v1",\n  "timestamp" : "2013-09-02T00:00:00.000-07:00",\n  "event" : {\n    "count" : 2,\n    "language" : "en"\n  }\n} ]\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Note that the timestamp for each bucket has been converted to Pacific time. Row ",(0,a.jsx)(n.code,{children:'{"timestamp": "2013-09-02T23:32:45Z", "page": "CCC", "language" : "en"}'})," and\n",(0,a.jsx)(n.code,{children:'{"timestamp": "2013-09-03T03:32:45Z", "page": "DDD", "language" : "en"}'})," are put in the same bucket because they are in the same day in Pacific time."]}),"\n",(0,a.jsxs)(n.p,{children:["Also note that the ",(0,a.jsx)(n.code,{children:"intervals"})," in groupBy query will not be converted to the timezone specified, the timezone specified in granularity is only applied on the\nquery results."]}),"\n",(0,a.jsxs)(n.p,{children:["If you set the origin for the granularity to ",(0,a.jsx)(n.code,{children:"1970-01-01T20:30:00-08:00"}),","]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'   "granularity":{"type": "period", "period": "P1D", "timeZone": "America/Los_Angeles", "origin": "1970-01-01T20:30:00-08:00"}\n'})}),"\n",(0,a.jsx)(n.p,{children:"you will get"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'[ {\n  "version" : "v1",\n  "timestamp" : "2013-08-29T20:30:00.000-07:00",\n  "event" : {\n    "count" : 1,\n    "language" : "en"\n  }\n}, {\n  "version" : "v1",\n  "timestamp" : "2013-08-30T20:30:00.000-07:00",\n  "event" : {\n    "count" : 1,\n    "language" : "en"\n  }\n}, {\n  "version" : "v1",\n  "timestamp" : "2013-09-01T20:30:00.000-07:00",\n  "event" : {\n    "count" : 1,\n    "language" : "en"\n  }\n}, {\n  "version" : "v1",\n  "timestamp" : "2013-09-02T20:30:00.000-07:00",\n  "event" : {\n    "count" : 1,\n    "language" : "en"\n  }\n} ]\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Note that the ",(0,a.jsx)(n.code,{children:"origin"})," you specified has nothing to do with the timezone, it only serves as a starting point for locating the very first granularity bucket.\nIn this case, Row ",(0,a.jsx)(n.code,{children:'{"timestamp": "2013-09-02T23:32:45Z", "page": "CCC", "language" : "en"}'})," and ",(0,a.jsx)(n.code,{children:'{"timestamp": "2013-09-03T03:32:45Z", "page": "DDD", "language" : "en"}'}),"\nare not in the same bucket."]}),"\n",(0,a.jsx)(n.h4,{id:"supported-time-zones",children:"Supported Time Zones"}),"\n",(0,a.jsxs)(n.p,{children:["Timezone support is provided by the ",(0,a.jsx)(n.a,{href:"http://www.joda.org",children:"Joda Time library"}),", which uses the standard IANA time zones. See the ",(0,a.jsx)(n.a,{href:"http://joda-time.sourceforge.net/timezones.html",children:"Joda Time supported timezones"}),"."]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>l});var t=i(96540);const a={},r=t.createContext(a);function s(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);