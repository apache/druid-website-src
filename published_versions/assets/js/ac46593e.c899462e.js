"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4871],{28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>d});var s=n(96540);const a={},i=s.createContext(a);function r(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:t},e.children)}},47355:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"data-management/delete","title":"Data deletion","description":"\x3c!--","source":"@site/docs/32.0.0/data-management/delete.md","sourceDirName":"data-management","slug":"/data-management/delete","permalink":"/docs/32.0.0/data-management/delete","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"delete","title":"Data deletion"},"sidebar":"docs","previous":{"title":"Data updates","permalink":"/docs/32.0.0/data-management/update"},"next":{"title":"Schema changes","permalink":"/docs/32.0.0/data-management/schema-changes"}}');var a=n(74848),i=n(28453);const r={id:"delete",title:"Data deletion"},d=void 0,l={},o=[{value:"By time range, manually",id:"by-time-range-manually",level:2},{value:"By time range, automatically",id:"by-time-range-automatically",level:2},{value:"Specific records",id:"specific-records",level:2},{value:"Entire table",id:"entire-table",level:2},{value:"Permanently (<code>kill</code> task)",id:"permanently-kill-task",level:2}];function c(e){const t={a:"a",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h2,{id:"by-time-range-manually",children:"By time range, manually"}),"\n",(0,a.jsxs)(t.p,{children:["Apache Druid stores data ",(0,a.jsx)(t.a,{href:"/docs/32.0.0/design/storage",children:"partitioned by time chunk"})," and supports\ndeleting data for time chunks by dropping segments. This is a fast, metadata-only operation."]}),"\n",(0,a.jsx)(t.p,{children:"Deletion by time range happens in two steps:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["Segments to be deleted must first be marked as ",(0,a.jsx)(t.a,{href:"/docs/32.0.0/design/storage#segment-lifecycle",children:'"unused"'}),". This can\nhappen when a segment is dropped by a ",(0,a.jsx)(t.a,{href:"/docs/32.0.0/operations/rule-configuration",children:"drop rule"})," or when you manually mark a\nsegment unused through the Coordinator API or web console. This is a soft delete: the data is not available for\nquerying, but the segment files remains in deep storage, and the segment records remains in the metadata store."]}),"\n",(0,a.jsxs)(t.li,{children:['Once a segment is marked "unused", you can use a ',(0,a.jsxs)(t.a,{href:"#kill-task",children:[(0,a.jsx)(t.code,{children:"kill"})," task"]})," to permanently delete the segment file from\ndeep storage and remove its record from the metadata store. This is a hard delete: the data is unrecoverable unless\nyou have a backup."]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["For documentation on disabling segments using the Coordinator API, see the\n",(0,a.jsx)(t.a,{href:"/docs/32.0.0/api-reference/legacy-metadata-api#datasources",children:"Legacy metadata API reference"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["A data deletion tutorial is available at ",(0,a.jsx)(t.a,{href:"/docs/32.0.0/tutorials/tutorial-delete-data",children:"Tutorial: Deleting data"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"by-time-range-automatically",children:"By time range, automatically"}),"\n",(0,a.jsxs)(t.p,{children:["Druid supports ",(0,a.jsx)(t.a,{href:"/docs/32.0.0/operations/rule-configuration",children:"load and drop rules"}),", which are used to define intervals of time\nwhere data should be preserved, and intervals where data should be discarded. Data that falls under a drop rule is\nmarked unused, in the same manner as if you ",(0,a.jsx)(t.a,{href:"#by-time-range-manually",children:"manually mark that time range unused"}),". This is a\nfast, metadata-only operation."]}),"\n",(0,a.jsxs)(t.p,{children:["Data that is dropped in this way is marked unused, but remains in deep storage. To permanently delete it, use a\n",(0,a.jsxs)(t.a,{href:"#kill-task",children:[(0,a.jsx)(t.code,{children:"kill"})," task"]}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"specific-records",children:"Specific records"}),"\n",(0,a.jsxs)(t.p,{children:["Druid supports deleting specific records using ",(0,a.jsx)(t.a,{href:"/docs/32.0.0/data-management/update#reindex",children:"reindexing"})," with a filter. The filter specifies which\ndata remains after reindexing, so it must be the inverse of the data you want to delete. Because segments must be\nrewritten to delete data in this way, it can be a time-consuming operation."]}),"\n",(0,a.jsxs)(t.p,{children:["For example, to delete records where ",(0,a.jsx)(t.code,{children:"userName"})," is ",(0,a.jsx)(t.code,{children:"'bob'"})," with native batch indexing, use a\n",(0,a.jsx)(t.a,{href:"/docs/32.0.0/ingestion/ingestion-spec#transformspec",children:(0,a.jsx)(t.code,{children:"transformSpec"})})," with filter ",(0,a.jsx)(t.code,{children:'{"type": "not", "field": {"type": "selector", "dimension": "userName", "value": "bob"}}'}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["To delete the same records using SQL, use ",(0,a.jsx)(t.a,{href:"/docs/32.0.0/multi-stage-query/concepts#replace",children:"REPLACE"})," with ",(0,a.jsx)(t.code,{children:"WHERE userName <> 'bob'"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["To reindex using ",(0,a.jsx)(t.a,{href:"/docs/32.0.0/ingestion/native-batch",children:"native batch"}),", use the ",(0,a.jsxs)(t.a,{href:"/docs/32.0.0/ingestion/input-sources#druid-input-source",children:[(0,a.jsx)(t.code,{children:"druid"})," input\nsource"]}),". If needed,\n",(0,a.jsx)(t.a,{href:"/docs/32.0.0/ingestion/ingestion-spec#transformspec",children:(0,a.jsx)(t.code,{children:"transformSpec"})})," can be used to filter or modify data during the\nreindexing job. To reindex with SQL, use ",(0,a.jsx)(t.a,{href:"/docs/32.0.0/multi-stage-query/reference#replace",children:(0,a.jsx)(t.code,{children:"REPLACE <table> OVERWRITE"})}),"\nwith ",(0,a.jsx)(t.code,{children:"SELECT ... FROM <table>"}),". (Druid does not have ",(0,a.jsx)(t.code,{children:"UPDATE"})," or ",(0,a.jsx)(t.code,{children:"ALTER TABLE"})," statements.) Any SQL SELECT query can be\nused to filter, modify, or enrich the data during the reindexing job."]}),"\n",(0,a.jsxs)(t.p,{children:["Data that is deleted in this way is marked unused, but remains in deep storage. To permanently delete it, use a ",(0,a.jsxs)(t.a,{href:"#kill-task",children:[(0,a.jsx)(t.code,{children:"kill"}),"\ntask"]}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"entire-table",children:"Entire table"}),"\n",(0,a.jsxs)(t.p,{children:["Deleting an entire table works the same way as ",(0,a.jsx)(t.a,{href:"#by-time-range-manually",children:"deleting part of a table by time range"}),". First,\nmark all segments unused using the Coordinator API or web console. Then, optionally, delete it permanently using a\n",(0,a.jsxs)(t.a,{href:"#kill-task",children:[(0,a.jsx)(t.code,{children:"kill"})," task"]}),"."]}),"\n",(0,a.jsx)("a",{name:"kill-task"}),"\n",(0,a.jsxs)(t.h2,{id:"permanently-kill-task",children:["Permanently (",(0,a.jsx)(t.code,{children:"kill"})," task)"]}),"\n",(0,a.jsxs)(t.p,{children:["Data that has been overwritten or soft-deleted still remains as segments that have been marked unused. You can use a\n",(0,a.jsx)(t.code,{children:"kill"})," task to permanently delete this data."]}),"\n",(0,a.jsx)(t.p,{children:"The available grammar is:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-json",children:'{\n    "type": "kill",\n    "id": <task_id>,\n    "dataSource": <task_datasource>,\n    "interval" : <all_unused_segments_in_this_interval_will_die!>,\n    "versions" : <optional_list_of_segment_versions_to_delete_in_this_interval>,\n    "context": <task_context>,\n    "batchSize": <optional_batch_size>,\n    "limit": <optional_maximum_number_of_segments_to_delete>,\n    "maxUsedStatusLastUpdatedTime": <optional_maximum_timestamp_when_segments_were_marked_as_unused>\n}\n'})}),"\n",(0,a.jsx)(t.p,{children:"Some of the parameters used in the task payload are further explained below:"}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{children:"Parameter"}),(0,a.jsx)(t.th,{children:"Default"}),(0,a.jsx)(t.th,{children:"Explanation"})]})}),(0,a.jsxs)(t.tbody,{children:[(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:(0,a.jsx)(t.code,{children:"versions"})}),(0,a.jsx)(t.td,{children:"null (all versions)"}),(0,a.jsxs)(t.td,{children:["List of segment versions within the specified ",(0,a.jsx)(t.code,{children:"interval"})," for the kill task to delete. The default behavior is to delete all unused segment versions in the specified ",(0,a.jsx)(t.code,{children:"interval"}),"."]})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:(0,a.jsx)(t.code,{children:"batchSize"})}),(0,a.jsx)(t.td,{children:"100"}),(0,a.jsxs)(t.td,{children:["Maximum number of segments that are deleted in one kill batch. Some operations on the Overlord may get stuck while a ",(0,a.jsx)(t.code,{children:"kill"})," task is in progress due to concurrency constraints (such as in ",(0,a.jsx)(t.code,{children:"TaskLockbox"}),"). Thus, a ",(0,a.jsx)(t.code,{children:"kill"})," task splits the list of unused segments to be deleted into smaller batches to yield the Overlord resources intermittently to other task operations."]})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:(0,a.jsx)(t.code,{children:"limit"})}),(0,a.jsx)(t.td,{children:"null (no limit)"}),(0,a.jsx)(t.td,{children:"Maximum number of segments for the kill task to delete."})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:(0,a.jsx)(t.code,{children:"maxUsedStatusLastUpdatedTime"})}),(0,a.jsx)(t.td,{children:"null (no cutoff)"}),(0,a.jsxs)(t.td,{children:["Maximum timestamp used as a cutoff to include unused segments. The kill task only considers segments which lie in the specified ",(0,a.jsx)(t.code,{children:"interval"})," and were marked as unused no later than this time. The default behavior is to kill all unused segments in the ",(0,a.jsx)(t.code,{children:"interval"})," regardless of when they where marked as unused."]})]})]})]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"WARNING:"})," The ",(0,a.jsx)(t.code,{children:"kill"})," task permanently removes all information about the affected segments from the metadata store and\ndeep storage. This operation cannot be undone."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);