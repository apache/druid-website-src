"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1345],{28453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>a});var s=r(96540);const t={},i=s.createContext(t);function o(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(i.Provider,{value:n},e.children)}},36945:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"querying/query-execution","title":"Query execution","description":"\x3c!--","source":"@site/docs/32.0.0/querying/query-execution.md","sourceDirName":"querying","slug":"/querying/query-execution","permalink":"/docs/32.0.0/querying/query-execution","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"query-execution","title":"Query execution"},"sidebar":"docs","previous":{"title":"Query processing","permalink":"/docs/32.0.0/querying/query-processing"},"next":{"title":"Troubleshooting","permalink":"/docs/32.0.0/querying/troubleshooting"}}');var t=r(74848),i=r(28453);const o={id:"query-execution",title:"Query execution"},a=void 0,d={},c=[{value:"Datasource type",id:"datasource-type",level:2},{value:"<code>table</code>",id:"table",level:3},{value:"<code>lookup</code>",id:"lookup",level:3},{value:"<code>union</code>",id:"union",level:3},{value:"<code>inline</code>",id:"inline",level:3},{value:"<code>query</code>",id:"query",level:3},{value:"<code>join</code>",id:"join",level:3}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["This document describes how Druid executes ",(0,t.jsx)(n.a,{href:"/docs/32.0.0/querying/",children:"native queries"}),", but since ",(0,t.jsx)(n.a,{href:"/docs/32.0.0/querying/sql",children:"Druid SQL"})," queries\nare translated to native queries, this document applies to the SQL runtime as well. Refer to the SQL\n",(0,t.jsx)(n.a,{href:"/docs/32.0.0/querying/sql-translation",children:"Query translation"})," page for information about how SQL queries are translated to native\nqueries."]})}),"\n",(0,t.jsxs)(n.p,{children:["Druid's approach to query execution varies depending on the kind of ",(0,t.jsx)(n.a,{href:"/docs/32.0.0/querying/datasource",children:"datasource"})," you are querying."]}),"\n",(0,t.jsx)(n.h2,{id:"datasource-type",children:"Datasource type"}),"\n",(0,t.jsx)(n.h3,{id:"table",children:(0,t.jsx)(n.code,{children:"table"})}),"\n",(0,t.jsxs)(n.p,{children:["Queries that operate directly on ",(0,t.jsx)(n.a,{href:"/docs/32.0.0/querying/datasource#table",children:"table datasources"})," are executed using a scatter-gather approach\nled by the Broker process. The process looks like this:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["The Broker identifies which ",(0,t.jsx)(n.a,{href:"/docs/32.0.0/design/segments",children:"segments"})," are relevant to the query based on the ",(0,t.jsx)(n.code,{children:'"intervals"'}),"\nparameter. Segments are always partitioned by time, so any segment whose interval overlaps the query interval is\npotentially relevant."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["The Broker may additionally further prune the segment list based on the ",(0,t.jsx)(n.code,{children:'"filter"'}),", if the input data was partitioned\nby range using the ",(0,t.jsxs)(n.a,{href:"/docs/32.0.0/ingestion/native-batch#partitionsspec",children:[(0,t.jsx)(n.code,{children:"single_dim"})," partitionsSpec"]}),", and if the filter matches\nthe dimension used for partitioning."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"The Broker, having pruned the list of segments for the query, forwards the query to data servers (like Historicals\nand tasks running on Middle Managers) that are currently serving those segments."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["For all query types except ",(0,t.jsx)(n.a,{href:"/docs/32.0.0/querying/scan-query",children:"Scan"}),", data servers process each segment in parallel and generate partial\nresults for each segment. The specific processing that is done depends on the query type. These partial results may be\ncached if ",(0,t.jsx)(n.a,{href:"/docs/32.0.0/querying/caching",children:"query caching"})," is enabled. For Scan queries, segments are processed in order by a single thread,\nand results are not cached."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"The Broker receives partial results from each data server, merges them into the final result set, and returns them\nto the caller. For Timeseries and Scan queries, and for GroupBy queries where there is no sorting, the Broker is able to\ndo this in a streaming fashion. Otherwise, the Broker fully computes the result set before returning anything."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"lookup",children:(0,t.jsx)(n.code,{children:"lookup"})}),"\n",(0,t.jsxs)(n.p,{children:["Queries that operate directly on ",(0,t.jsx)(n.a,{href:"/docs/32.0.0/querying/datasource#lookup",children:"lookup datasources"})," (without a join) are executed on the Broker\nthat received the query, using its local copy of the lookup. All registered lookup tables are preloaded in-memory on the\nBroker. The query runs single-threaded."]}),"\n",(0,t.jsxs)(n.p,{children:['Execution of queries that use lookups as right-hand inputs to a join are executed in a way that depends on their\n"base" (bottom-leftmost) datasource, as described in the ',(0,t.jsx)(n.a,{href:"#join",children:"join"})," section below."]}),"\n",(0,t.jsx)(n.h3,{id:"union",children:(0,t.jsx)(n.code,{children:"union"})}),"\n",(0,t.jsxs)(n.p,{children:["Queries that operate directly on ",(0,t.jsx)(n.a,{href:"/docs/32.0.0/querying/datasource#union",children:"union datasources"})," are split up on the Broker into a separate\nquery for each table that is part of the union. Each of these queries runs separately, and the Broker merges their\nresults together."]}),"\n",(0,t.jsx)(n.h3,{id:"inline",children:(0,t.jsx)(n.code,{children:"inline"})}),"\n",(0,t.jsxs)(n.p,{children:["Queries that operate directly on ",(0,t.jsx)(n.a,{href:"/docs/32.0.0/querying/datasource#inline",children:"inline datasources"})," are executed on the Broker that received the\nquery. The query runs single-threaded."]}),"\n",(0,t.jsxs)(n.p,{children:['Execution of queries that use inline datasources as right-hand inputs to a join are executed in a way that depends on\ntheir "base" (bottom-leftmost) datasource, as described in the ',(0,t.jsx)(n.a,{href:"#join",children:"join"})," section below."]}),"\n",(0,t.jsx)(n.h3,{id:"query",children:(0,t.jsx)(n.code,{children:"query"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"/docs/32.0.0/querying/datasource#query",children:"Query datasources"})," are subqueries. Each subquery is executed as if it was its own query and\nthe results are brought back to the Broker. Then, the Broker continues on with the rest of the query as if the subquery\nwas replaced with an inline datasource."]}),"\n",(0,t.jsxs)(n.p,{children:["In most cases, Druid buffers subquery results in memory on the Broker before the rest of the query proceeds.\nTherefore, subqueries execute sequentially. The total number of rows buffered across all subqueries of a given query\ncannot exceed the ",(0,t.jsx)(n.a,{href:"/docs/32.0.0/configuration/",children:(0,t.jsx)(n.code,{children:"druid.server.http.maxSubqueryRows"})})," which defaults to 100000 rows, or the\n",(0,t.jsx)(n.a,{href:"/docs/32.0.0/configuration/",children:(0,t.jsx)(n.code,{children:"druid.server.http.maxSubqueryBytes"})})," if set. Otherwise, Druid throws a resource limit exceeded\nexception."]}),"\n",(0,t.jsxs)(n.p,{children:["There is one exception: if the outer query is of type ",(0,t.jsx)(n.a,{href:"/docs/32.0.0/querying/groupbyquery",children:(0,t.jsx)(n.code,{children:"groupBy"})}),", and has a ",(0,t.jsx)(n.code,{children:"dataSource"})," of type\n",(0,t.jsx)(n.code,{children:"query"})," that is itself another ",(0,t.jsx)(n.code,{children:"groupBy"}),", then subquery results can be processed in a streaming fashion. In this case\nthe ",(0,t.jsx)(n.code,{children:"druid.server.http.maxSubqueryRows"})," and ",(0,t.jsx)(n.code,{children:"druid.server.http.maxSubqueryBytes"})," limits do not apply."]}),"\n",(0,t.jsx)(n.h3,{id:"join",children:(0,t.jsx)(n.code,{children:"join"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"/docs/32.0.0/querying/datasource#join",children:"Join datasources"})," are handled using a broadcast hash-join approach."]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["The Broker executes any subqueries that are inputs the join, as described in the ",(0,t.jsx)(n.a,{href:"#query",children:"query"})," section, and\nreplaces them with inline datasources."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:'The Broker flattens a join tree, if present, into a "base" datasource (the bottom-leftmost one) and other leaf\ndatasources (the rest).'}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Query execution proceeds using the same structure that the base datasource would use on its own. If the base\ndatasource is a ",(0,t.jsx)(n.a,{href:"#table",children:"table"}),", segments are pruned based on ",(0,t.jsx)(n.code,{children:'"intervals"'})," as usual, and the query is executed on the\ncluster by forwarding it to all relevant data servers in parallel. If the base datasource is a ",(0,t.jsx)(n.a,{href:"#lookup",children:"lookup"})," or\n",(0,t.jsx)(n.a,{href:"#inline",children:"inline"})," datasource (including an inline datasource that was the result of inlining a subquery), the query is\nexecuted on the Broker itself. The base query cannot be a union, because unions are not currently supported as inputs to\na join."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Before beginning to process the base datasource, the server(s) that will execute the query first inspect all the\nnon-base leaf datasources to determine if a new hash table needs to be built for the upcoming hash join. Currently,\nlookups do not require new hash tables to be built (because they are preloaded), but inline datasources do."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Query execution proceeds again using the same structure that the base datasource would use on its own, with one\naddition: while processing the base datasource, Druid servers will use the hash tables built from the other join inputs\nto produce the join result row-by-row, and query engines will operate on the joined rows rather than the base rows."}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}}}]);