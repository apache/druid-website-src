"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8293],{28453:(e,n,s)=>{s.d(n,{R:()=>d,x:()=>l});var t=s(96540);const r={},i=t.createContext(r);function d(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),t.createElement(i.Provider,{value:n},e.children)}},55878:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>d,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"querying/virtual-columns","title":"Virtual columns","description":"\x3c!--","source":"@site/docs/33.0.0/querying/virtual-columns.md","sourceDirName":"querying","slug":"/querying/virtual-columns","permalink":"/docs/33.0.0/querying/virtual-columns","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"virtual-columns","title":"Virtual columns"},"sidebar":"docs","previous":{"title":"String comparators","permalink":"/docs/33.0.0/querying/sorting-orders"},"next":{"title":"Spatial filters","permalink":"/docs/33.0.0/querying/geo"}}');var r=s(74848),i=s(28453);const d={id:"virtual-columns",title:"Virtual columns"},l=void 0,c={},a=[{value:"Virtual column types",id:"virtual-column-types",level:2},{value:"Expression virtual column",id:"expression-virtual-column",level:3},{value:"Nested field virtual column",id:"nested-field-virtual-column",level:3},{value:"Nested path part",id:"nested-path-part",level:4},{value:"List filtered virtual column",id:"list-filtered-virtual-column",level:3}];function o(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["Apache Druid supports two query languages: ",(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/sql",children:"Druid SQL"})," and ",(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/",children:"native queries"}),".\nThis document describes the native\nlanguage. For information about functions available in SQL, refer to the\n",(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/sql-scalar",children:"SQL documentation"}),"."]})}),"\n",(0,r.jsx)(n.p,{children:'Virtual columns are queryable column "views" created from a set of columns during a query.'}),"\n",(0,r.jsx)(n.p,{children:"A virtual column can potentially draw from multiple underlying columns, although a virtual column always presents itself as a single column."}),"\n",(0,r.jsxs)(n.p,{children:["Virtual columns can be referenced by their output names to be used as ",(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/dimensionspecs",children:"dimensions"})," or as inputs to ",(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/filters",children:"filters"})," and ",(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/aggregations",children:"aggregators"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Each Apache Druid query can accept a list of virtual columns as a parameter. The following scan query is provided as an example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'{\n "queryType": "scan",\n "dataSource": "page_data",\n "columns":[],\n "virtualColumns": [\n    {\n      "type": "expression",\n      "name": "fooPage",\n      "expression": "concat(\'foo\' + page)",\n      "outputType": "STRING"\n    },\n    {\n      "type": "expression",\n      "name": "tripleWordCount",\n      "expression": "wordCount * 3",\n      "outputType": "LONG"\n    }\n  ],\n "intervals": [\n   "2013-01-01/2019-01-02"\n ]\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"virtual-column-types",children:"Virtual column types"}),"\n",(0,r.jsx)(n.h3,{id:"expression-virtual-column",children:"Expression virtual column"}),"\n",(0,r.jsxs)(n.p,{children:["Expression virtual columns use Druid's native ",(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/math-expr",children:"expression"})," system to allow defining query time\ntransforms of inputs from one or more columns."]}),"\n",(0,r.jsx)(n.p,{children:"The expression virtual column has the following syntax:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "type": "expression",\n  "name": <name of the virtual column>,\n  "expression": <row expression>,\n  "outputType": <output value type of expression>\n}\n'})}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"property"}),(0,r.jsx)(n.th,{children:"description"}),(0,r.jsx)(n.th,{children:"required?"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"type"}),(0,r.jsxs)(n.td,{children:["Must be ",(0,r.jsx)(n.code,{children:'"expression"'})," to indicate that this is an expression virtual column."]}),(0,r.jsx)(n.td,{children:"yes"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"name"}),(0,r.jsx)(n.td,{children:"The name of the virtual column."}),(0,r.jsx)(n.td,{children:"yes"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"expression"}),(0,r.jsxs)(n.td,{children:["An ",(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/math-expr",children:"expression"})," that takes a row as input and outputs a value for the virtual column."]}),(0,r.jsx)(n.td,{children:"yes"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"outputType"}),(0,r.jsx)(n.td,{children:"The expression's output will be coerced to this type. Can be LONG, FLOAT, DOUBLE, STRING, ARRAY types, or COMPLEX types."}),(0,r.jsx)(n.td,{children:"no, default is FLOAT"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"nested-field-virtual-column",children:"Nested field virtual column"}),"\n",(0,r.jsxs)(n.p,{children:["The nested field virtual column is an optimized virtual column that can provide direct access into various paths of\na ",(0,r.jsx)(n.code,{children:"COMPLEX<json>"})," column, including using their indexes."]}),"\n",(0,r.jsxs)(n.p,{children:["This virtual column is used for the SQL operators ",(0,r.jsx)(n.code,{children:"JSON_VALUE"})," (if ",(0,r.jsx)(n.code,{children:"processFromRaw"})," is set to false) or ",(0,r.jsx)(n.code,{children:"JSON_QUERY"}),"\n(if ",(0,r.jsx)(n.code,{children:"processFromRaw"})," is true), and accepts 'JSONPath' or 'jq' syntax string representations of paths, or a parsed\nlist of \"path parts\" in order to determine what should be selected from the column."]}),"\n",(0,r.jsxs)(n.p,{children:["You can define a nested field virtual column with any of the following equivalent syntaxes. The examples all produce\nthe same output value, with each example showing a different way to specify how to access the nested value. The first\nis using JSONPath syntax ",(0,r.jsx)(n.code,{children:"path"}),", the second with a jq ",(0,r.jsx)(n.code,{children:"path"}),", and the third uses ",(0,r.jsx)(n.code,{children:"pathParts"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'    {\n      "type": "nested-field",\n      "columnName": "shipTo",\n      "outputName": "v0",\n      "expectedType": "STRING",\n      "path": "$.phoneNumbers[1].number"\n    }\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'    {\n      "type": "nested-field",\n      "columnName": "shipTo",\n      "outputName": "v1",\n      "expectedType": "STRING",\n      "path": ".phoneNumbers[1].number",\n      "useJqSyntax": true\n    }\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'    {\n      "type": "nested-field",\n      "columnName": "shipTo",\n      "outputName": "v2",\n      "expectedType": "STRING",\n      "pathParts": [\n        {\n          "type": "field",\n          "field": "phoneNumbers"\n        },\n        {\n          "type": "arrayElement",\n          "index": 1\n        },\n        {\n          "type": "field",\n          "field": "number"\n        }\n      ]\n    }\n'})}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"property"}),(0,r.jsx)(n.th,{children:"description"}),(0,r.jsx)(n.th,{children:"required?"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"type"}),(0,r.jsxs)(n.td,{children:["Must be ",(0,r.jsx)(n.code,{children:'"nested-field"'})," to indicate that this is a nested field virtual column."]}),(0,r.jsx)(n.td,{children:"yes"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"columnName"}),(0,r.jsxs)(n.td,{children:["The name of the ",(0,r.jsx)(n.code,{children:"COMPLEX<json>"})," input column."]}),(0,r.jsx)(n.td,{children:"yes"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"outputName"}),(0,r.jsx)(n.td,{children:"The name of the virtual column."}),(0,r.jsx)(n.td,{children:"yes"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"expectedType"}),(0,r.jsxs)(n.td,{children:["The native Druid output type of the column, Druid will coerce output to this type if it does not match the underlying data. This can be ",(0,r.jsx)(n.code,{children:"STRING"}),", ",(0,r.jsx)(n.code,{children:"LONG"}),", ",(0,r.jsx)(n.code,{children:"FLOAT"}),", ",(0,r.jsx)(n.code,{children:"DOUBLE"}),", or ",(0,r.jsx)(n.code,{children:"COMPLEX<json>"}),". Extracting ",(0,r.jsx)(n.code,{children:"ARRAY"})," types is not yet supported."]}),(0,r.jsxs)(n.td,{children:["no, default ",(0,r.jsx)(n.code,{children:"STRING"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"pathParts"}),(0,r.jsxs)(n.td,{children:["The parsed path parts used to locate the nested values. ",(0,r.jsx)(n.code,{children:"path"})," will be translated into ",(0,r.jsx)(n.code,{children:"pathParts"})," internally. One of ",(0,r.jsx)(n.code,{children:"path"})," or ",(0,r.jsx)(n.code,{children:"pathParts"})," must be set"]}),(0,r.jsxs)(n.td,{children:["no, if ",(0,r.jsx)(n.code,{children:"path"})," is defined"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"processFromRaw"}),(0,r.jsxs)(n.td,{children:['If set to true, the virtual column will process the "raw" JSON data to extract values rather than using an optimized "literal" value selector. This option allows extracting non-literal values (such as nested JSON objects or arrays) as a ',(0,r.jsx)(n.code,{children:"COMPLEX<json>"})," at the cost of much slower performance."]}),(0,r.jsx)(n.td,{children:"no, default false"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"path"}),(0,r.jsxs)(n.td,{children:["'JSONPath' (or 'jq') syntax path. One of ",(0,r.jsx)(n.code,{children:"path"})," or ",(0,r.jsx)(n.code,{children:"pathParts"})," must be set."]}),(0,r.jsxs)(n.td,{children:["no, if ",(0,r.jsx)(n.code,{children:"pathParts"})," is defined"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"useJqSyntax"}),(0,r.jsxs)(n.td,{children:["If true, parse ",(0,r.jsx)(n.code,{children:"path"})," using 'jq' syntax instead of 'JSONPath'."]}),(0,r.jsx)(n.td,{children:"no, default is false"})]})]})]}),"\n",(0,r.jsx)(n.h4,{id:"nested-path-part",children:"Nested path part"}),"\n",(0,r.jsxs)(n.p,{children:["Specify ",(0,r.jsx)(n.code,{children:"pathParts"})," as an array of objects that describe each component of the path to traverse. Each object can take the following properties:"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"property"}),(0,r.jsx)(n.th,{children:"description"}),(0,r.jsx)(n.th,{children:"required?"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"type"}),(0,r.jsxs)(n.td,{children:["Must be 'field' or 'arrayElement'. Use ",(0,r.jsx)(n.code,{children:"field"})," when accessing a specific field in a nested structure. Use ",(0,r.jsx)(n.code,{children:"arrayElement"})," when accessing a specific integer position of an array (zero based)."]}),(0,r.jsx)(n.td,{children:"yes"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"field"}),(0,r.jsxs)(n.td,{children:["The name of the 'field' in a 'field' ",(0,r.jsx)(n.code,{children:"type"})," path part"]}),(0,r.jsxs)(n.td,{children:["yes, if ",(0,r.jsx)(n.code,{children:"type"})," is 'field'"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"index"}),(0,r.jsxs)(n.td,{children:["The array element index if ",(0,r.jsx)(n.code,{children:"type"})," is ",(0,r.jsx)(n.code,{children:"arrayElement"})]}),(0,r.jsxs)(n.td,{children:["yes, if ",(0,r.jsx)(n.code,{children:"type"})," is 'arrayElement'"]})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:["See ",(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/nested-columns",children:"Nested columns"})," for more information on ingesting and storing nested data."]}),"\n",(0,r.jsx)(n.h3,{id:"list-filtered-virtual-column",children:"List filtered virtual column"}),"\n",(0,r.jsxs)(n.p,{children:["This virtual column provides an alternative way to use\n",(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/dimensionspecs#filtered-dimensionspecs",children:"'list filtered' dimension spec"})," as a virtual column. It has optimized\naccess to the underlying column value indexes that can provide a small performance improvement in some cases."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'    {\n      "type": "mv-filtered",\n      "name": "filteredDim3",\n      "delegate": "dim3",\n      "values": ["hello", "world"],\n      "isAllowList": true\n    }\n'})}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"property"}),(0,r.jsx)(n.th,{children:"description"}),(0,r.jsx)(n.th,{children:"required?"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"type"}),(0,r.jsxs)(n.td,{children:["Must be ",(0,r.jsx)(n.code,{children:'"mv-filtered"'})," to indicate that this is a list filtered virtual column."]}),(0,r.jsx)(n.td,{children:"yes"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"name"}),(0,r.jsx)(n.td,{children:"The output name of the virtual column"}),(0,r.jsx)(n.td,{children:"yes"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"delegate"}),(0,r.jsx)(n.td,{children:"The name of the multi-value STRING input column to filter"}),(0,r.jsx)(n.td,{children:"yes"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"values"}),(0,r.jsx)(n.td,{children:"Set of STRING values to allow or deny"}),(0,r.jsx)(n.td,{children:"yes"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"isAllowList"}),(0,r.jsxs)(n.td,{children:["If true, the output of the virtual column will be limited to the set specified by ",(0,r.jsx)(n.code,{children:"values"}),", else it will provide all values ",(0,r.jsx)(n.em,{children:"except"})," those specified."]}),(0,r.jsx)(n.td,{children:"No, default true"})]})]})]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}}}]);