"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8104],{6538:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"development/extensions-contrib/iceberg","title":"Iceberg extension","description":"\x3c!--","source":"@site/docs/latest/development/extensions-contrib/iceberg.md","sourceDirName":"development/extensions-contrib","slug":"/development/extensions-contrib/iceberg","permalink":"/docs/latest/development/extensions-contrib/iceberg","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"iceberg","title":"Iceberg extension"}}');var s=t(74848),i=t(28453);const r={id:"iceberg",title:"Iceberg extension"},a=void 0,c={},l=[{value:"Iceberg Ingest extension",id:"iceberg-ingest-extension",level:2},{value:"Hive metastore catalog",id:"hive-metastore-catalog",level:2},{value:"Read from HDFS warehouse",id:"read-from-hdfs-warehouse",level:3},{value:"Read from S3 warehouse",id:"read-from-s3-warehouse",level:3},{value:"Local catalog",id:"local-catalog",level:2},{value:"REST catalog",id:"rest-catalog",level:2},{value:"Glue catalog",id:"glue-catalog",level:2},{value:"Downloading Iceberg extension",id:"downloading-iceberg-extension",level:2},{value:"Known limitations",id:"known-limitations",level:2}];function d(e){const n={a:"a",br:"br",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"iceberg-ingest-extension",children:"Iceberg Ingest extension"}),"\n",(0,s.jsxs)(n.p,{children:["Apache Iceberg is an open table format for huge analytic datasets. ",(0,s.jsx)(n.a,{href:"/docs/latest/ingestion/input-sources#iceberg-input-source",children:"IcebergInputSource"})," lets you ingest data stored in the Iceberg table format into Apache Druid. To use the iceberg extension, add the ",(0,s.jsx)(n.code,{children:"druid-iceberg-extensions"})," to the list of loaded extensions. See ",(0,s.jsx)(n.a,{href:"/docs/latest/configuration/extensions#loading-extensions",children:"Loading extensions"})," for more information."]}),"\n",(0,s.jsx)(n.p,{children:"Iceberg manages most of its metadata in metadata files in the object storage. However, it is still dependent on a metastore to manage a certain amount of metadata.\nIceberg refers to these metastores as catalogs. The Iceberg extension lets you connect to the following Iceberg catalog types:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Glue catalog"}),"\n",(0,s.jsx)(n.li,{children:"REST-based catalog"}),"\n",(0,s.jsx)(n.li,{children:"Hive metastore catalog"}),"\n",(0,s.jsx)(n.li,{children:"Local catalog"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For a given catalog, Iceberg input source reads the table name from the catalog, applies the filters, and extracts all the underlying live data files up to the latest snapshot.\nThe data files can be in Parquet, ORC, or Avro formats. The data files typically reside in a warehouse location, which can be in HDFS, S3, or the local filesystem.\nThe ",(0,s.jsx)(n.code,{children:"druid-iceberg-extensions"})," extension relies on the existing input source connectors in Druid to read the data files from the warehouse. Therefore, the Iceberg input source can be considered as an intermediate input source, which provides the file paths for other input source implementations."]}),"\n",(0,s.jsx)(n.h2,{id:"hive-metastore-catalog",children:"Hive metastore catalog"}),"\n",(0,s.jsxs)(n.p,{children:["For Druid to seamlessly talk to the Hive metastore, ensure that the Hive configuration files such as ",(0,s.jsx)(n.code,{children:"hive-site.xml"})," and ",(0,s.jsx)(n.code,{children:"core-site.xml"})," are available in the Druid classpath for peon processes.",(0,s.jsx)(n.br,{}),"\n","You can also specify Hive properties under the ",(0,s.jsx)(n.code,{children:"catalogProperties"})," object in the ingestion spec."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"druid-iceberg-extensions"})," extension presently only supports HDFS, S3 and local warehouse directories."]}),"\n",(0,s.jsx)(n.h3,{id:"read-from-hdfs-warehouse",children:"Read from HDFS warehouse"}),"\n",(0,s.jsxs)(n.p,{children:["To read from a HDFS warehouse, load the ",(0,s.jsx)(n.code,{children:"druid-hdfs-storage"})," extension. Druid extracts data file paths from the Hive metastore catalog and uses ",(0,s.jsx)(n.a,{href:"/docs/latest/ingestion/input-sources#hdfs-input-source",children:"HDFS input source"})," to ingest these files.\nThe ",(0,s.jsx)(n.code,{children:"warehouseSource"})," type in the ingestion spec should be ",(0,s.jsx)(n.code,{children:"hdfs"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["For authenticating with Kerberized clusters, include ",(0,s.jsx)(n.code,{children:"principal"})," and ",(0,s.jsx)(n.code,{children:"keytab"})," properties in the ",(0,s.jsx)(n.code,{children:"catalogProperties"})," object:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'"catalogProperties": {\n  "principal": "krb_principal",\n  "keytab": "/path/to/keytab"\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Only Kerberos based authentication is supported as of now."}),"\n",(0,s.jsx)(n.h3,{id:"read-from-s3-warehouse",children:"Read from S3 warehouse"}),"\n",(0,s.jsxs)(n.p,{children:["To read from a S3 warehouse, load the ",(0,s.jsx)(n.code,{children:"druid-s3-extensions"})," extension. Druid extracts the data file paths from the Hive metastore catalog and uses ",(0,s.jsx)(n.code,{children:"S3InputSource"})," to ingest these files.\nSet the ",(0,s.jsx)(n.code,{children:"type"})," property of the ",(0,s.jsx)(n.code,{children:"warehouseSource"})," object to ",(0,s.jsx)(n.code,{children:"s3"})," in the ingestion spec. If the S3 endpoint for the warehouse is different from the endpoint configured as the deep storage, include the following properties in the ",(0,s.jsx)(n.code,{children:"warehouseSource"})," object to define the S3 endpoint settings:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'"warehouseSource": {\n  "type": "s3",\n  "endpointConfig": {\n    "url": "S3_ENDPOINT_URL",\n    "signingRegion": "us-east-1"\n  },\n  "clientConfig": {\n    "protocol": "http",\n    "disableChunkedEncoding": true,\n    "enablePathStyleAccess": true,\n    "forceGlobalBucketAccessEnabled": false\n  },\n  "properties": {\n    "accessKeyId": {\n      "type": "default",\n      "password": "<ACCESS_KEY_ID"\n    },\n    "secretAccessKey": {\n      "type": "default",\n      "password": "<SECRET_ACCESS_KEY>"\n    }\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This extension uses the ",(0,s.jsx)(n.a,{href:"https://hadoop.apache.org/docs/stable/hadoop-aws/tools/hadoop-aws/",children:"Hadoop AWS module"})," to connect to S3 and retrieve the metadata and data file paths.\nThe following properties are required in the ",(0,s.jsx)(n.code,{children:"catalogProperties"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'"catalogProperties": {\n  "fs.s3a.access.key" : "S3_ACCESS_KEY",\n  "fs.s3a.secret.key" : "S3_SECRET_KEY",\n  "fs.s3a.endpoint" : "S3_API_ENDPOINT"\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Since the Hadoop AWS connector uses the ",(0,s.jsx)(n.code,{children:"s3a"})," filesystem client, specify the warehouse path with the ",(0,s.jsx)(n.code,{children:"s3a://"})," protocol instead of ",(0,s.jsx)(n.code,{children:"s3://"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"local-catalog",children:"Local catalog"}),"\n",(0,s.jsxs)(n.p,{children:["The local catalog type can be used for catalogs configured on the local filesystem. Set the ",(0,s.jsx)(n.code,{children:"icebergCatalog"})," type to ",(0,s.jsx)(n.code,{children:"local"}),". You can use this catalog for demos or localized tests. It is not recommended for production use cases.\nThe ",(0,s.jsx)(n.code,{children:"warehouseSource"})," is set to ",(0,s.jsx)(n.code,{children:"local"})," because this catalog only supports reading from a local filesystem."]}),"\n",(0,s.jsx)(n.h2,{id:"rest-catalog",children:"REST catalog"}),"\n",(0,s.jsxs)(n.p,{children:["To connect to an Iceberg REST Catalog server, configure the ",(0,s.jsx)(n.code,{children:"icebergCatalog"})," type as ",(0,s.jsx)(n.code,{children:"rest"}),". The Iceberg REST Open API spec gives catalogs greater control over the implementation and in most cases, the ",(0,s.jsx)(n.code,{children:"warehousePath"})," does not have to be provided by the client.\nSecurity credentials may be provided in the ",(0,s.jsx)(n.code,{children:"catalogProperties"})," object."]}),"\n",(0,s.jsx)(n.h2,{id:"glue-catalog",children:"Glue catalog"}),"\n",(0,s.jsxs)(n.p,{children:["Configure the ",(0,s.jsx)(n.code,{children:"icebergCatalog"})," type as ",(0,s.jsx)(n.code,{children:"glue"}),".",(0,s.jsx)(n.code,{children:"warehousePath"})," and properties must be provided in ",(0,s.jsx)(n.code,{children:"catalogProperties"})," object.\nRefer ",(0,s.jsx)(n.a,{href:"https://iceberg.apache.org/docs/1.6.0/aws/#glue-catalog",children:"Iceberg Glue Catalog documentation"})," for setting properties."]}),"\n",(0,s.jsx)(n.h2,{id:"downloading-iceberg-extension",children:"Downloading Iceberg extension"}),"\n",(0,s.jsxs)(n.p,{children:["To download ",(0,s.jsx)(n.code,{children:"druid-iceberg-extensions"}),", run the following command after replacing ",(0,s.jsx)(n.code,{children:"<VERSION>"})," with the desired\nDruid version:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:'java \\\n  -cp "lib/*" \\\n  -Ddruid.extensions.directory="extensions" \\\n  -Ddruid.extensions.hadoopDependenciesDir="hadoop-dependencies" \\\n  org.apache.druid.cli.Main tools pull-deps \\\n  --no-default-hadoop \\\n  -c "org.apache.druid.extensions.contrib:druid-iceberg-extensions:<VERSION>"\n'})}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/docs/latest/configuration/extensions#loading-community-extensions",children:"Loading community extensions"})," for more information."]}),"\n",(0,s.jsx)(n.h2,{id:"known-limitations",children:"Known limitations"}),"\n",(0,s.jsx)(n.p,{children:"This section lists the known limitations that apply to the Iceberg extension."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"This extension does not fully utilize the Iceberg features such as snapshotting or schema evolution."}),"\n",(0,s.jsx)(n.li,{children:"The Iceberg input source reads every single live file on the Iceberg table up to the latest snapshot, which makes the table scan less performant. It is recommended to use Iceberg filters on partition columns in the ingestion spec in order to limit the number of data files being retrieved. Since, Druid doesn't store the last ingested iceberg snapshot ID, it cannot identify the files created between that snapshot and the latest snapshot on Iceberg."}),"\n",(0,s.jsxs)(n.li,{children:["It does not handle Iceberg ",(0,s.jsx)(n.a,{href:"https://iceberg.apache.org/docs/latest/evolution/",children:"schema evolution"})," yet. In cases where an existing Iceberg table column is deleted and recreated with the same name, ingesting this table into Druid may bring the data for this column before it was deleted."]}),"\n",(0,s.jsx)(n.li,{children:"The Hive catalog has not been tested on Hadoop 2.x.x and is not guaranteed to work with Hadoop 2."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var o=t(96540);const s={},i=o.createContext(s);function r(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);