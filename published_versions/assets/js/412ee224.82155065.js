"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7722],{28453:(e,s,d)=>{d.d(s,{R:()=>c,x:()=>n});var r=d(96540);const i={},t=r.createContext(i);function c(e){const s=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function n(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),r.createElement(t.Provider,{value:s},e.children)}},42055:(e,s,d)=>{d.r(s),d.d(s,{assets:()=>l,contentTitle:()=>n,default:()=>a,frontMatter:()=>c,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"operations/metrics","title":"Metrics","description":"\x3c!--","source":"@site/docs/latest/operations/metrics.md","sourceDirName":"operations","slug":"/operations/metrics","permalink":"/docs/latest/operations/metrics","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"metrics","title":"Metrics"},"sidebar":"docs","previous":{"title":"Request logging","permalink":"/docs/latest/operations/request-logging"},"next":{"title":"Alerts","permalink":"/docs/latest/operations/alerts"}}');var i=d(74848),t=d(28453);const c={id:"metrics",title:"Metrics"},n=void 0,l={},o=[{value:"Query metrics",id:"query-metrics",level:2},{value:"Router",id:"router",level:3},{value:"Broker",id:"broker",level:3},{value:"Historical",id:"historical",level:3},{value:"Real-time",id:"real-time",level:3},{value:"GroupBy query metrics",id:"groupby-query-metrics",level:3},{value:"Jetty",id:"jetty",level:3},{value:"Cache",id:"cache",level:3},{value:"Memcached only metrics",id:"memcached-only-metrics",level:4},{value:"SQL Metrics",id:"sql-metrics",level:2},{value:"Ingestion metrics",id:"ingestion-metrics",level:2},{value:"General native ingestion metrics",id:"general-native-ingestion-metrics",level:3},{value:"Ingestion metrics for Kafka",id:"ingestion-metrics-for-kafka",level:3},{value:"Ingestion metrics for Kinesis",id:"ingestion-metrics-for-kinesis",level:3},{value:"Compaction metrics",id:"compaction-metrics",level:3},{value:"Other ingestion metrics",id:"other-ingestion-metrics",level:3},{value:"Indexing service",id:"indexing-service",level:2},{value:"Shuffle metrics (Native parallel task)",id:"shuffle-metrics-native-parallel-task",level:2},{value:"Coordination",id:"coordination",level:2},{value:"General Health",id:"general-health",level:2},{value:"Service Health",id:"service-health",level:3},{value:"Historical",id:"historical-1",level:3},{value:"JVM",id:"jvm",level:3},{value:"ZooKeeper",id:"zookeeper",level:3},{value:"Sys [Deprecated]",id:"sys-deprecated",level:2},{value:"OshiSysMonitor",id:"oshisysmonitor",level:2},{value:"S3 multi-part upload",id:"s3-multi-part-upload",level:2},{value:"Cgroup",id:"cgroup",level:2}];function h(e){const s={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(s.p,{children:["You can configure Druid to ",(0,i.jsx)(s.a,{href:"/docs/latest/configuration/#enabling-metrics",children:"emit metrics"})," that are essential for monitoring query execution, ingestion, coordination, and so on."]}),"\n",(0,i.jsx)(s.p,{children:"All Druid metrics share a common set of fields:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"timestamp"}),": the time the metric was created"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"metric"}),": the name of the metric"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"service"}),": the service name that emitted the metric"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"host"}),": the host name that emitted the metric"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"value"}),": some numeric value associated with the metric"]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"Metrics may have additional dimensions beyond those listed above."}),"\n",(0,i.jsx)(s.admonition,{type:"info",children:(0,i.jsxs)(s.p,{children:["Most metric values reset each emission period, as specified in ",(0,i.jsx)(s.code,{children:"druid.monitoring.emissionPeriod"}),"."]})}),"\n",(0,i.jsx)(s.h2,{id:"query-metrics",children:"Query metrics"}),"\n",(0,i.jsx)(s.h3,{id:"router",children:"Router"}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Metric"}),(0,i.jsx)(s.th,{children:"Description"}),(0,i.jsx)(s.th,{children:"Dimensions"}),(0,i.jsx)(s.th,{children:"Normal value"})]})}),(0,i.jsx)(s.tbody,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/time"})}),(0,i.jsx)(s.td,{children:"Milliseconds taken to complete a query."}),(0,i.jsxs)(s.td,{children:["Native Query: ",(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"type"}),", ",(0,i.jsx)(s.code,{children:"interval"}),", ",(0,i.jsx)(s.code,{children:"hasFilters"}),", ",(0,i.jsx)(s.code,{children:"duration"}),", ",(0,i.jsx)(s.code,{children:"context"}),", ",(0,i.jsx)(s.code,{children:"remoteAddress"}),", ",(0,i.jsx)(s.code,{children:"id"}),"."]}),(0,i.jsx)(s.td,{children:"< 1s"})]})})]}),"\n",(0,i.jsx)(s.h3,{id:"broker",children:"Broker"}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Metric"}),(0,i.jsx)(s.th,{children:"Description"}),(0,i.jsx)(s.th,{children:"Dimensions"}),(0,i.jsx)(s.th,{children:"Normal value"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/time"})}),(0,i.jsx)(s.td,{children:"Milliseconds taken to complete a query."}),(0,i.jsxs)(s.td,{children:[(0,i.jsxs)("p",{children:["Common: ",(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"type"}),", ",(0,i.jsx)(s.code,{children:"interval"}),", ",(0,i.jsx)(s.code,{children:"hasFilters"}),", ",(0,i.jsx)(s.code,{children:"duration"}),", ",(0,i.jsx)(s.code,{children:"context"}),", ",(0,i.jsx)(s.code,{children:"remoteAddress"}),", ",(0,i.jsx)(s.code,{children:"id"}),"."]}),(0,i.jsxs)("p",{children:["Aggregation Queries: ",(0,i.jsx)(s.code,{children:"numMetrics"}),", ",(0,i.jsx)(s.code,{children:"numComplexMetrics"}),"."]}),(0,i.jsxs)("p",{children:["GroupBy: ",(0,i.jsx)(s.code,{children:"numDimensions"}),"."]}),(0,i.jsxs)("p",{children:[" TopN: ",(0,i.jsx)(s.code,{children:"threshold"}),", ",(0,i.jsx)(s.code,{children:"dimension"}),"."]})]}),(0,i.jsx)(s.td,{children:"< 1s"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/bytes"})}),(0,i.jsx)(s.td,{children:"The total number of bytes returned to the requesting client in the query response from the broker. Other services report the total bytes for their portion of the query."}),(0,i.jsxs)(s.td,{children:[(0,i.jsxs)("p",{children:["Common: ",(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"type"}),", ",(0,i.jsx)(s.code,{children:"interval"}),", ",(0,i.jsx)(s.code,{children:"hasFilters"}),", ",(0,i.jsx)(s.code,{children:"duration"}),", ",(0,i.jsx)(s.code,{children:"context"}),", ",(0,i.jsx)(s.code,{children:"remoteAddress"}),", ",(0,i.jsx)(s.code,{children:"id"}),"."]}),(0,i.jsxs)("p",{children:[" Aggregation Queries: ",(0,i.jsx)(s.code,{children:"numMetrics"}),", ",(0,i.jsx)(s.code,{children:"numComplexMetrics"}),"."]}),(0,i.jsxs)("p",{children:[" GroupBy: ",(0,i.jsx)(s.code,{children:"numDimensions"}),"."]}),(0,i.jsxs)("p",{children:[" TopN: ",(0,i.jsx)(s.code,{children:"threshold"}),", ",(0,i.jsx)(s.code,{children:"dimension"}),"."]})]}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/node/time"})}),(0,i.jsx)(s.td,{children:"Milliseconds taken to query individual historical/realtime processes."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"id"}),", ",(0,i.jsx)(s.code,{children:"status"}),", ",(0,i.jsx)(s.code,{children:"server"})]}),(0,i.jsx)(s.td,{children:"< 1s"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/node/bytes"})}),(0,i.jsx)(s.td,{children:"Number of bytes returned from querying individual historical/realtime processes."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"id"}),", ",(0,i.jsx)(s.code,{children:"status"}),", ",(0,i.jsx)(s.code,{children:"server"})]}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/node/ttfb"})}),(0,i.jsx)(s.td,{children:"Time to first byte. Milliseconds elapsed until Broker starts receiving the response from individual historical/realtime processes."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"id"}),", ",(0,i.jsx)(s.code,{children:"status"}),", ",(0,i.jsx)(s.code,{children:"server"})]}),(0,i.jsx)(s.td,{children:"< 1s"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/node/backpressure"})}),(0,i.jsx)(s.td,{children:"Milliseconds that the channel to this process has spent suspended due to backpressure."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"id"}),", ",(0,i.jsx)(s.code,{children:"status"}),", ",(0,i.jsx)(s.code,{children:"server"}),"."]}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/count"})}),(0,i.jsx)(s.td,{children:"Number of total queries."}),(0,i.jsxs)(s.td,{children:["This metric is only available if the ",(0,i.jsx)(s.code,{children:"QueryCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/success/count"})}),(0,i.jsx)(s.td,{children:"Number of queries successfully processed."}),(0,i.jsxs)(s.td,{children:["This metric is only available if the ",(0,i.jsx)(s.code,{children:"QueryCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/failed/count"})}),(0,i.jsx)(s.td,{children:"Number of failed queries."}),(0,i.jsxs)(s.td,{children:["This metric is only available if the ",(0,i.jsx)(s.code,{children:"QueryCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/interrupted/count"})}),(0,i.jsx)(s.td,{children:"Number of queries interrupted due to cancellation."}),(0,i.jsxs)(s.td,{children:["This metric is only available if the ",(0,i.jsx)(s.code,{children:"QueryCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/timeout/count"})}),(0,i.jsx)(s.td,{children:"Number of timed out queries."}),(0,i.jsxs)(s.td,{children:["This metric is only available if the ",(0,i.jsx)(s.code,{children:"QueryCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/segments/count"})}),(0,i.jsxs)(s.td,{children:["This metric is not enabled by default. See the ",(0,i.jsx)(s.code,{children:"QueryMetrics"})," Interface for reference regarding enabling this metric. Number of segments that will be touched by the query. In the broker, it makes a plan to distribute the query to realtime tasks and historicals based on a snapshot of segment distribution state. If there are some segments moved after this snapshot is created, certain historicals and realtime tasks can report those segments as missing to the broker. The broker will resend the query to the new servers that serve those segments after move. In this case, those segments can be counted more than once in this metric."]}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/priority"})}),(0,i.jsxs)(s.td,{children:["Assigned lane and priority, only if Laning strategy is enabled. Refer to ",(0,i.jsx)(s.a,{href:"/docs/latest/configuration/#laning-strategies",children:"Laning strategies"})]}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"lane"}),", ",(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"type"})]}),(0,i.jsx)(s.td,{children:"0"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sqlQuery/time"})}),(0,i.jsx)(s.td,{children:"Milliseconds taken to complete a SQL query."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"id"}),", ",(0,i.jsx)(s.code,{children:"nativeQueryIds"}),", ",(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"remoteAddress"}),", ",(0,i.jsx)(s.code,{children:"success"}),", ",(0,i.jsx)(s.code,{children:"engine"})]}),(0,i.jsx)(s.td,{children:"< 1s"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sqlQuery/planningTimeMs"})}),(0,i.jsx)(s.td,{children:"Milliseconds taken to plan a SQL to native query."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"id"}),", ",(0,i.jsx)(s.code,{children:"nativeQueryIds"}),", ",(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"remoteAddress"}),", ",(0,i.jsx)(s.code,{children:"success"}),", ",(0,i.jsx)(s.code,{children:"engine"})]}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sqlQuery/bytes"})}),(0,i.jsx)(s.td,{children:"Number of bytes returned in the SQL query response."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"id"}),", ",(0,i.jsx)(s.code,{children:"nativeQueryIds"}),", ",(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"remoteAddress"}),", ",(0,i.jsx)(s.code,{children:"success"}),", ",(0,i.jsx)(s.code,{children:"engine"})]}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"serverview/init/time"})}),(0,i.jsx)(s.td,{children:"Time taken to initialize the broker server view. Useful to detect if brokers are taking too long to start."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Depends on the number of segments."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"metadatacache/init/time"})}),(0,i.jsx)(s.td,{children:"Time taken to initialize the broker segment metadata cache. Useful to detect if brokers are taking too long to start"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Depends on the number of segments."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"metadatacache/refresh/count"})}),(0,i.jsx)(s.td,{children:"Number of segments to refresh in broker segment metadata cache."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"metadatacache/refresh/time"})}),(0,i.jsx)(s.td,{children:"Time taken to refresh segments in broker segment metadata cache."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"metadatacache/schemaPoll/count"})}),(0,i.jsx)(s.td,{children:"Number of coordinator polls to fetch datasource schema."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"metadatacache/schemaPoll/failed"})}),(0,i.jsx)(s.td,{children:"Number of failed coordinator polls to fetch datasource schema."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"metadatacache/schemaPoll/time"})}),(0,i.jsx)(s.td,{children:"Time taken for coordinator polls to fetch datasource schema."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"serverview/sync/healthy"})}),(0,i.jsxs)(s.td,{children:["Sync status of the Broker with a segment-loading server such as a Historical or Peon. Emitted only when ",(0,i.jsx)(s.a,{href:"/docs/latest/configuration/#segment-management",children:"HTTP-based server view"})," is enabled. This metric can be used in conjunction with ",(0,i.jsx)(s.code,{children:"serverview/sync/unstableTime"})," to debug slow startup of Brokers."]}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"server"}),", ",(0,i.jsx)(s.code,{children:"tier"})]}),(0,i.jsx)(s.td,{children:"1 for fully synced servers, 0 otherwise"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"serverview/sync/unstableTime"})}),(0,i.jsxs)(s.td,{children:["Time in milliseconds for which the Broker has been failing to sync with a segment-loading server. Emitted only when ",(0,i.jsx)(s.a,{href:"/docs/latest/configuration/#segment-management",children:"HTTP-based server view"})," is enabled."]}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"server"}),", ",(0,i.jsx)(s.code,{children:"tier"})]}),(0,i.jsx)(s.td,{children:"Not emitted for synced servers."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"subquery/rows"})}),(0,i.jsx)(s.td,{children:"Number of rows materialized by the subquery's results."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"id"}),", ",(0,i.jsx)(s.code,{children:"subqueryId"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"subquery/bytes"})}),(0,i.jsxs)(s.td,{children:["Number of bytes materialized by the subquery's results. This metric is only emitted if the query uses ",(0,i.jsx)(s.a,{href:"https://druid.apache.org/docs/latest/configuration/#guardrails-for-materialization-of-subqueries",children:"byte-based subquery guardrails"})]}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"id"}),", ",(0,i.jsx)(s.code,{children:"subqueryId"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"subquery/rowLimit/count"})}),(0,i.jsx)(s.td,{children:"Number of subqueries whose results are materialized as rows (Java objects on heap)."}),(0,i.jsxs)(s.td,{children:["This metric is only available if the ",(0,i.jsx)(s.code,{children:"SubqueryCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"subquery/byteLimit/count"})}),(0,i.jsx)(s.td,{children:"Number of subqueries whose results are materialized as frames (Druid's internal byte representation of rows)."}),(0,i.jsxs)(s.td,{children:["This metric is only available if the ",(0,i.jsx)(s.code,{children:"SubqueryCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"subquery/fallback/count"})}),(0,i.jsx)(s.td,{children:"Number of subqueries which cannot be materialized as frames"}),(0,i.jsxs)(s.td,{children:["This metric is only available if the ",(0,i.jsx)(s.code,{children:"SubqueryCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"subquery/fallback/insufficientType/count"})}),(0,i.jsx)(s.td,{children:"Number of subqueries which cannot be materialized as frames due to insufficient type information in the row signature."}),(0,i.jsxs)(s.td,{children:["This metric is only available if the ",(0,i.jsx)(s.code,{children:"SubqueryCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"subquery/fallback/unknownReason/count"})}),(0,i.jsx)(s.td,{children:"Number of subqueries which cannot be materialized as frames due other reasons."}),(0,i.jsxs)(s.td,{children:["This metric is only available if the ",(0,i.jsx)(s.code,{children:"SubqueryCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/rowLimit/exceeded/count"})}),(0,i.jsx)(s.td,{children:"Number of queries whose inlined subquery results exceeded the given row limit"}),(0,i.jsxs)(s.td,{children:["This metric is only available if the ",(0,i.jsx)(s.code,{children:"SubqueryCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/byteLimit/exceeded/count"})}),(0,i.jsx)(s.td,{children:"Number of queries whose inlined subquery results exceeded the given byte limit"}),(0,i.jsxs)(s.td,{children:["This metric is only available if the ",(0,i.jsx)(s.code,{children:"SubqueryCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{})]})]})]}),"\n",(0,i.jsx)(s.h3,{id:"historical",children:"Historical"}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Metric"}),(0,i.jsx)(s.th,{children:"Description"}),(0,i.jsx)(s.th,{children:"Dimensions"}),(0,i.jsx)(s.th,{children:"Normal value"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/time"})}),(0,i.jsx)(s.td,{children:"Milliseconds taken to complete a query."}),(0,i.jsxs)(s.td,{children:[(0,i.jsxs)("p",{children:["Common: ",(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"type"}),", ",(0,i.jsx)(s.code,{children:"interval"}),", ",(0,i.jsx)(s.code,{children:"hasFilters"}),", ",(0,i.jsx)(s.code,{children:"duration"}),", ",(0,i.jsx)(s.code,{children:"context"}),", ",(0,i.jsx)(s.code,{children:"remoteAddress"}),", ",(0,i.jsx)(s.code,{children:"id"}),"."]}),(0,i.jsxs)("p",{children:[" Aggregation Queries: ",(0,i.jsx)(s.code,{children:"numMetrics"}),", ",(0,i.jsx)(s.code,{children:"numComplexMetrics"}),"."]}),(0,i.jsxs)("p",{children:[" GroupBy: ",(0,i.jsx)(s.code,{children:"numDimensions"}),"."]}),(0,i.jsxs)("p",{children:[" TopN: ",(0,i.jsx)(s.code,{children:"threshold"}),", ",(0,i.jsx)(s.code,{children:"dimension"}),"."]})]}),(0,i.jsx)(s.td,{children:"< 1s"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/segment/time"})}),(0,i.jsx)(s.td,{children:"Milliseconds taken to query individual segment. Includes time to page in the segment from disk."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"id"}),", ",(0,i.jsx)(s.code,{children:"status"}),", ",(0,i.jsx)(s.code,{children:"segment"}),", ",(0,i.jsx)(s.code,{children:"vectorized"}),"."]}),(0,i.jsx)(s.td,{children:"several hundred milliseconds"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/wait/time"})}),(0,i.jsx)(s.td,{children:"Milliseconds spent waiting for a segment to be scanned."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"id"}),", ",(0,i.jsx)(s.code,{children:"segment"})]}),(0,i.jsx)(s.td,{children:"< several hundred milliseconds"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/scan/pending"})}),(0,i.jsx)(s.td,{children:"Number of segments in queue waiting to be scanned."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Close to 0"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/scan/active"})}),(0,i.jsxs)(s.td,{children:["Number of segments currently scanned. This metric also indicates how many threads from ",(0,i.jsx)(s.code,{children:"druid.processing.numThreads"})," are currently being used."]}),(0,i.jsx)(s.td,{}),(0,i.jsxs)(s.td,{children:["Close to ",(0,i.jsx)(s.code,{children:"druid.processing.numThreads"})]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/segmentAndCache/time"})}),(0,i.jsx)(s.td,{children:"Milliseconds taken to query individual segment or hit the cache (if it is enabled on the Historical process)."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"id"}),", ",(0,i.jsx)(s.code,{children:"segment"})]}),(0,i.jsx)(s.td,{children:"several hundred milliseconds"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/cpu/time"})}),(0,i.jsx)(s.td,{children:"Microseconds of CPU time taken to complete a query."}),(0,i.jsxs)(s.td,{children:[(0,i.jsxs)("p",{children:["Common: ",(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"type"}),", ",(0,i.jsx)(s.code,{children:"interval"}),", ",(0,i.jsx)(s.code,{children:"hasFilters"}),", ",(0,i.jsx)(s.code,{children:"duration"}),", ",(0,i.jsx)(s.code,{children:"context"}),", ",(0,i.jsx)(s.code,{children:"remoteAddress"}),", ",(0,i.jsx)(s.code,{children:"id"}),"."]}),(0,i.jsxs)("p",{children:[" Aggregation Queries: ",(0,i.jsx)(s.code,{children:"numMetrics"}),", ",(0,i.jsx)(s.code,{children:"numComplexMetrics"}),"."]}),(0,i.jsxs)("p",{children:[" GroupBy: ",(0,i.jsx)(s.code,{children:"numDimensions"}),"."]}),(0,i.jsxs)("p",{children:[" TopN: ",(0,i.jsx)(s.code,{children:"threshold"}),", ",(0,i.jsx)(s.code,{children:"dimension"}),"."]})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/count"})}),(0,i.jsx)(s.td,{children:"Total number of queries."}),(0,i.jsxs)(s.td,{children:["This metric is only available if the ",(0,i.jsx)(s.code,{children:"QueryCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/success/count"})}),(0,i.jsx)(s.td,{children:"Number of queries successfully processed."}),(0,i.jsxs)(s.td,{children:["This metric is only available if the ",(0,i.jsx)(s.code,{children:"QueryCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/failed/count"})}),(0,i.jsx)(s.td,{children:"Number of failed queries."}),(0,i.jsxs)(s.td,{children:["This metric is only available if the ",(0,i.jsx)(s.code,{children:"QueryCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/interrupted/count"})}),(0,i.jsx)(s.td,{children:"Number of queries interrupted due to cancellation."}),(0,i.jsxs)(s.td,{children:["This metric is only available if the ",(0,i.jsx)(s.code,{children:"QueryCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/timeout/count"})}),(0,i.jsx)(s.td,{children:"Number of timed out queries."}),(0,i.jsxs)(s.td,{children:["This metric is only available if the ",(0,i.jsx)(s.code,{children:"QueryCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{})]})]})]}),"\n",(0,i.jsx)(s.h3,{id:"real-time",children:"Real-time"}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Metric"}),(0,i.jsx)(s.th,{children:"Description"}),(0,i.jsx)(s.th,{children:"Dimensions"}),(0,i.jsx)(s.th,{children:"Normal value"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/time"})}),(0,i.jsx)(s.td,{children:"Milliseconds taken to complete a query."}),(0,i.jsxs)(s.td,{children:[(0,i.jsxs)("p",{children:["Common: ",(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"type"}),", ",(0,i.jsx)(s.code,{children:"interval"}),", ",(0,i.jsx)(s.code,{children:"hasFilters"}),", ",(0,i.jsx)(s.code,{children:"duration"}),", ",(0,i.jsx)(s.code,{children:"context"}),", ",(0,i.jsx)(s.code,{children:"remoteAddress"}),", ",(0,i.jsx)(s.code,{children:"id"}),"."]}),(0,i.jsxs)("p",{children:[" Aggregation Queries: ",(0,i.jsx)(s.code,{children:"numMetrics"}),", ",(0,i.jsx)(s.code,{children:"numComplexMetrics"}),"."]}),(0,i.jsxs)("p",{children:[" GroupBy: ",(0,i.jsx)(s.code,{children:"numDimensions"}),"."]}),(0,i.jsxs)("p",{children:[" TopN: ",(0,i.jsx)(s.code,{children:"threshold"}),", ",(0,i.jsx)(s.code,{children:"dimension"}),"."]})]}),(0,i.jsx)(s.td,{children:"< 1s"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/wait/time"})}),(0,i.jsx)(s.td,{children:"Milliseconds spent waiting for a segment to be scanned."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"id"}),", ",(0,i.jsx)(s.code,{children:"segment"})]}),(0,i.jsx)(s.td,{children:"several hundred milliseconds"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/scan/pending"})}),(0,i.jsx)(s.td,{children:"Number of segments in queue waiting to be scanned."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Close to 0"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/scan/active"})}),(0,i.jsxs)(s.td,{children:["Number of segments currently scanned. This metric also indicates how many threads from ",(0,i.jsx)(s.code,{children:"druid.processing.numThreads"})," are currently being used."]}),(0,i.jsx)(s.td,{}),(0,i.jsxs)(s.td,{children:["Close to ",(0,i.jsx)(s.code,{children:"druid.processing.numThreads"})]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/cpu/time"})}),(0,i.jsx)(s.td,{children:"Microseconds of CPU time taken to complete a query."}),(0,i.jsxs)(s.td,{children:[(0,i.jsxs)("p",{children:["Common: ",(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"type"}),", ",(0,i.jsx)(s.code,{children:"interval"}),", ",(0,i.jsx)(s.code,{children:"hasFilters"}),", ",(0,i.jsx)(s.code,{children:"duration"}),", ",(0,i.jsx)(s.code,{children:"context"}),", ",(0,i.jsx)(s.code,{children:"remoteAddress"}),", ",(0,i.jsx)(s.code,{children:"id"}),"."]}),(0,i.jsxs)("p",{children:[" Aggregation Queries: ",(0,i.jsx)(s.code,{children:"numMetrics"}),", ",(0,i.jsx)(s.code,{children:"numComplexMetrics"}),"."]}),(0,i.jsxs)("p",{children:[" GroupBy: ",(0,i.jsx)(s.code,{children:"numDimensions"}),". "]}),(0,i.jsxs)("p",{children:["TopN: ",(0,i.jsx)(s.code,{children:"threshold"}),", ",(0,i.jsx)(s.code,{children:"dimension"}),"."]})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/count"})}),(0,i.jsx)(s.td,{children:"Number of total queries."}),(0,i.jsxs)(s.td,{children:["This metric is only available if the ",(0,i.jsx)(s.code,{children:"QueryCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/success/count"})}),(0,i.jsx)(s.td,{children:"Number of queries successfully processed."}),(0,i.jsxs)(s.td,{children:["This metric is only available if the ",(0,i.jsx)(s.code,{children:"QueryCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/failed/count"})}),(0,i.jsx)(s.td,{children:"Number of failed queries."}),(0,i.jsxs)(s.td,{children:["This metric is only available if the ",(0,i.jsx)(s.code,{children:"QueryCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/interrupted/count"})}),(0,i.jsx)(s.td,{children:"Number of queries interrupted due to cancellation."}),(0,i.jsxs)(s.td,{children:["This metric is only available if the ",(0,i.jsx)(s.code,{children:"QueryCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/timeout/count"})}),(0,i.jsx)(s.td,{children:"Number of timed out queries."}),(0,i.jsxs)(s.td,{children:["This metric is only available if the ",(0,i.jsx)(s.code,{children:"QueryCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{})]})]})]}),"\n",(0,i.jsx)(s.h3,{id:"groupby-query-metrics",children:"GroupBy query metrics"}),"\n",(0,i.jsx)(s.p,{children:"These metrics are reported from broker, historical and real-time nodes"}),"\n",(0,i.jsxs)(s.p,{children:["|",(0,i.jsx)(s.code,{children:"mergeBuffer/pendingRequests"}),"|Number of requests waiting to acquire a batch of buffers from the merge buffer pool.|This metric is only available if the ",(0,i.jsx)(s.code,{children:"GroupByStatsMonitor"})," module is included.|Should be ideally 0, though a higher number isn't representative of a problem.|\n|",(0,i.jsx)(s.code,{children:"mergeBuffer/used"}),"|Number of merge buffers used from the merge buffer pool.|This metric is only available if the ",(0,i.jsx)(s.code,{children:"GroupByStatsMonitor"})," module is included.|Depends on the number of groupBy queries needing merge buffers.|\n|",(0,i.jsx)(s.code,{children:"mergeBuffer/queries"}),"|Number of groupBy queries that acquired a batch of buffers from the merge buffer pool.|This metric is only available if the ",(0,i.jsx)(s.code,{children:"GroupByStatsMonitor"})," module is included.|Depends on the number of groupBy queries needing merge buffers.|\n|",(0,i.jsx)(s.code,{children:"mergeBuffer/acquisitionTimeNs"}),"|Total time in nanoseconds to acquire merge buffer for groupBy queries.|This metric is only available if the ",(0,i.jsx)(s.code,{children:"GroupByStatsMonitor"})," module is included.|Varies|\n|",(0,i.jsx)(s.code,{children:"groupBy/spilledQueries"}),"|Number of groupBy queries that have spilled onto the disk.|This metric is only available if the ",(0,i.jsx)(s.code,{children:"GroupByStatsMonitor"})," module is included.|Varies|\n|",(0,i.jsx)(s.code,{children:"groupBy/spilledBytes"}),"|Number of bytes spilled on the disk by the groupBy queries.|This metric is only available if the ",(0,i.jsx)(s.code,{children:"GroupByStatsMonitor"})," module is included.|Varies|\n|",(0,i.jsx)(s.code,{children:"groupBy/mergeDictionarySize"}),"|Size of on-heap merge dictionary in bytes.|This metric is only available if the ",(0,i.jsx)(s.code,{children:"GroupByStatsMonitor"})," module is included.|Varies|"]}),"\n",(0,i.jsx)(s.h3,{id:"jetty",children:"Jetty"}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Metric"}),(0,i.jsx)(s.th,{children:"Description"}),(0,i.jsx)(s.th,{children:"Normal value"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"jetty/numOpenConnections"})}),(0,i.jsx)(s.td,{children:"Number of open jetty connections."}),(0,i.jsx)(s.td,{children:"Not much higher than number of jetty threads."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"jetty/threadPool/total"})}),(0,i.jsx)(s.td,{children:"Number of total workable threads allocated."}),(0,i.jsxs)(s.td,{children:["The number should equal to ",(0,i.jsx)(s.code,{children:"threadPoolNumIdleThreads"})," + ",(0,i.jsx)(s.code,{children:"threadPoolNumBusyThreads"}),"."]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"jetty/threadPool/idle"})}),(0,i.jsx)(s.td,{children:"Number of idle threads."}),(0,i.jsxs)(s.td,{children:["Less than or equal to ",(0,i.jsx)(s.code,{children:"threadPoolNumTotalThreads"}),". Non zero number means there is less work to do than configured capacity."]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"jetty/threadPool/busy"})}),(0,i.jsx)(s.td,{children:"Number of busy threads that has work to do from the worker queue."}),(0,i.jsxs)(s.td,{children:["Less than or equal to ",(0,i.jsx)(s.code,{children:"threadPoolNumTotalThreads"}),"."]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"jetty/threadPool/isLowOnThreads"})}),(0,i.jsx)(s.td,{children:"A rough indicator of whether number of total workable threads allocated is enough to handle the works in the work queue."}),(0,i.jsx)(s.td,{children:"0"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"jetty/threadPool/min"})}),(0,i.jsx)(s.td,{children:"Number of minimum threads allocatable."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"druid.server.http.numThreads"})," plus a small fixed number of threads allocated for Jetty acceptors and selectors."]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"jetty/threadPool/max"})}),(0,i.jsx)(s.td,{children:"Number of maximum threads allocatable."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"druid.server.http.numThreads"})," plus a small fixed number of threads allocated for Jetty acceptors and selectors."]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"jetty/threadPool/queueSize"})}),(0,i.jsx)(s.td,{children:"Size of the worker queue."}),(0,i.jsxs)(s.td,{children:["Not much higher than ",(0,i.jsx)(s.code,{children:"druid.server.http.queueSize"}),"."]})]})]})]}),"\n",(0,i.jsx)(s.h3,{id:"cache",children:"Cache"}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Metric"}),(0,i.jsx)(s.th,{children:"Description"}),(0,i.jsx)(s.th,{children:"Dimensions"}),(0,i.jsx)(s.th,{children:"Normal value"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/cache/delta/*"})}),(0,i.jsx)(s.td,{children:"Cache metrics since the last emission."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"N/A"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/cache/total/*"})}),(0,i.jsx)(s.td,{children:"Total cache metrics."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"N/A"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"*/numEntries"})}),(0,i.jsx)(s.td,{children:"Number of cache entries."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"*/sizeBytes"})}),(0,i.jsx)(s.td,{children:"Size in bytes of cache entries."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"*/hits"})}),(0,i.jsx)(s.td,{children:"Number of cache hits."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"*/misses"})}),(0,i.jsx)(s.td,{children:"Number of cache misses."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"*/evictions"})}),(0,i.jsx)(s.td,{children:"Number of cache evictions."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"*/hitRate"})}),(0,i.jsx)(s.td,{children:"Cache hit rate."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"~40%"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"*/averageByte"})}),(0,i.jsx)(s.td,{children:"Average cache entry byte size."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"*/timeouts"})}),(0,i.jsx)(s.td,{children:"Number of cache timeouts."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"0"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"*/errors"})}),(0,i.jsx)(s.td,{children:"Number of cache errors."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"0"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"*/put/ok"})}),(0,i.jsx)(s.td,{children:"Number of new cache entries successfully cached."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies, but more than zero"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"*/put/error"})}),(0,i.jsx)(s.td,{children:"Number of new cache entries that could not be cached due to errors."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies, but more than zero"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"*/put/oversized"})}),(0,i.jsxs)(s.td,{children:["Number of potential new cache entries that were skipped due to being too large (based on ",(0,i.jsx)(s.code,{children:"druid.{broker,historical,realtime}.cache.maxEntrySize"})," properties)."]}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]})]})]}),"\n",(0,i.jsx)(s.h4,{id:"memcached-only-metrics",children:"Memcached only metrics"}),"\n",(0,i.jsx)(s.p,{children:"Memcached client metrics are reported as per the following. These metrics come directly from the client as opposed to from the cache retrieval layer."}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Metric"}),(0,i.jsx)(s.th,{children:"Description"}),(0,i.jsx)(s.th,{children:"Dimensions"}),(0,i.jsx)(s.th,{children:"Normal value"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/cache/memcached/total"})}),(0,i.jsxs)(s.td,{children:["Cache metrics unique to memcached (only if ",(0,i.jsx)(s.code,{children:"druid.cache.type=memcached"}),") as their actual values."]}),(0,i.jsx)(s.td,{children:"Variable"}),(0,i.jsx)(s.td,{children:"N/A"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"query/cache/memcached/delta"})}),(0,i.jsxs)(s.td,{children:["Cache metrics unique to memcached (only if ",(0,i.jsx)(s.code,{children:"druid.cache.type=memcached"}),") as their delta from the prior event emission."]}),(0,i.jsx)(s.td,{children:"Variable"}),(0,i.jsx)(s.td,{children:"N/A"})]})]})]}),"\n",(0,i.jsx)(s.h2,{id:"sql-metrics",children:"SQL Metrics"}),"\n",(0,i.jsx)(s.p,{children:"If SQL is enabled, the Broker will emit the following metrics for SQL."}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Metric"}),(0,i.jsx)(s.th,{children:"Description"}),(0,i.jsx)(s.th,{children:"Dimensions"}),(0,i.jsx)(s.th,{children:"Normal value"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sqlQuery/time"})}),(0,i.jsx)(s.td,{children:"Milliseconds taken to complete a SQL."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"id"}),", ",(0,i.jsx)(s.code,{children:"nativeQueryIds"}),", ",(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"remoteAddress"}),", ",(0,i.jsx)(s.code,{children:"success"}),", ",(0,i.jsx)(s.code,{children:"engine"})]}),(0,i.jsx)(s.td,{children:"< 1s"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sqlQuery/planningTimeMs"})}),(0,i.jsx)(s.td,{children:"Milliseconds taken to plan a SQL to native query."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"id"}),", ",(0,i.jsx)(s.code,{children:"nativeQueryIds"}),", ",(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"remoteAddress"}),", ",(0,i.jsx)(s.code,{children:"success"}),", ",(0,i.jsx)(s.code,{children:"engine"})]}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sqlQuery/bytes"})}),(0,i.jsx)(s.td,{children:"number of bytes returned in SQL response."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"id"}),", ",(0,i.jsx)(s.code,{children:"nativeQueryIds"}),", ",(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"remoteAddress"}),", ",(0,i.jsx)(s.code,{children:"success"}),", ",(0,i.jsx)(s.code,{children:"engine"})]}),(0,i.jsx)(s.td,{})]})]})]}),"\n",(0,i.jsx)(s.h2,{id:"ingestion-metrics",children:"Ingestion metrics"}),"\n",(0,i.jsx)(s.h3,{id:"general-native-ingestion-metrics",children:"General native ingestion metrics"}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Metric"}),(0,i.jsx)(s.th,{children:"Description"}),(0,i.jsx)(s.th,{children:"Dimensions"}),(0,i.jsx)(s.th,{children:"Normal value"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/count"})}),(0,i.jsxs)(s.td,{children:["Count of ",(0,i.jsx)(s.code,{children:"1"})," every time an ingestion job runs (includes compaction jobs). Aggregate using dimensions."]}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),", ",(0,i.jsx)(s.code,{children:"taskIngestionMode"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsxs)(s.td,{children:["Always ",(0,i.jsx)(s.code,{children:"1"}),"."]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/segments/count"})}),(0,i.jsx)(s.td,{children:"Count of final segments created by job (includes tombstones)."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),", ",(0,i.jsx)(s.code,{children:"taskIngestionMode"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsxs)(s.td,{children:["At least ",(0,i.jsx)(s.code,{children:"1"}),"."]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/tombstones/count"})}),(0,i.jsx)(s.td,{children:"Count of tombstones created by job."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),", ",(0,i.jsx)(s.code,{children:"taskIngestionMode"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"Zero or more for replace. Always zero for non-replace tasks (always zero for legacy replace, see below)."})]})]})]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"taskIngestionMode"})," dimension includes the following modes:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"APPEND"}),": a native ingestion job appending to existing segments"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"REPLACE_LEGACY"}),": the original replace before tombstones"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"REPLACE"}),": a native ingestion job replacing existing segments using tombstones"]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["The mode is decided using the values\nof the ",(0,i.jsx)(s.code,{children:"isAppendToExisting"})," and ",(0,i.jsx)(s.code,{children:"isDropExisting"})," flags in the\ntask's ",(0,i.jsx)(s.code,{children:"IOConfig"})," as follows:"]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:(0,i.jsx)(s.code,{children:"isAppendToExisting"})}),(0,i.jsx)(s.th,{children:(0,i.jsx)(s.code,{children:"isDropExisting"})}),(0,i.jsx)(s.th,{children:"Mode"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"true"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"false"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"APPEND"})})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"true"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"true "})}),(0,i.jsx)(s.td,{children:"Invalid combination, exception thrown."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"false"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"false"})}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"REPLACE_LEGACY"}),". The default for JSON-based batch ingestion."]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"false"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"true"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"REPLACE"})})]})]})]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"tags"})," dimension is reported only for metrics emitted from ingestion tasks whose ingest spec specifies the ",(0,i.jsx)(s.code,{children:"tags"}),"\nfield in the ",(0,i.jsx)(s.code,{children:"context"})," field of the ingestion spec. ",(0,i.jsx)(s.code,{children:"tags"})," is expected to be a map of string to object."]}),"\n",(0,i.jsx)(s.h3,{id:"ingestion-metrics-for-kafka",children:"Ingestion metrics for Kafka"}),"\n",(0,i.jsxs)(s.p,{children:["These metrics apply to the ",(0,i.jsx)(s.a,{href:"/docs/latest/ingestion/kafka-ingestion",children:"Kafka indexing service"}),"."]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Metric"}),(0,i.jsx)(s.th,{children:"Description"}),(0,i.jsx)(s.th,{children:"Dimensions"}),(0,i.jsx)(s.th,{children:"Normal value"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/kafka/lag"})}),(0,i.jsx)(s.td,{children:"Total lag between the offsets consumed by the Kafka indexing tasks and latest offsets in Kafka brokers across all partitions. Minimum emission period for this metric is a minute."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"stream"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"Greater than 0, should not be a very high number."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/kafka/maxLag"})}),(0,i.jsx)(s.td,{children:"Max lag between the offsets consumed by the Kafka indexing tasks and latest offsets in Kafka brokers across all partitions. Minimum emission period for this metric is a minute."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"stream"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"Greater than 0, should not be a very high number."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/kafka/avgLag"})}),(0,i.jsx)(s.td,{children:"Average lag between the offsets consumed by the Kafka indexing tasks and latest offsets in Kafka brokers across all partitions. Minimum emission period for this metric is a minute."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"stream"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"Greater than 0, should not be a very high number."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/kafka/partitionLag"})}),(0,i.jsx)(s.td,{children:"Partition-wise lag between the offsets consumed by the Kafka indexing tasks and latest offsets in Kafka brokers. Minimum emission period for this metric is a minute."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"stream"}),", ",(0,i.jsx)(s.code,{children:"partition"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"Greater than 0, should not be a very high number."})]})]})]}),"\n",(0,i.jsx)(s.h3,{id:"ingestion-metrics-for-kinesis",children:"Ingestion metrics for Kinesis"}),"\n",(0,i.jsxs)(s.p,{children:["These metrics apply to the ",(0,i.jsx)(s.a,{href:"/docs/latest/ingestion/kinesis-ingestion",children:"Kinesis indexing service"}),"."]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Metric"}),(0,i.jsx)(s.th,{children:"Description"}),(0,i.jsx)(s.th,{children:"Dimensions"}),(0,i.jsx)(s.th,{children:"Normal value"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/kinesis/lag/time"})}),(0,i.jsx)(s.td,{children:"Total lag time in milliseconds between the current message sequence number consumed by the Kinesis indexing tasks and latest sequence number in Kinesis across all shards. Minimum emission period for this metric is a minute."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"stream"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"Greater than 0, up to max Kinesis retention period in milliseconds."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/kinesis/maxLag/time"})}),(0,i.jsx)(s.td,{children:"Max lag time in milliseconds between the current message sequence number consumed by the Kinesis indexing tasks and latest sequence number in Kinesis across all shards. Minimum emission period for this metric is a minute."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"stream"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"Greater than 0, up to max Kinesis retention period in milliseconds."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/kinesis/avgLag/time"})}),(0,i.jsx)(s.td,{children:"Average lag time in milliseconds between the current message sequence number consumed by the Kinesis indexing tasks and latest sequence number in Kinesis across all shards. Minimum emission period for this metric is a minute."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"stream"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"Greater than 0, up to max Kinesis retention period in milliseconds."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/kinesis/partitionLag/time"})}),(0,i.jsx)(s.td,{children:"Partition-wise lag time in milliseconds between the current message sequence number consumed by the Kinesis indexing tasks and latest sequence number in Kinesis. Minimum emission period for this metric is a minute."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"stream"}),", ",(0,i.jsx)(s.code,{children:"partition"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"Greater than 0, up to max Kinesis retention period in milliseconds."})]})]})]}),"\n",(0,i.jsx)(s.h3,{id:"compaction-metrics",children:"Compaction metrics"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.a,{href:"/docs/latest/data-management/compaction",children:"Compaction tasks"})," emit the following metrics."]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Metric"}),(0,i.jsx)(s.th,{children:"Description"}),(0,i.jsx)(s.th,{children:"Dimensions"}),(0,i.jsx)(s.th,{children:"Normal value"})]})}),(0,i.jsx)(s.tbody,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"compact/segmentAnalyzer/fetchAndProcessMillis"})}),(0,i.jsx)(s.td,{children:"Time taken to fetch and process segments to infer the schema for the compaction task to run."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),",",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"Varies. A high value indicates compaction tasks will speed up from explicitly setting the data schema."})]})})]}),"\n",(0,i.jsx)(s.h3,{id:"other-ingestion-metrics",children:"Other ingestion metrics"}),"\n",(0,i.jsx)(s.p,{children:"Streaming ingestion tasks and certain types of\nbatch ingestion emit the following metrics. These metrics are deltas for each emission period."}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Metric"}),(0,i.jsx)(s.th,{children:"Description"}),(0,i.jsx)(s.th,{children:"Dimensions"}),(0,i.jsx)(s.th,{children:"Normal value"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/events/processed"})}),(0,i.jsx)(s.td,{children:"Number of events processed per emission period."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"Equal to the number of events per emission period."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/events/processedWithError"})}),(0,i.jsxs)(s.td,{children:["Number of events processed with some partial errors per emission period. Events processed with partial errors are counted towards both this metric and ",(0,i.jsx)(s.code,{children:"ingest/events/processed"}),"."]}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"0"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/events/unparseable"})}),(0,i.jsx)(s.td,{children:"Number of events rejected because the events are unparseable."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"0"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/events/thrownAway"})}),(0,i.jsxs)(s.td,{children:["Number of events rejected because they are null, or filtered by ",(0,i.jsx)(s.code,{children:"transformSpec"}),", or outside one of ",(0,i.jsx)(s.code,{children:"lateMessageRejectionPeriod"}),", ",(0,i.jsx)(s.code,{children:"earlyMessageRejectionPeriod"}),", or ",(0,i.jsx)(s.code,{children:"windowPeriod"}),"."]}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"0"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/events/duplicate"})}),(0,i.jsx)(s.td,{children:"Number of events rejected because the events are duplicated."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"0"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/input/bytes"})}),(0,i.jsx)(s.td,{children:"Number of bytes read from input sources, after decompression but prior to parsing. This covers all data read, including data that does not end up being fully processed and ingested. For example, this includes data that ends up being rejected for being unparseable or filtered out."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"Depends on the amount of data read."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/rows/output"})}),(0,i.jsx)(s.td,{children:"Number of Druid rows persisted."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"})]}),(0,i.jsx)(s.td,{children:"Your number of events with rollup."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/persists/count"})}),(0,i.jsx)(s.td,{children:"Number of times persist occurred."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"Depends on the configuration."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/persists/time"})}),(0,i.jsx)(s.td,{children:"Milliseconds spent doing intermediate persist."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"Depends on the configuration. Generally a few minutes at most."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/persists/cpu"})}),(0,i.jsx)(s.td,{children:"CPU time in nanoseconds spent on doing intermediate persist."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"Depends on the configuration. Generally a few minutes at most."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/persists/backPressure"})}),(0,i.jsx)(s.td,{children:"Milliseconds spent creating persist tasks and blocking waiting for them to finish."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"0 or very low"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/persists/failed"})}),(0,i.jsx)(s.td,{children:"Number of persists that failed."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"0"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/handoff/failed"})}),(0,i.jsx)(s.td,{children:"Number of handoffs that failed."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),",",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"0"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/merge/time"})}),(0,i.jsx)(s.td,{children:"Milliseconds spent merging intermediate segments."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"Depends on the configuration. Generally a few minutes at most."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/merge/cpu"})}),(0,i.jsx)(s.td,{children:"CPU time in Nanoseconds spent on merging intermediate segments."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"Depends on the configuration. Generally a few minutes at most."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/handoff/count"})}),(0,i.jsx)(s.td,{children:"Number of handoffs that happened."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"Varies. Generally greater than 0 once every segment granular period if cluster operating normally."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/sink/count"})}),(0,i.jsx)(s.td,{children:"Number of sinks not handed off."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"1~3"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/events/messageGap"})}),(0,i.jsx)(s.td,{children:"Time gap in milliseconds between the latest ingested event timestamp and the current system timestamp of metrics emission. If the value is increasing but lag is low, Druid may not be receiving new data. This metric is reset as new tasks spawn up."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"Greater than 0, depends on the time carried in event."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/notices/queueSize"})}),(0,i.jsx)(s.td,{children:"Number of pending notices to be processed by the coordinator."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"Typically 0 and occasionally in lower single digits. Should not be a very high number."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/notices/time"})}),(0,i.jsx)(s.td,{children:"Milliseconds taken to process a notice by the supervisor."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"< 1s"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/pause/time"})}),(0,i.jsx)(s.td,{children:"Milliseconds spent by a task in a paused state without ingesting."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"< 10 seconds"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/handoff/time"})}),(0,i.jsx)(s.td,{children:"Total number of milliseconds taken to handoff a set of segments."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"Depends on the coordinator cycle time."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"task/autoScaler/requiredCount"})}),(0,i.jsxs)(s.td,{children:["Count of required tasks based on the calculations of ",(0,i.jsx)(s.code,{children:"lagBased"})," auto scaler."]}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"stream"}),", ",(0,i.jsx)(s.code,{children:"scalingSkipReason"})]}),(0,i.jsx)(s.td,{children:"Depends on auto scaler config."})]})]})]}),"\n",(0,i.jsxs)(s.p,{children:["If the JVM does not support CPU time measurement for the current thread, ",(0,i.jsx)(s.code,{children:"ingest/merge/cpu"})," and ",(0,i.jsx)(s.code,{children:"ingest/persists/cpu"})," will be 0."]}),"\n",(0,i.jsx)(s.h2,{id:"indexing-service",children:"Indexing service"}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Metric"}),(0,i.jsx)(s.th,{children:"Description"}),(0,i.jsx)(s.th,{children:"Dimensions"}),(0,i.jsx)(s.th,{children:"Normal value"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"task/run/time"})}),(0,i.jsx)(s.td,{children:"Milliseconds taken to run a task."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),", ",(0,i.jsx)(s.code,{children:"taskStatus"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"task/pending/time"})}),(0,i.jsx)(s.td,{children:"Milliseconds taken for a task to wait for running."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"task/action/log/time"})}),(0,i.jsx)(s.td,{children:"Milliseconds taken to log a task action to the audit log."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),", ",(0,i.jsx)(s.code,{children:"taskActionType"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"< 1000 (subsecond)"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"task/action/run/time"})}),(0,i.jsx)(s.td,{children:"Milliseconds taken to execute a task action."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),", ",(0,i.jsx)(s.code,{children:"taskActionType"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"Varies from subsecond to a few seconds, based on action type."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"task/action/success/count"})}),(0,i.jsxs)(s.td,{children:["Number of task actions that were executed successfully during the emission period. Currently only being emitted for ",(0,i.jsxs)(s.a,{href:"/docs/latest/ingestion/tasks#batching-segmentallocate-actions",children:["batched ",(0,i.jsx)(s.code,{children:"segmentAllocate"})," actions"]}),"."]}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),", ",(0,i.jsx)(s.code,{children:"taskActionType"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"task/action/failed/count"})}),(0,i.jsxs)(s.td,{children:["Number of task actions that failed during the emission period. Currently only being emitted for ",(0,i.jsxs)(s.a,{href:"/docs/latest/ingestion/tasks#batching-segmentallocate-actions",children:["batched ",(0,i.jsx)(s.code,{children:"segmentAllocate"})," actions"]}),"."]}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),", ",(0,i.jsx)(s.code,{children:"taskActionType"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"task/action/batch/queueTime"})}),(0,i.jsxs)(s.td,{children:["Milliseconds spent by a batch of task actions in queue. Currently only being emitted for ",(0,i.jsxs)(s.a,{href:"/docs/latest/ingestion/tasks#batching-segmentallocate-actions",children:["batched ",(0,i.jsx)(s.code,{children:"segmentAllocate"})," actions"]}),"."]}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskActionType"}),", ",(0,i.jsx)(s.code,{children:"interval"})]}),(0,i.jsxs)(s.td,{children:["Varies based on the ",(0,i.jsx)(s.code,{children:"batchAllocationWaitTime"})," and number of batches in queue."]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"task/action/batch/runTime"})}),(0,i.jsxs)(s.td,{children:["Milliseconds taken to execute a batch of task actions. Currently only being emitted for ",(0,i.jsxs)(s.a,{href:"/docs/latest/ingestion/tasks#batching-segmentallocate-actions",children:["batched ",(0,i.jsx)(s.code,{children:"segmentAllocate"})," actions"]}),"."]}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskActionType"}),", ",(0,i.jsx)(s.code,{children:"interval"})]}),(0,i.jsx)(s.td,{children:"Varies from subsecond to a few seconds, based on action type and batch size."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"task/action/batch/size"})}),(0,i.jsxs)(s.td,{children:["Number of task actions in a batch that was executed during the emission period. Currently only being emitted for ",(0,i.jsxs)(s.a,{href:"/docs/latest/ingestion/tasks#batching-segmentallocate-actions",children:["batched ",(0,i.jsx)(s.code,{children:"segmentAllocate"})," actions"]}),"."]}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskActionType"}),", ",(0,i.jsx)(s.code,{children:"interval"})]}),(0,i.jsx)(s.td,{children:"Varies based on number of concurrent task actions."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"task/action/batch/attempts"})}),(0,i.jsxs)(s.td,{children:["Number of execution attempts for a single batch of task actions. Currently only being emitted for ",(0,i.jsxs)(s.a,{href:"/docs/latest/ingestion/tasks#batching-segmentallocate-actions",children:["batched ",(0,i.jsx)(s.code,{children:"segmentAllocate"})," actions"]}),"."]}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskActionType"}),", ",(0,i.jsx)(s.code,{children:"interval"})]}),(0,i.jsx)(s.td,{children:"1 if there are no failures or retries."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"task/segmentAvailability/wait/time"})}),(0,i.jsx)(s.td,{children:"The amount of milliseconds a batch indexing task waited for newly created segments to become available for querying."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"segmentAvailabilityConfirmed"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/added/bytes"})}),(0,i.jsx)(s.td,{children:"Size in bytes of new segments created."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),", ",(0,i.jsx)(s.code,{children:"interval"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/moved/bytes"})}),(0,i.jsx)(s.td,{children:"Size in bytes of segments moved/archived via the Move Task."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),", ",(0,i.jsx)(s.code,{children:"interval"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/nuked/bytes"})}),(0,i.jsx)(s.td,{children:"Size in bytes of segments deleted via the Kill Task."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),", ",(0,i.jsx)(s.code,{children:"interval"}),", ",(0,i.jsx)(s.code,{children:"tags"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"task/success/count"})}),(0,i.jsxs)(s.td,{children:["Number of successful tasks per emission period. This metric is only available if the ",(0,i.jsx)(s.code,{children:"TaskCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"task/failed/count"})}),(0,i.jsxs)(s.td,{children:["Number of failed tasks per emission period. This metric is only available if the ",(0,i.jsx)(s.code,{children:"TaskCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"task/running/count"})}),(0,i.jsxs)(s.td,{children:["Number of current running tasks. This metric is only available if the ",(0,i.jsx)(s.code,{children:"TaskCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"task/pending/count"})}),(0,i.jsxs)(s.td,{children:["Number of current pending tasks. This metric is only available if the ",(0,i.jsx)(s.code,{children:"TaskCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"task/waiting/count"})}),(0,i.jsxs)(s.td,{children:["Number of current waiting tasks. This metric is only available if the ",(0,i.jsx)(s.code,{children:"TaskCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"taskSlot/total/count"})}),(0,i.jsxs)(s.td,{children:["Number of total task slots per emission period. This metric is only available if the ",(0,i.jsx)(s.code,{children:"TaskSlotCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"category"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"taskSlot/idle/count"})}),(0,i.jsxs)(s.td,{children:["Number of idle task slots per emission period. This metric is only available if the ",(0,i.jsx)(s.code,{children:"TaskSlotCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"category"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"taskSlot/used/count"})}),(0,i.jsxs)(s.td,{children:["Number of busy task slots per emission period. This metric is only available if the ",(0,i.jsx)(s.code,{children:"TaskSlotCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"category"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"taskSlot/lazy/count"})}),(0,i.jsxs)(s.td,{children:["Number of total task slots in lazy marked Middle Managers and Indexers per emission period. This metric is only available if the ",(0,i.jsx)(s.code,{children:"TaskSlotCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"category"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"taskSlot/blacklisted/count"})}),(0,i.jsxs)(s.td,{children:["Number of total task slots in blacklisted Middle Managers and Indexers per emission period. This metric is only available if the ",(0,i.jsx)(s.code,{children:"TaskSlotCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"category"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"worker/task/failed/count"})}),(0,i.jsxs)(s.td,{children:["Number of failed tasks run on the reporting worker per emission period. This metric is only available if the ",(0,i.jsx)(s.code,{children:"WorkerTaskCountStatsMonitor"})," module is included, and is only supported for Middle Manager nodes."]}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"category"}),", ",(0,i.jsx)(s.code,{children:"workerVersion"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"worker/task/success/count"})}),(0,i.jsxs)(s.td,{children:["Number of successful tasks run on the reporting worker per emission period. This metric is only available if the ",(0,i.jsx)(s.code,{children:"WorkerTaskCountStatsMonitor"})," module is included, and is only supported for Middle Manager nodes."]}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"category"}),",",(0,i.jsx)(s.code,{children:"workerVersion"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"worker/taskSlot/idle/count"})}),(0,i.jsxs)(s.td,{children:["Number of idle task slots on the reporting worker per emission period. This metric is only available if the ",(0,i.jsx)(s.code,{children:"WorkerTaskCountStatsMonitor"})," module is included, and is only supported for Middle Manager nodes."]}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"category"}),", ",(0,i.jsx)(s.code,{children:"workerVersion"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"worker/taskSlot/total/count"})}),(0,i.jsxs)(s.td,{children:["Number of total task slots on the reporting worker per emission period. This metric is only available if the ",(0,i.jsx)(s.code,{children:"WorkerTaskCountStatsMonitor"})," module is included."]}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"category"}),", ",(0,i.jsx)(s.code,{children:"workerVersion"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"worker/taskSlot/used/count"})}),(0,i.jsxs)(s.td,{children:["Number of busy task slots on the reporting worker per emission period. This metric is only available if the ",(0,i.jsx)(s.code,{children:"WorkerTaskCountStatsMonitor"})," module is included."]}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"category"}),", ",(0,i.jsx)(s.code,{children:"workerVersion"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"worker/task/assigned/count"})}),(0,i.jsxs)(s.td,{children:["Number of tasks assigned to an indexer per emission period. This metric is only available if the ",(0,i.jsx)(s.code,{children:"WorkerTaskCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"worker/task/completed/count"})}),(0,i.jsxs)(s.td,{children:["Number of tasks completed by an indexer per emission period. This metric is only available if the ",(0,i.jsx)(s.code,{children:"WorkerTaskCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"worker/task/failed/count"})}),(0,i.jsxs)(s.td,{children:["Number of tasks that failed on an indexer during the emission period. This metric is only available if the ",(0,i.jsx)(s.code,{children:"WorkerTaskCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"worker/task/success/count"})}),(0,i.jsxs)(s.td,{children:["Number of tasks that succeeded on an indexer during the emission period. This metric is only available if the ",(0,i.jsx)(s.code,{children:"WorkerTaskCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"worker/task/running/count"})}),(0,i.jsxs)(s.td,{children:["Number of tasks running on an indexer per emission period. This metric is only available if the ",(0,i.jsx)(s.code,{children:"WorkerTaskCountStatsMonitor"})," module is included."]}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{children:"Varies"})]})]})]}),"\n",(0,i.jsx)(s.h2,{id:"shuffle-metrics-native-parallel-task",children:"Shuffle metrics (Native parallel task)"}),"\n",(0,i.jsxs)(s.p,{children:["The shuffle metrics can be enabled by adding ",(0,i.jsx)(s.code,{children:"org.apache.druid.indexing.worker.shuffle.ShuffleMonitor"})," in ",(0,i.jsx)(s.code,{children:"druid.monitoring.monitors"}),".\nSee ",(0,i.jsx)(s.a,{href:"/docs/latest/configuration/#enabling-metrics",children:"Enabling metrics"})," for more details."]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Metric"}),(0,i.jsx)(s.th,{children:"Description"}),(0,i.jsx)(s.th,{children:"Dimensions"}),(0,i.jsx)(s.th,{children:"Normal value"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/shuffle/bytes"})}),(0,i.jsx)(s.td,{children:"Number of bytes shuffled per emission period."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"supervisorTaskId"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"ingest/shuffle/requests"})}),(0,i.jsx)(s.td,{children:"Number of shuffle requests per emission period."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"supervisorTaskId"})}),(0,i.jsx)(s.td,{children:"Varies"})]})]})]}),"\n",(0,i.jsx)(s.h2,{id:"coordination",children:"Coordination"}),"\n",(0,i.jsx)(s.p,{children:"These metrics are emitted by the Druid Coordinator in every run of the corresponding coordinator duty."}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Metric"}),(0,i.jsx)(s.th,{children:"Description"}),(0,i.jsx)(s.th,{children:"Dimensions"}),(0,i.jsx)(s.th,{children:"Normal value"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/assigned/count"})}),(0,i.jsx)(s.td,{children:"Number of segments assigned to be loaded in the cluster."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"tier"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/moved/count"})}),(0,i.jsx)(s.td,{children:"Number of segments moved in the cluster."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"tier"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/dropped/count"})}),(0,i.jsx)(s.td,{children:"Number of segments chosen to be dropped from the cluster due to being over-replicated."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"tier"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/deleted/count"})}),(0,i.jsx)(s.td,{children:"Number of segments marked as unused due to drop rules."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/unneeded/count"})}),(0,i.jsx)(s.td,{children:"Number of segments dropped due to being marked as unused."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"tier"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/assignSkipped/count"})}),(0,i.jsx)(s.td,{children:"Number of segments that could not be assigned to any server for loading. This can occur due to replication throttling, no available disk space, or a full load queue."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"tier"}),", ",(0,i.jsx)(s.code,{children:"description"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/moveSkipped/count"})}),(0,i.jsx)(s.td,{children:"Number of segments that were chosen for balancing but could not be moved. This can occur when segments are already optimally placed."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"tier"}),", ",(0,i.jsx)(s.code,{children:"description"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/dropSkipped/count"})}),(0,i.jsx)(s.td,{children:"Number of segments that could not be dropped from any server."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"tier"}),", ",(0,i.jsx)(s.code,{children:"description"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/loadQueue/size"})}),(0,i.jsx)(s.td,{children:"Size in bytes of segments to load."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"server"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/loadQueue/count"})}),(0,i.jsx)(s.td,{children:"Number of segments to load."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"server"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/loading/rateKbps"})}),(0,i.jsx)(s.td,{children:"Current rate of segment loading on a server in kbps (1000 bits per second). The rate is calculated as a moving average over the last 10 GiB or more of successful segment loads on that server."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"server"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/dropQueue/count"})}),(0,i.jsx)(s.td,{children:"Number of segments to drop."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"server"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/loadQueue/assigned"})}),(0,i.jsx)(s.td,{children:"Number of segments assigned for load or drop to the load queue of a server."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"server"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/loadQueue/success"})}),(0,i.jsx)(s.td,{children:"Number of segment assignments that completed successfully."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"server"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/loadQueue/failed"})}),(0,i.jsx)(s.td,{children:"Number of segment assignments that failed to complete."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"server"})]}),(0,i.jsx)(s.td,{children:"0"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/loadQueue/cancelled"})}),(0,i.jsx)(s.td,{children:"Number of segment assignments that were canceled before completion."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"server"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/size"})}),(0,i.jsx)(s.td,{children:"Total size of used segments in a data source. Emitted only for data sources to which at least one used segment belongs."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/count"})}),(0,i.jsx)(s.td,{children:"Number of used segments belonging to a data source. Emitted only for data sources to which at least one used segment belongs."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{children:"< max"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/overShadowed/count"})}),(0,i.jsx)(s.td,{children:"Number of segments marked as unused due to being overshadowed."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/unneededEternityTombstone/count"})}),(0,i.jsx)(s.td,{children:"Number of non-overshadowed eternity tombstones marked as unused."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/unavailable/count"})}),(0,i.jsx)(s.td,{children:"Number of unique segments left to load until all used segments are available for queries."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{children:"0"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/underReplicated/count"})}),(0,i.jsx)(s.td,{children:"Number of segments, including replicas, left to load until all used segments are available for queries."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"tier"}),", ",(0,i.jsx)(s.code,{children:"dataSource"})]}),(0,i.jsx)(s.td,{children:"0"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/availableDeepStorageOnly/count"})}),(0,i.jsx)(s.td,{children:"Number of unique segments that are only available for querying directly from deep storage."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"tier/historical/count"})}),(0,i.jsx)(s.td,{children:"Number of available historical nodes in each tier."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"tier"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"tier/replication/factor"})}),(0,i.jsx)(s.td,{children:"Configured maximum replication factor in each tier."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"tier"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"tier/required/capacity"})}),(0,i.jsx)(s.td,{children:"Total capacity in bytes required in each tier."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"tier"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"tier/total/capacity"})}),(0,i.jsx)(s.td,{children:"Total capacity in bytes available in each tier."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"tier"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"compact/task/count"})}),(0,i.jsx)(s.td,{children:"Number of tasks issued in the auto compaction run."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"compactTask/maxSlot/count"})}),(0,i.jsx)(s.td,{children:"Maximum number of task slots available for auto compaction tasks in the auto compaction run."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"compactTask/availableSlot/count"})}),(0,i.jsx)(s.td,{children:"Number of available task slots that can be used for auto compaction tasks in the auto compaction run. This is the max number of task slots minus any currently running compaction tasks."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"killTask/availableSlot/count"})}),(0,i.jsx)(s.td,{children:"Number of available task slots that can be used for auto kill tasks in the auto kill run. This is the max number of task slots minus any currently running auto kill tasks."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"killTask/maxSlot/count"})}),(0,i.jsx)(s.td,{children:"Maximum number of task slots available for auto kill tasks in the auto kill run."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"kill/task/count"})}),(0,i.jsx)(s.td,{children:"Number of tasks issued in the auto kill run."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"kill/eligibleUnusedSegments/count"})}),(0,i.jsx)(s.td,{children:"The number of unused segments of a datasource that are identified as eligible for deletion from the metadata store by the coordinator."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"kill/pendingSegments/count"})}),(0,i.jsx)(s.td,{children:"Number of stale pending segments deleted from the metadata store."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/waitCompact/bytes"})}),(0,i.jsx)(s.td,{children:"Total bytes of this datasource waiting to be compacted by the auto compaction (only consider intervals/segments that are eligible for auto compaction)."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/waitCompact/count"})}),(0,i.jsx)(s.td,{children:"Total number of segments of this datasource waiting to be compacted by the auto compaction (only consider intervals/segments that are eligible for auto compaction)."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"interval/waitCompact/count"})}),(0,i.jsx)(s.td,{children:"Total number of intervals of this datasource waiting to be compacted by the auto compaction (only consider intervals/segments that are eligible for auto compaction)."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/compacted/bytes"})}),(0,i.jsx)(s.td,{children:"Total bytes of this datasource that are already compacted with the spec set in the auto compaction config."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/compacted/count"})}),(0,i.jsx)(s.td,{children:"Total number of segments of this datasource that are already compacted with the spec set in the auto compaction config."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"interval/compacted/count"})}),(0,i.jsx)(s.td,{children:"Total number of intervals of this datasource that are already compacted with the spec set in the auto compaction config."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/skipCompact/bytes"})}),(0,i.jsx)(s.td,{children:"Total bytes of this datasource that are skipped (not eligible for auto compaction) by the auto compaction."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/skipCompact/count"})}),(0,i.jsx)(s.td,{children:"Total number of segments of this datasource that are skipped (not eligible for auto compaction) by the auto compaction."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"interval/skipCompact/count"})}),(0,i.jsx)(s.td,{children:"Total number of intervals of this datasource that are skipped (not eligible for auto compaction) by the auto compaction."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"coordinator/time"})}),(0,i.jsx)(s.td,{children:"Approximate Coordinator duty runtime in milliseconds."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"duty"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"coordinator/global/time"})}),(0,i.jsxs)(s.td,{children:["Approximate runtime of a full coordination cycle in milliseconds. The ",(0,i.jsx)(s.code,{children:"dutyGroup"})," dimension indicates what type of coordination this run was. For example: Historical Management or Indexing."]}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dutyGroup"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"metadata/kill/supervisor/count"})}),(0,i.jsxs)(s.td,{children:["Total number of terminated supervisors that were automatically deleted from metadata store per each Coordinator kill supervisor duty run. This metric can help adjust ",(0,i.jsx)(s.code,{children:"druid.coordinator.kill.supervisor.durationToRetain"})," configuration based on whether more or less terminated supervisors need to be deleted per cycle. This metric is only emitted when ",(0,i.jsx)(s.code,{children:"druid.coordinator.kill.supervisor.on"})," is set to true."]}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"metadata/kill/audit/count"})}),(0,i.jsxs)(s.td,{children:["Total number of audit logs that were automatically deleted from metadata store per each Coordinator kill audit duty run. This metric can help adjust ",(0,i.jsx)(s.code,{children:"druid.coordinator.kill.audit.durationToRetain"})," configuration based on whether more or less audit logs need to be deleted per cycle. This metric is emitted only when ",(0,i.jsx)(s.code,{children:"druid.coordinator.kill.audit.on"})," is set to true."]}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"metadata/kill/compaction/count"})}),(0,i.jsxs)(s.td,{children:["Total number of compaction configurations that were automatically deleted from metadata store per each Coordinator kill compaction configuration duty run. This metric is only emitted when ",(0,i.jsx)(s.code,{children:"druid.coordinator.kill.compaction.on"})," is set to true."]}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"metadata/kill/rule/count"})}),(0,i.jsxs)(s.td,{children:["Total number of rules that were automatically deleted from metadata store per each Coordinator kill rule duty run. This metric can help adjust ",(0,i.jsx)(s.code,{children:"druid.coordinator.kill.rule.durationToRetain"})," configuration based on whether more or less rules need to be deleted per cycle. This metric is only emitted when ",(0,i.jsx)(s.code,{children:"druid.coordinator.kill.rule.on"})," is set to true."]}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"metadata/kill/datasource/count"})}),(0,i.jsxs)(s.td,{children:["Total number of datasource metadata that were automatically deleted from metadata store per each Coordinator kill datasource duty run. Note that datasource metadata only exists for datasource created from supervisor. This metric can help adjust ",(0,i.jsx)(s.code,{children:"druid.coordinator.kill.datasource.durationToRetain"})," configuration based on whether more or less datasource metadata need to be deleted per cycle. This metric is only emitted when ",(0,i.jsx)(s.code,{children:"druid.coordinator.kill.datasource.on"})," is set to true."]}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"serverview/init/time"})}),(0,i.jsx)(s.td,{children:"Time taken to initialize the coordinator server view."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Depends on the number of segments."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"serverview/sync/healthy"})}),(0,i.jsxs)(s.td,{children:["Sync status of the Coordinator with a segment-loading server such as a Historical or Peon. Emitted only when ",(0,i.jsx)(s.a,{href:"/docs/latest/configuration/#segment-management",children:"HTTP-based server view"})," is enabled. You can use this metric in conjunction with ",(0,i.jsx)(s.code,{children:"serverview/sync/unstableTime"})," to debug slow startup of the Coordinator."]}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"server"}),", ",(0,i.jsx)(s.code,{children:"tier"})]}),(0,i.jsx)(s.td,{children:"1 for fully synced servers, 0 otherwise"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"serverview/sync/unstableTime"})}),(0,i.jsxs)(s.td,{children:["Time in milliseconds for which the Coordinator has been failing to sync with a segment-loading server. Emitted only when ",(0,i.jsx)(s.a,{href:"/docs/latest/configuration/#segment-management",children:"HTTP-based server view"})," is enabled."]}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"server"}),", ",(0,i.jsx)(s.code,{children:"tier"})]}),(0,i.jsx)(s.td,{children:"Not emitted for synced servers."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"metadatacache/init/time"})}),(0,i.jsx)(s.td,{children:"Time taken to initialize the coordinator segment metadata cache."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Depends on the number of segments."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"metadatacache/refresh/count"})}),(0,i.jsx)(s.td,{children:"Number of segments to refresh in coordinator segment metadata cache."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"metadatacache/refresh/time"})}),(0,i.jsx)(s.td,{children:"Time taken to refresh segments in coordinator segment metadata cache."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"metadatacache/backfill/count"})}),(0,i.jsx)(s.td,{children:"Number of segments for which schema was back filled in the database."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"metadatacache/realtimeSegmentSchema/count"})}),(0,i.jsx)(s.td,{children:"Number of realtime segments for which schema is cached."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Depends on the number of realtime segments in the cluster."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"metadatacache/finalizedSegmentMetadata/count"})}),(0,i.jsx)(s.td,{children:"Number of finalized segments for which schema metadata is cached."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Depends on the number of segments in the cluster."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"metadatacache/finalizedSchemaPayload/count"})}),(0,i.jsx)(s.td,{children:"Number of finalized segment schema cached."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Depends on the number of distinct schema in the cluster."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"metadatacache/temporaryMetadataQueryResults/count"})}),(0,i.jsx)(s.td,{children:"Number of segments for which schema was fetched by executing segment metadata query."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Eventually it should be 0."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"metadatacache/temporaryPublishedMetadataQueryResults/count"})}),(0,i.jsx)(s.td,{children:"Number of segments for which schema is cached after back filling in the database."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"This value gets reset after each database poll. Eventually it should be 0."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"metadatacache/deepStorageOnly/segment/count"})}),(0,i.jsx)(s.td,{children:"Number of available segments present only in deep storage."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"metadatacache/deepStorageOnly/refresh/count"})}),(0,i.jsx)(s.td,{children:"Number of deep storage only segments with cached schema."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dataSource"})}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"metadatacache/deepStorageOnly/process/time"})}),(0,i.jsx)(s.td,{children:"Time taken in milliseconds to process deep storage only segment schema."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Under a minute"})]})]})]}),"\n",(0,i.jsx)(s.h2,{id:"general-health",children:"General Health"}),"\n",(0,i.jsx)(s.h3,{id:"service-health",children:"Service Health"}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Metric"}),(0,i.jsx)(s.th,{children:"Description"}),(0,i.jsx)(s.th,{children:"Dimensions"}),(0,i.jsx)(s.th,{children:"Normal value"})]})}),(0,i.jsx)(s.tbody,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"service/heartbeat"})}),(0,i.jsxs)(s.td,{children:["Metric indicating the service is up. This metric is emitted only when ",(0,i.jsx)(s.code,{children:"ServiceStatusMonitor"})," is enabled."]}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"leader"})," on the Overlord and Coordinator.",(0,i.jsx)("br",{}),(0,i.jsx)(s.code,{children:"workerVersion"}),", ",(0,i.jsx)(s.code,{children:"category"}),", ",(0,i.jsx)(s.code,{children:"status"})," on the Middle Manager.",(0,i.jsx)("br",{}),(0,i.jsx)(s.code,{children:"taskId"}),", ",(0,i.jsx)(s.code,{children:"groupId"}),", ",(0,i.jsx)(s.code,{children:"taskType"}),", ",(0,i.jsx)(s.code,{children:"status"}),", ",(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"tags"})," on the Peon"]}),(0,i.jsx)(s.td,{children:"1"})]})})]}),"\n",(0,i.jsx)(s.h3,{id:"historical-1",children:"Historical"}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Metric"}),(0,i.jsx)(s.th,{children:"Description"}),(0,i.jsx)(s.th,{children:"Dimensions"}),(0,i.jsx)(s.th,{children:"Normal value"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/max"})}),(0,i.jsx)(s.td,{children:"Maximum byte limit available for segments."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/used"})}),(0,i.jsx)(s.td,{children:"Bytes used for served segments."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"tier"}),", ",(0,i.jsx)(s.code,{children:"priority"})]}),(0,i.jsx)(s.td,{children:"< max"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/usedPercent"})}),(0,i.jsx)(s.td,{children:"Percentage of space used by served segments."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"tier"}),", ",(0,i.jsx)(s.code,{children:"priority"})]}),(0,i.jsx)(s.td,{children:"< 100%"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/count"})}),(0,i.jsx)(s.td,{children:"Number of served segments."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"tier"}),", ",(0,i.jsx)(s.code,{children:"priority"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/pendingDelete"})}),(0,i.jsx)(s.td,{children:"On-disk size in bytes of segments that are waiting to be cleared out."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/rowCount/avg"})}),(0,i.jsxs)(s.td,{children:["The average number of rows per segment on a historical. ",(0,i.jsx)(s.code,{children:"SegmentStatsMonitor"})," must be enabled."]}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"tier"}),", ",(0,i.jsx)(s.code,{children:"priority"})]}),(0,i.jsxs)(s.td,{children:["Varies. See ",(0,i.jsx)(s.a,{href:"/docs/latest/operations/segment-optimization",children:"segment optimization"})," for guidance on optimal segment sizes."]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"segment/rowCount/range/count"})}),(0,i.jsxs)(s.td,{children:["The number of segments in a bucket. ",(0,i.jsx)(s.code,{children:"SegmentStatsMonitor"})," must be enabled."]}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dataSource"}),", ",(0,i.jsx)(s.code,{children:"tier"}),", ",(0,i.jsx)(s.code,{children:"priority"}),", ",(0,i.jsx)(s.code,{children:"range"})]}),(0,i.jsx)(s.td,{children:"Varies"})]})]})]}),"\n",(0,i.jsx)(s.h3,{id:"jvm",children:"JVM"}),"\n",(0,i.jsxs)(s.p,{children:["These metrics are only available if the ",(0,i.jsx)(s.code,{children:"JvmMonitor"})," module is included in ",(0,i.jsx)(s.code,{children:"druid.monitoring.monitors"}),".\nFor more information, see ",(0,i.jsx)(s.a,{href:"/docs/latest/configuration/#enabling-metrics",children:"Enabling Metrics"}),"."]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Metric"}),(0,i.jsx)(s.th,{children:"Description"}),(0,i.jsx)(s.th,{children:"Dimensions"}),(0,i.jsx)(s.th,{children:"Normal value"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"jvm/pool/committed"})}),(0,i.jsx)(s.td,{children:"Committed pool"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"poolKind"}),", ",(0,i.jsx)(s.code,{children:"poolName"}),", ",(0,i.jsx)(s.code,{children:"jvmVersion"})]}),(0,i.jsx)(s.td,{children:"Close to max pool"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"jvm/pool/init"})}),(0,i.jsx)(s.td,{children:"Initial pool"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"poolKind"}),", ",(0,i.jsx)(s.code,{children:"poolName"}),", ",(0,i.jsx)(s.code,{children:"jvmVersion"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"jvm/pool/max"})}),(0,i.jsx)(s.td,{children:"Max pool"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"poolKind"}),", ",(0,i.jsx)(s.code,{children:"poolName"}),", ",(0,i.jsx)(s.code,{children:"jvmVersion"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"jvm/pool/used"})}),(0,i.jsx)(s.td,{children:"Pool used"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"poolKind"}),", ",(0,i.jsx)(s.code,{children:"poolName"}),", ",(0,i.jsx)(s.code,{children:"jvmVersion"})]}),(0,i.jsx)(s.td,{children:"< max pool"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"jvm/bufferpool/count"})}),(0,i.jsx)(s.td,{children:"Bufferpool count"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"bufferpoolName"}),", ",(0,i.jsx)(s.code,{children:"jvmVersion"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"jvm/bufferpool/used"})}),(0,i.jsx)(s.td,{children:"Bufferpool used"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"bufferpoolName"}),", ",(0,i.jsx)(s.code,{children:"jvmVersion"})]}),(0,i.jsx)(s.td,{children:"Close to capacity"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"jvm/bufferpool/capacity"})}),(0,i.jsx)(s.td,{children:"Bufferpool capacity"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"bufferpoolName"}),", ",(0,i.jsx)(s.code,{children:"jvmVersion"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"jvm/mem/init"})}),(0,i.jsx)(s.td,{children:"Initial memory"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"memKind"}),", ",(0,i.jsx)(s.code,{children:"jvmVersion"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"jvm/mem/max"})}),(0,i.jsx)(s.td,{children:"Max memory"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"memKind"}),", ",(0,i.jsx)(s.code,{children:"jvmVersion"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"jvm/mem/used"})}),(0,i.jsx)(s.td,{children:"Used memory"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"memKind"}),", ",(0,i.jsx)(s.code,{children:"jvmVersion"})]}),(0,i.jsx)(s.td,{children:"< max memory"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"jvm/mem/committed"})}),(0,i.jsx)(s.td,{children:"Committed memory"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"memKind"}),", ",(0,i.jsx)(s.code,{children:"jvmVersion"})]}),(0,i.jsx)(s.td,{children:"Close to max memory"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"jvm/gc/count"})}),(0,i.jsx)(s.td,{children:"Garbage collection count"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"gcName"})," (cms/g1/parallel/etc.), ",(0,i.jsx)(s.code,{children:"gcGen"})," (old/young), ",(0,i.jsx)(s.code,{children:"jvmVersion"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"jvm/gc/cpu"})}),(0,i.jsxs)(s.td,{children:["Count of CPU time in Nanoseconds spent on garbage collection. Note: ",(0,i.jsx)(s.code,{children:"jvm/gc/cpu"})," represents the total time over multiple GC cycles; divide by ",(0,i.jsx)(s.code,{children:"jvm/gc/count"})," to get the mean GC time per cycle."]}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"gcName"}),", ",(0,i.jsx)(s.code,{children:"gcGen"}),", ",(0,i.jsx)(s.code,{children:"jvmVersion"})]}),(0,i.jsxs)(s.td,{children:["Sum of ",(0,i.jsx)(s.code,{children:"jvm/gc/cpu"})," should be within 10-30% of sum of ",(0,i.jsx)(s.code,{children:"jvm/cpu/total"}),", depending on the GC algorithm used (reported by ",(0,i.jsx)(s.a,{href:"/docs/latest/configuration/#enabling-metrics",children:(0,i.jsx)(s.code,{children:"JvmCpuMonitor"})}),")."]})]})]})]}),"\n",(0,i.jsx)(s.h3,{id:"zookeeper",children:"ZooKeeper"}),"\n",(0,i.jsxs)(s.p,{children:["These metrics are available only when ",(0,i.jsx)(s.code,{children:"druid.zk.service.enabled = true"}),"."]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Metric"}),(0,i.jsx)(s.th,{children:"Description"}),(0,i.jsx)(s.th,{children:"Dimensions"}),(0,i.jsx)(s.th,{children:"Normal value"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"zk/connected"})}),(0,i.jsxs)(s.td,{children:["Indicator of connection status. ",(0,i.jsx)(s.code,{children:"1"})," for connected, ",(0,i.jsx)(s.code,{children:"0"})," for disconnected. Emitted once per monitor period."]}),(0,i.jsx)(s.td,{children:"None"}),(0,i.jsx)(s.td,{children:"1"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"zk/reconnect/time"})}),(0,i.jsx)(s.td,{children:"Amount of time, in milliseconds, that a server was disconnected from ZooKeeper before reconnecting. Emitted on reconnection. Not emitted if connection to ZooKeeper is permanently lost, because in this case, there is no reconnection."}),(0,i.jsx)(s.td,{children:"None"}),(0,i.jsx)(s.td,{children:"Not present"})]})]})]}),"\n",(0,i.jsx)(s.h2,{id:"sys-deprecated",children:"Sys [Deprecated]"}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:["SysMonitor is now deprecated and will be removed in future releases.\nInstead, use the new OSHI monitor called ",(0,i.jsx)(s.a,{href:"#oshisysmonitor",children:"OshiSysMonitor"}),". The new monitor has a wider support for different machine architectures including ARM instances."]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["These metrics are only available if the ",(0,i.jsx)(s.code,{children:"SysMonitor"})," module is included."]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Metric"}),(0,i.jsx)(s.th,{children:"Description"}),(0,i.jsx)(s.th,{children:"Dimensions"}),(0,i.jsx)(s.th,{children:"Normal value"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/swap/free"})}),(0,i.jsx)(s.td,{children:"Free swap"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/swap/max"})}),(0,i.jsx)(s.td,{children:"Max swap"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/swap/pageIn"})}),(0,i.jsx)(s.td,{children:"Paged in swap"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/swap/pageOut"})}),(0,i.jsx)(s.td,{children:"Paged out swap"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/disk/write/count"})}),(0,i.jsx)(s.td,{children:"Writes to disk"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"fsDevName"}),", ",(0,i.jsx)(s.code,{children:"fsDirName"}),", ",(0,i.jsx)(s.code,{children:"fsTypeName"}),", ",(0,i.jsx)(s.code,{children:"fsSysTypeName"}),", ",(0,i.jsx)(s.code,{children:"fsOptions"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/disk/read/count"})}),(0,i.jsx)(s.td,{children:"Reads from disk"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"fsDevName"}),", ",(0,i.jsx)(s.code,{children:"fsDirName"}),", ",(0,i.jsx)(s.code,{children:"fsTypeName"}),", ",(0,i.jsx)(s.code,{children:"fsSysTypeName"}),", ",(0,i.jsx)(s.code,{children:"fsOptions"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/disk/write/size"})}),(0,i.jsx)(s.td,{children:"Bytes written to disk. One indicator of the amount of paging occurring for segments."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"fsDevName"}),",",(0,i.jsx)(s.code,{children:"fsDirName"}),",",(0,i.jsx)(s.code,{children:"fsTypeName"}),", ",(0,i.jsx)(s.code,{children:"fsSysTypeName"}),", ",(0,i.jsx)(s.code,{children:"fsOptions"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/disk/read/size"})}),(0,i.jsx)(s.td,{children:"Bytes read from disk. One indicator of the amount of paging occurring for segments."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"fsDevName"}),",",(0,i.jsx)(s.code,{children:"fsDirName"}),", ",(0,i.jsx)(s.code,{children:"fsTypeName"}),", ",(0,i.jsx)(s.code,{children:"fsSysTypeName"}),", ",(0,i.jsx)(s.code,{children:"fsOptions"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/net/write/size"})}),(0,i.jsx)(s.td,{children:"Bytes written to the network"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"netName"}),", ",(0,i.jsx)(s.code,{children:"netAddress"}),", ",(0,i.jsx)(s.code,{children:"netHwaddr"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/net/read/size"})}),(0,i.jsx)(s.td,{children:"Bytes read from the network"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"netName"}),", ",(0,i.jsx)(s.code,{children:"netAddress"}),", ",(0,i.jsx)(s.code,{children:"netHwaddr"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/fs/used"})}),(0,i.jsx)(s.td,{children:"Filesystem bytes used"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"fsDevName"}),", ",(0,i.jsx)(s.code,{children:"fsDirName"}),", ",(0,i.jsx)(s.code,{children:"fsTypeName"}),", ",(0,i.jsx)(s.code,{children:"fsSysTypeName"}),", ",(0,i.jsx)(s.code,{children:"fsOptions"})]}),(0,i.jsx)(s.td,{children:"< max"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/fs/max"})}),(0,i.jsx)(s.td,{children:"Filesystem bytes max"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"fsDevName"}),", ",(0,i.jsx)(s.code,{children:"fsDirName"}),", ",(0,i.jsx)(s.code,{children:"fsTypeName"}),", ",(0,i.jsx)(s.code,{children:"fsSysTypeName"}),", ",(0,i.jsx)(s.code,{children:"fsOptions"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/mem/used"})}),(0,i.jsx)(s.td,{children:"Memory used"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"< max"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/mem/max"})}),(0,i.jsx)(s.td,{children:"Memory max"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/storage/used"})}),(0,i.jsx)(s.td,{children:"Disk space used"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"fsDirName"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/cpu"})}),(0,i.jsx)(s.td,{children:"CPU used"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"cpuName"}),", ",(0,i.jsx)(s.code,{children:"cpuTime"})]}),(0,i.jsx)(s.td,{children:"Varies"})]})]})]}),"\n",(0,i.jsx)(s.h2,{id:"oshisysmonitor",children:"OshiSysMonitor"}),"\n",(0,i.jsxs)(s.p,{children:["These metrics are only available if the ",(0,i.jsx)(s.code,{children:"OshiSysMonitor"})," module is included."]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Metric"}),(0,i.jsx)(s.th,{children:"Description"}),(0,i.jsx)(s.th,{children:"Dimensions"}),(0,i.jsx)(s.th,{children:"Normal Value"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/swap/free"})}),(0,i.jsx)(s.td,{children:"Free swap"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/swap/max"})}),(0,i.jsx)(s.td,{children:"Max swap"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/swap/pageIn"})}),(0,i.jsx)(s.td,{children:"Paged in swap"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/swap/pageOut"})}),(0,i.jsx)(s.td,{children:"Paged out swap"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/disk/write/count"})}),(0,i.jsx)(s.td,{children:"Writes to disk"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"diskName"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/disk/read/count"})}),(0,i.jsx)(s.td,{children:"Reads from disk"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"diskName"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/disk/write/size"})}),(0,i.jsx)(s.td,{children:"Bytes written to disk. One indicator of the amount of paging occurring for segments."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"diskName"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/disk/read/size"})}),(0,i.jsx)(s.td,{children:"Bytes read from disk. One indicator of the amount of paging occurring for segments."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"diskName"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/disk/queue"})}),(0,i.jsx)(s.td,{children:"Disk queue length. Measures number of requests waiting to be processed by disk"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"diskName"})}),(0,i.jsx)(s.td,{children:"Generally 0"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/disk/transferTime"})}),(0,i.jsx)(s.td,{children:"Transfer time to read from or write to disk"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"diskName"})}),(0,i.jsx)(s.td,{children:"Depends on hardware"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/net/write/size"})}),(0,i.jsx)(s.td,{children:"Bytes written to the network"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"netName"}),", ",(0,i.jsx)(s.code,{children:"netAddress"}),", ",(0,i.jsx)(s.code,{children:"netHwaddr"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/net/read/size"})}),(0,i.jsx)(s.td,{children:"Bytes read from the network"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"netName"}),", ",(0,i.jsx)(s.code,{children:"netAddress"}),", ",(0,i.jsx)(s.code,{children:"netHwaddr"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/net/read/packets"})}),(0,i.jsx)(s.td,{children:"Total packets read from the network"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"netName"}),", ",(0,i.jsx)(s.code,{children:"netAddress"}),", ",(0,i.jsx)(s.code,{children:"netHwaddr"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/net/write/packets"})}),(0,i.jsx)(s.td,{children:"Total packets written to the network"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"netName"}),", ",(0,i.jsx)(s.code,{children:"netAddress"}),", ",(0,i.jsx)(s.code,{children:"netHwaddr"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/net/read/errors"})}),(0,i.jsx)(s.td,{children:"Total network read errors"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"netName"}),", ",(0,i.jsx)(s.code,{children:"netAddress"}),", ",(0,i.jsx)(s.code,{children:"netHwaddr"})]}),(0,i.jsx)(s.td,{children:"Generally 0"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/net/write/errors"})}),(0,i.jsx)(s.td,{children:"Total network write errors"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"netName"}),", ",(0,i.jsx)(s.code,{children:"netAddress"}),", ",(0,i.jsx)(s.code,{children:"netHwaddr"})]}),(0,i.jsx)(s.td,{children:"Generally 0"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/net/read/dropped"})}),(0,i.jsx)(s.td,{children:"Total packets dropped coming from network"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"netName"}),", ",(0,i.jsx)(s.code,{children:"netAddress"}),", ",(0,i.jsx)(s.code,{children:"netHwaddr"})]}),(0,i.jsx)(s.td,{children:"Generally 0"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/net/write/collisions"})}),(0,i.jsx)(s.td,{children:"Total network write collisions"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"netName"}),", ",(0,i.jsx)(s.code,{children:"netAddress"}),", ",(0,i.jsx)(s.code,{children:"netHwaddr"})]}),(0,i.jsx)(s.td,{children:"Generally 0"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/fs/used"})}),(0,i.jsx)(s.td,{children:"Filesystem bytes used"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"fsDevName"}),", ",(0,i.jsx)(s.code,{children:"fsDirName"})]}),(0,i.jsx)(s.td,{children:"< max"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/fs/max"})}),(0,i.jsx)(s.td,{children:"Filesystem bytes max"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"fsDevName"}),", ",(0,i.jsx)(s.code,{children:"fsDirName"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/fs/files/count"})}),(0,i.jsx)(s.td,{children:"Filesystem total IO nodes"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"fsDevName"}),", ",(0,i.jsx)(s.code,{children:"fsDirName"})]}),(0,i.jsx)(s.td,{children:"< max"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/fs/files/free"})}),(0,i.jsx)(s.td,{children:"Filesystem free IO nodes"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"fsDevName"}),", ",(0,i.jsx)(s.code,{children:"fsDirName"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/mem/used"})}),(0,i.jsx)(s.td,{children:"Memory used"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"< max"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/mem/max"})}),(0,i.jsx)(s.td,{children:"Memory max"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/mem/free"})}),(0,i.jsx)(s.td,{children:"Memory free"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/storage/used"})}),(0,i.jsx)(s.td,{children:"Disk space used"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"fsDirName"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/cpu"})}),(0,i.jsx)(s.td,{children:"CPU used"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"cpuName"}),", ",(0,i.jsx)(s.code,{children:"cpuTime"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/uptime"})}),(0,i.jsx)(s.td,{children:"Total system uptime"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/la/{i}"})}),(0,i.jsxs)(s.td,{children:["System CPU load averages over past ",(0,i.jsx)(s.code,{children:"i"})," minutes, where ",(0,i.jsx)(s.code,{children:"i={1,5,15}"})]}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/tcpv4/activeOpens"})}),(0,i.jsx)(s.td,{children:"Total TCP active open connections"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/tcpv4/passiveOpens"})}),(0,i.jsx)(s.td,{children:"Total TCP passive open connections"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/tcpv4/attemptFails"})}),(0,i.jsx)(s.td,{children:"Total TCP active connection failures"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Generally 0"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/tcpv4/estabResets"})}),(0,i.jsx)(s.td,{children:"Total TCP connection resets"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Generally 0"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/tcpv4/in/segs"})}),(0,i.jsx)(s.td,{children:"Total segments received in connection"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/tcpv4/in/errs"})}),(0,i.jsx)(s.td,{children:"Errors while reading segments"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Generally 0"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/tcpv4/out/segs"})}),(0,i.jsx)(s.td,{children:"Total segments sent"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/tcpv4/out/rsts"})}),(0,i.jsx)(s.td,{children:'Total "out reset" packets sent to reset the connection'}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Generally 0"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"sys/tcpv4/retrans/segs"})}),(0,i.jsx)(s.td,{children:"Total segments re-transmitted"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]})]})]}),"\n",(0,i.jsxs)(s.p,{children:["If you want to enable only some of these metrics categories you could specify ",(0,i.jsx)(s.code,{children:"druid.monitoring.sys.categories"}),".\nPossible values are ",(0,i.jsx)(s.code,{children:"mem"}),", ",(0,i.jsx)(s.code,{children:"swap"}),", ",(0,i.jsx)(s.code,{children:"fs"}),", ",(0,i.jsx)(s.code,{children:"disk"}),", ",(0,i.jsx)(s.code,{children:"net"}),", ",(0,i.jsx)(s.code,{children:"cpu"}),", ",(0,i.jsx)(s.code,{children:"sys"}),", and ",(0,i.jsx)(s.code,{children:"tcp"}),"."]}),"\n",(0,i.jsx)(s.h2,{id:"s3-multi-part-upload",children:"S3 multi-part upload"}),"\n",(0,i.jsxs)(s.p,{children:["These metrics are only available if the ",(0,i.jsx)(s.code,{children:"druid-s3-extensions"})," module is included and if certain specific features are being used: MSQ export to S3, durable intermediate storage on S3."]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Metric"}),(0,i.jsx)(s.th,{children:"Description"}),(0,i.jsx)(s.th,{children:"Dimensions"}),(0,i.jsx)(s.th,{children:"Normal value"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"s3/upload/part/queueSize"})}),(0,i.jsx)(s.td,{children:"Number of items currently waiting in queue to be uploaded to S3. Each item in the queue corresponds to a single part in a multi-part upload."}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"s3/upload/part/queuedTime"})}),(0,i.jsx)(s.td,{children:"Milliseconds spent by a single item (or part) in queue before it starts getting uploaded to S3."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"uploadId"}),", ",(0,i.jsx)(s.code,{children:"partNumber"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"s3/upload/part/time"})}),(0,i.jsx)(s.td,{children:"Milliseconds taken to upload a single part of a multi-part upload to S3."}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"uploadId"}),", ",(0,i.jsx)(s.code,{children:"partNumber"})]}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"s3/upload/total/time"})}),(0,i.jsx)(s.td,{children:"Milliseconds taken for uploading all parts of a multi-part upload to S3."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"uploadId"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"s3/upload/total/bytes"})}),(0,i.jsx)(s.td,{children:"Total bytes uploaded to S3 during a multi-part upload."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"uploadId"})}),(0,i.jsx)(s.td,{children:"Varies"})]})]})]}),"\n",(0,i.jsx)(s.h2,{id:"cgroup",children:"Cgroup"}),"\n",(0,i.jsxs)(s.p,{children:["These metrics are available on operating systems with the cgroup kernel feature. All the values are derived by reading from ",(0,i.jsx)(s.code,{children:"/sys/fs/cgroup"}),"."]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Metric"}),(0,i.jsx)(s.th,{children:"Description"}),(0,i.jsx)(s.th,{children:"Dimensions"}),(0,i.jsx)(s.th,{children:"Normal value"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"cgroup/cpu/shares"})}),(0,i.jsxs)(s.td,{children:["Relative value of CPU time available to this process. Read from ",(0,i.jsx)(s.code,{children:"cpu.shares"}),"."]}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"cgroup/cpu/cores_quota"})}),(0,i.jsxs)(s.td,{children:["Number of cores available to this process. Derived from ",(0,i.jsx)(s.code,{children:"cpu.cfs_quota_us"}),"/",(0,i.jsx)(s.code,{children:"cpu.cfs_period_us"}),"."]}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies. A value of -1 indicates there is no explicit quota set."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"cgroup/cpu/usage/total/percentage"})}),(0,i.jsx)(s.td,{children:"Total cpu percentage used by cgroup of process that is running"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"0-100"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"cgroup/cpu/usage/user/percentage"})}),(0,i.jsx)(s.td,{children:"User cpu percentage used by cgroup of process that is running"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"0-100"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"cgroup/cpu/usage/sys/percentage"})}),(0,i.jsx)(s.td,{children:"Sys cpu percentage used by cgroup of process that is running"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"0-100"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"cgroup/disk/read/size"})}),(0,i.jsx)(s.td,{children:"Reports the number of bytes transferred to specific devices by a cgroup of process that is running."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"diskName"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"cgroup/disk/write/size"})}),(0,i.jsx)(s.td,{children:"Reports the number of bytes transferred from specific devices by a cgroup of process that is running."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"diskName"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"cgroup/disk/read/count"})}),(0,i.jsx)(s.td,{children:"Reports the number of read operations performed on specific devices by a cgroup of process that is running."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"diskName"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"cgroup/disk/write/count"})}),(0,i.jsx)(s.td,{children:"Reports the number of write operations performed on specific devices by a cgroup of process that is running."}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"diskName"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"cgroup/memory/*"})}),(0,i.jsxs)(s.td,{children:["Memory stats for this process, such as ",(0,i.jsx)(s.code,{children:"cache"})," and ",(0,i.jsx)(s.code,{children:"total_swap"}),". Each stat produces a separate metric. Read from ",(0,i.jsx)(s.code,{children:"memory.stat"}),"."]}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"cgroup/memory_numa/*/pages"})}),(0,i.jsxs)(s.td,{children:["Memory stats, per NUMA node, for this process, such as ",(0,i.jsx)(s.code,{children:"total"})," and ",(0,i.jsx)(s.code,{children:"unevictable"}),". Each stat produces a separate metric. Read from ",(0,i.jsx)(s.code,{children:"memory.num_stat"}),"."]}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"numaZone"})}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"cgroup/memory/limit/bytes"})}),(0,i.jsx)(s.td,{children:"Reports the maximum memory that can be used by processes in the cgroup (in bytes)"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"cgroup/memory/usage/bytes"})}),(0,i.jsx)(s.td,{children:"Reports the maximum amount of user memory (including file cache)"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"cgroup/cpuset/cpu_count"})}),(0,i.jsxs)(s.td,{children:["Total number of CPUs available to the process. Derived from ",(0,i.jsx)(s.code,{children:"cpuset.cpus"}),"."]}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"cgroup/cpuset/effective_cpu_count"})}),(0,i.jsxs)(s.td,{children:["Total number of active CPUs available to the process. Derived from ",(0,i.jsx)(s.code,{children:"cpuset.effective_cpus"}),"."]}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"cgroup/cpuset/mems_count"})}),(0,i.jsxs)(s.td,{children:["Total number of memory nodes available to the process. Derived from ",(0,i.jsx)(s.code,{children:"cpuset.mems"}),"."]}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"cgroup/cpuset/effective_mems_count"})}),(0,i.jsxs)(s.td,{children:["Total number of active memory nodes available to the process. Derived from ",(0,i.jsx)(s.code,{children:"cpuset.effective_mems"}),"."]}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Varies"})]})]})]})]})}function a(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);