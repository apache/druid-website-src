"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[3953],{15680:(e,n,a)=>{a.d(n,{xA:()=>d,yg:()=>m});var t=a(96540);function r(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function o(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function i(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?o(Object(a),!0).forEach((function(n){r(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function l(e,n){if(null==e)return{};var a,t,r=function(e,n){if(null==e)return{};var a,t,r={},o=Object.keys(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||(r[a]=e[a]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var u=t.createContext({}),s=function(e){var n=t.useContext(u),a=n;return e&&(a="function"==typeof e?e(n):i(i({},n),e)),a},d=function(e){var n=s(e.components);return t.createElement(u.Provider,{value:n},e.children)},p="mdxType",y={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},c=t.forwardRef((function(e,n){var a=e.components,r=e.mdxType,o=e.originalType,u=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=s(a),c=r,m=p["".concat(u,".").concat(c)]||p[c]||y[c]||o;return a?t.createElement(m,i(i({ref:n},d),{},{components:a})):t.createElement(m,i({ref:n},d))}));function m(e,n){var a=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=c;var l={};for(var u in n)hasOwnProperty.call(n,u)&&(l[u]=n[u]);l.originalType=e,l[p]="string"==typeof e?e:r,i[1]=l;for(var s=2;s<o;s++)i[s]=a[s];return t.createElement.apply(null,i)}return t.createElement.apply(null,a)}c.displayName="MDXCreateElement"},19365:(e,n,a)=>{a.d(n,{A:()=>i});var t=a(96540),r=a(20053);const o={tabItem:"tabItem_Ymn6"};function i(e){var n=e.children,a=e.hidden,i=e.className;return t.createElement("div",{role:"tabpanel",className:(0,r.A)(o.tabItem,i),hidden:a},n)}},11470:(e,n,a)=>{a.d(n,{A:()=>w});var t=a(58168),r=a(96540),o=a(20053),i=a(23104),l=a(56347),u=a(57485),s=a(31682),d=a(89466);function p(e){return function(e){var n,a;return null!=(n=null==(a=r.Children.map(e,(function(e){if(!e||(0,r.isValidElement)(e)&&(n=e.props)&&"object"==typeof n&&"value"in n)return e;var n;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:a.filter(Boolean))?n:[]}(e).map((function(e){var n=e.props;return{value:n.value,label:n.label,attributes:n.attributes,default:n.default}}))}function y(e){var n=e.values,a=e.children;return(0,r.useMemo)((function(){var e=null!=n?n:p(a);return function(e){var n=(0,s.X)(e,(function(e,n){return e.value===n.value}));if(n.length>0)throw new Error('Docusaurus error: Duplicate values "'+n.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[n,a])}function c(e){var n=e.value;return e.tabValues.some((function(e){return e.value===n}))}function m(e){var n=e.queryString,a=void 0!==n&&n,t=e.groupId,o=(0,l.W6)(),i=function(e){var n=e.queryString,a=void 0!==n&&n,t=e.groupId;if("string"==typeof a)return a;if(!1===a)return null;if(!0===a&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=t?t:null}({queryString:a,groupId:t});return[(0,u.aZ)(i),(0,r.useCallback)((function(e){if(i){var n=new URLSearchParams(o.location.search);n.set(i,e),o.replace(Object.assign({},o.location,{search:n.toString()}))}}),[i,o])]}function g(e){var n,a,t,o,i=e.defaultValue,l=e.queryString,u=void 0!==l&&l,s=e.groupId,p=y(e),g=(0,r.useState)((function(){return function(e){var n,a=e.defaultValue,t=e.tabValues;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(a){if(!c({value:a,tabValues:t}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+a+'" but none of its children has the corresponding value. Available values are: '+t.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return a}var r=null!=(n=t.find((function(e){return e.default})))?n:t[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:i,tabValues:p})})),h=g[0],f=g[1],N=m({queryString:u,groupId:s}),b=N[0],v=N[1],w=(n=function(e){return e?"docusaurus.tab."+e:null}({groupId:s}.groupId),a=(0,d.Dv)(n),t=a[0],o=a[1],[t,(0,r.useCallback)((function(e){n&&o.set(e)}),[n,o])]),q=w[0],T=w[1],C=function(){var e=null!=b?b:q;return c({value:e,tabValues:p})?e:null}();return(0,r.useLayoutEffect)((function(){C&&f(C)}),[C]),{selectedValue:h,selectValue:(0,r.useCallback)((function(e){if(!c({value:e,tabValues:p}))throw new Error("Can't select invalid tab value="+e);f(e),v(e),T(e)}),[v,T,p]),tabValues:p}}var h=a(92303);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function N(e){var n=e.className,a=e.block,l=e.selectedValue,u=e.selectValue,s=e.tabValues,d=[],p=(0,i.a_)().blockElementScrollPositionUntilNextRender,y=function(e){var n=e.currentTarget,a=d.indexOf(n),t=s[a].value;t!==l&&(p(n),u(t))},c=function(e){var n,a=null;switch(e.key){case"Enter":y(e);break;case"ArrowRight":var t,r=d.indexOf(e.currentTarget)+1;a=null!=(t=d[r])?t:d[0];break;case"ArrowLeft":var o,i=d.indexOf(e.currentTarget)-1;a=null!=(o=d[i])?o:d[d.length-1]}null==(n=a)||n.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.A)("tabs",{"tabs--block":a},n)},s.map((function(e){var n=e.value,a=e.label,i=e.attributes;return r.createElement("li",(0,t.A)({role:"tab",tabIndex:l===n?0:-1,"aria-selected":l===n,key:n,ref:function(e){return d.push(e)},onKeyDown:c,onClick:y},i,{className:(0,o.A)("tabs__item",f.tabItem,null==i?void 0:i.className,{"tabs__item--active":l===n})}),null!=a?a:n)})))}function b(e){var n=e.lazy,a=e.children,t=e.selectedValue,o=(Array.isArray(a)?a:[a]).filter(Boolean);if(n){var i=o.find((function(e){return e.props.value===t}));return i?(0,r.cloneElement)(i,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},o.map((function(e,n){return(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==t})})))}function v(e){var n=g(e);return r.createElement("div",{className:(0,o.A)("tabs-container",f.tabList)},r.createElement(N,(0,t.A)({},e,n)),r.createElement(b,(0,t.A)({},e,n)))}function w(e){var n=(0,h.A)();return r.createElement(v,(0,t.A)({key:String(n)},e))}},29128:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>y,contentTitle:()=>d,default:()=>h,frontMatter:()=>s,metadata:()=>p,toc:()=>c});var t=a(58168),r=a(98587),o=(a(96540),a(15680)),i=a(11470),l=a(19365),u=["components"],s={id:"datasource",title:"Datasources"},d=void 0,p={unversionedId:"querying/datasource",id:"querying/datasource",title:"Datasources",description:"\x3c!--",source:"@site/docs/latest/querying/datasource.md",sourceDirName:"querying",slug:"/querying/datasource",permalink:"/docs/latest/querying/datasource",draft:!1,tags:[],version:"current",frontMatter:{id:"datasource",title:"Datasources"},sidebar:"docs",previous:{title:"Troubleshooting",permalink:"/docs/latest/querying/troubleshooting"},next:{title:"Joins",permalink:"/docs/latest/querying/joins"}},y={},c=[{value:"Datasource type",id:"datasource-type",level:2},{value:"<code>table</code>",id:"table",level:3},{value:"<code>lookup</code>",id:"lookup",level:3},{value:"<code>union</code>",id:"union",level:3},{value:"<code>inline</code>",id:"inline",level:3},{value:"<code>query</code>",id:"query",level:3},{value:"<code>join</code>",id:"join",level:3},{value:"Joins in SQL",id:"joins-in-sql",level:4},{value:"Joins in native queries",id:"joins-in-native-queries",level:4},{value:"Join performance",id:"join-performance",level:4},{value:"Future work for joins",id:"future-work-for-joins",level:4},{value:"<code>unnest</code>",id:"unnest",level:3}],m={toc:c},g="wrapper";function h(e){var n=e.components,a=(0,r.A)(e,u);return(0,o.yg)(g,(0,t.A)({},m,a,{components:n,mdxType:"MDXLayout"}),(0,o.yg)("p",null,'Datasources in Apache Druid are things that you can query. The most common kind of datasource is a table datasource,\nand in many contexts the word "datasource" implicitly refers to table datasources. This is especially true\n',(0,o.yg)("a",{parentName:"p",href:"/docs/latest/ingestion/"},"during data ingestion"),", where ingestion is always creating or writing into a table\ndatasource. But at query time, there are many other types of datasources available."),(0,o.yg)("p",null,'The word "datasource" is generally spelled ',(0,o.yg)("inlineCode",{parentName:"p"},"dataSource")," (with a capital S) when it appears in API requests and\nresponses."),(0,o.yg)("h2",{id:"datasource-type"},"Datasource type"),(0,o.yg)("h3",{id:"table"},(0,o.yg)("inlineCode",{parentName:"h3"},"table")),(0,o.yg)(i.A,{mdxType:"Tabs"},(0,o.yg)(l.A,{value:"1",label:"SQL",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-sql"},'SELECT column1, column2 FROM "druid"."dataSourceName"\n'))),(0,o.yg)(l.A,{value:"2",label:"Native",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-json"},'{\n  "queryType": "scan",\n  "dataSource": "dataSourceName",\n  "columns": ["column1", "column2"],\n  "intervals": ["0000/3000"]\n}\n')))),(0,o.yg)("p",null,"The table datasource is the most common type. This is the kind of datasource you get when you perform\n",(0,o.yg)("a",{parentName:"p",href:"/docs/latest/ingestion/"},"data ingestion"),". They are split up into segments, distributed around the cluster,\nand queried in parallel."),(0,o.yg)("p",null,"In ",(0,o.yg)("a",{parentName:"p",href:"/docs/latest/querying/sql#from"},"Druid SQL"),", table datasources reside in the ",(0,o.yg)("inlineCode",{parentName:"p"},"druid")," schema. This is the default schema, so table\ndatasources can be referenced as either ",(0,o.yg)("inlineCode",{parentName:"p"},"druid.dataSourceName")," or simply ",(0,o.yg)("inlineCode",{parentName:"p"},"dataSourceName"),"."),(0,o.yg)("p",null,"In native queries, table datasources can be referenced using their names as strings (as in the example above), or by\nusing JSON objects of the form:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-json"},'"dataSource": {\n  "type": "table",\n  "name": "dataSourceName"\n}\n')),(0,o.yg)("p",null,"To see a list of all table datasources, use the SQL query\n",(0,o.yg)("inlineCode",{parentName:"p"},"SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'druid'"),"."),(0,o.yg)("h3",{id:"lookup"},(0,o.yg)("inlineCode",{parentName:"h3"},"lookup")),(0,o.yg)(i.A,{mdxType:"Tabs"},(0,o.yg)(l.A,{value:"3",label:"SQL",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-sql"},"SELECT k, v FROM lookup.countries\n"))),(0,o.yg)(l.A,{value:"4",label:"Native",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-json"},'{\n  "queryType": "scan",\n  "dataSource": {\n    "type": "lookup",\n    "lookup": "countries"\n  },\n  "columns": ["k", "v"],\n  "intervals": ["0000/3000"]\n}\n')))),(0,o.yg)("p",null,"Lookup datasources correspond to Druid's key-value ",(0,o.yg)("a",{parentName:"p",href:"/docs/latest/querying/lookups"},"lookup")," objects. In ",(0,o.yg)("a",{parentName:"p",href:"/docs/latest/querying/sql#from"},"Druid SQL"),",\nthey reside in the ",(0,o.yg)("inlineCode",{parentName:"p"},"lookup")," schema. They are preloaded in memory on all servers, so they can be accessed rapidly.\nThey can be joined onto regular tables using the ",(0,o.yg)("a",{parentName:"p",href:"#join"},"join operator"),"."),(0,o.yg)("p",null,"Lookup datasources are key-value oriented and always have exactly two columns: ",(0,o.yg)("inlineCode",{parentName:"p"},"k")," (the key) and ",(0,o.yg)("inlineCode",{parentName:"p"},"v")," (the value), and\nboth are always strings."),(0,o.yg)("p",null,"To see a list of all lookup datasources, use the SQL query\n",(0,o.yg)("inlineCode",{parentName:"p"},"SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'lookup'"),"."),(0,o.yg)("admonition",{type:"info"},(0,o.yg)("p",{parentName:"admonition"}," Performance tip: Lookups can be joined with a base table either using an explicit ",(0,o.yg)("a",{parentName:"p",href:"#join"},"join"),", or by using the\nSQL ",(0,o.yg)("a",{parentName:"p",href:"/docs/latest/querying/sql-scalar#string-functions"},(0,o.yg)("inlineCode",{parentName:"a"},"LOOKUP")," function"),".\nHowever, the join operator must evaluate the condition on each row, whereas the\n",(0,o.yg)("inlineCode",{parentName:"p"},"LOOKUP")," function can defer evaluation until after an aggregation phase. This means that the ",(0,o.yg)("inlineCode",{parentName:"p"},"LOOKUP")," function is\nusually faster than joining to a lookup datasource.")),(0,o.yg)("p",null,"Refer to the ",(0,o.yg)("a",{parentName:"p",href:"/docs/latest/querying/query-execution#table"},"Query execution")," page for more details on how queries are executed when you\nuse table datasources."),(0,o.yg)("h3",{id:"union"},(0,o.yg)("inlineCode",{parentName:"h3"},"union")),(0,o.yg)(i.A,{mdxType:"Tabs"},(0,o.yg)(l.A,{value:"5",label:"SQL",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-sql"},"SELECT column1, column2\nFROM (\n  SELECT column1, column2 FROM table1\n  UNION ALL\n  SELECT column1, column2 FROM table2\n  UNION ALL\n  SELECT column1, column2 FROM table3\n)\n"))),(0,o.yg)(l.A,{value:"6",label:"Native",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-json"},'{\n  "queryType": "scan",\n  "dataSource": {\n    "type": "union",\n    "dataSources": ["table1", "table2", "table3"]\n  },\n  "columns": ["column1", "column2"],\n  "intervals": ["0000/3000"]\n}\n')))),(0,o.yg)("p",null,"Unions allow you to treat two or more tables as a single datasource. In SQL, this is done with the UNION ALL operator\napplied directly to tables, called a ",(0,o.yg)("a",{parentName:"p",href:"/docs/latest/querying/sql#table-level"},'"table-level union"'),'. In native queries, this is done with a\n"union" datasource.'),(0,o.yg)("p",null,"With SQL ",(0,o.yg)("a",{parentName:"p",href:"/docs/latest/querying/sql#table-level"},"table-level unions")," the same columns must be selected from each table in the same order,\nand those columns must either have the same types, or types that can be implicitly cast to each other (such as different\nnumeric types). For this reason, it is more robust to write your queries to select specific columns."),(0,o.yg)("p",null,"With the native union datasource, the tables being unioned do not need to have identical schemas. If they do not fully\nmatch up, then columns that exist in one table but not another will be treated as if they contained all null values in\nthe tables where they do not exist."),(0,o.yg)("p",null,"In either case, features like expressions, column aliasing, JOIN, GROUP BY, ORDER BY, and so on cannot be used with\ntable unions."),(0,o.yg)("p",null,"Refer to the ",(0,o.yg)("a",{parentName:"p",href:"/docs/latest/querying/query-execution#union"},"Query execution")," page for more details on how queries are executed when you\nuse union datasources."),(0,o.yg)("h3",{id:"inline"},(0,o.yg)("inlineCode",{parentName:"h3"},"inline")),(0,o.yg)(i.A,{mdxType:"Tabs"},(0,o.yg)(l.A,{value:"7",label:"Native",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-json"},'{\n  "queryType": "scan",\n  "dataSource": {\n    "type": "inline",\n    "columnNames": ["country", "city"],\n    "rows": [\n      ["United States", "San Francisco"],\n      ["Canada", "Calgary"]\n    ]\n  },\n  "columns": ["country", "city"],\n  "intervals": ["0000/3000"]\n}\n')))),(0,o.yg)("p",null,"Inline datasources allow you to query a small amount of data that is embedded in the query itself. They are useful when\nyou want to write a query on a small amount of data without loading it first. They are also useful as inputs into a\n",(0,o.yg)("a",{parentName:"p",href:"#join"},"join"),". Druid also uses them internally to handle subqueries that need to be inlined on the Broker. See the\n",(0,o.yg)("a",{parentName:"p",href:"#query"},(0,o.yg)("inlineCode",{parentName:"a"},"query")," datasource")," documentation for more details."),(0,o.yg)("p",null,"There are two fields in an inline datasource: an array of ",(0,o.yg)("inlineCode",{parentName:"p"},"columnNames")," and an array of ",(0,o.yg)("inlineCode",{parentName:"p"},"rows"),". Each row is an array\nthat must be exactly as long as the list of ",(0,o.yg)("inlineCode",{parentName:"p"},"columnNames"),". The first element in each row corresponds to the first\ncolumn in ",(0,o.yg)("inlineCode",{parentName:"p"},"columnNames"),", and so on."),(0,o.yg)("p",null,"Inline datasources are not available in Druid SQL."),(0,o.yg)("p",null,"Refer to the ",(0,o.yg)("a",{parentName:"p",href:"/docs/latest/querying/query-execution#inline"},"Query execution")," page for more details on how queries are executed when you\nuse inline datasources."),(0,o.yg)("h3",{id:"query"},(0,o.yg)("inlineCode",{parentName:"h3"},"query")),(0,o.yg)(i.A,{mdxType:"Tabs"},(0,o.yg)(l.A,{value:"8",label:"SQL",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-sql"},"-- Uses a subquery to count hits per page, then takes the average.\nSELECT\n  AVG(cnt) AS average_hits_per_page\nFROM\n  (SELECT page, COUNT(*) AS hits FROM site_traffic GROUP BY page)\n"))),(0,o.yg)(l.A,{value:"9",label:"Native",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-json"},'{\n  "queryType": "timeseries",\n  "dataSource": {\n    "type": "query",\n    "query": {\n      "queryType": "groupBy",\n      "dataSource": "site_traffic",\n      "intervals": ["0000/3000"],\n      "granularity": "all",\n      "dimensions": ["page"],\n      "aggregations": [\n        { "type": "count", "name": "hits" }\n      ]\n    }\n  },\n  "intervals": ["0000/3000"],\n  "granularity": "all",\n  "aggregations": [\n    { "type": "longSum", "name": "hits", "fieldName": "hits" },\n    { "type": "count", "name": "pages" }\n  ],\n  "postAggregations": [\n    { "type": "expression", "name": "average_hits_per_page", "expression": "hits / pages" }\n  ]\n}\n')))),(0,o.yg)("p",null,"Query datasources allow you to issue subqueries. In native queries, they can appear anywhere that accepts a\n",(0,o.yg)("inlineCode",{parentName:"p"},"dataSource")," (except underneath a ",(0,o.yg)("inlineCode",{parentName:"p"},"union"),"). In SQL, they can appear in the following places, always surrounded by parentheses:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"The FROM clause: ",(0,o.yg)("inlineCode",{parentName:"li"},"FROM (<subquery>)"),"."),(0,o.yg)("li",{parentName:"ul"},"As inputs to a JOIN: ",(0,o.yg)("inlineCode",{parentName:"li"},"<table-or-subquery-1> t1 INNER JOIN <table-or-subquery-2> t2 ON t1.<col1> = t2.<col2>"),"."),(0,o.yg)("li",{parentName:"ul"},"In the WHERE clause: ",(0,o.yg)("inlineCode",{parentName:"li"},"WHERE <column> { IN | NOT IN } (<subquery>)"),". These are translated to joins by the SQL planner.")),(0,o.yg)("admonition",{type:"info"},(0,o.yg)("p",{parentName:"admonition"}," Performance tip: In most cases, subquery results are fully buffered in memory on the Broker and then further\nprocessing occurs on the Broker itself. This means that subqueries with large result sets can cause performance\nbottlenecks or run into memory usage limits on the Broker. See the ",(0,o.yg)("a",{parentName:"p",href:"/docs/latest/querying/query-execution#query"},"Query execution"),"\npage for more details on how subqueries are executed and what limits will apply.")),(0,o.yg)("h3",{id:"join"},(0,o.yg)("inlineCode",{parentName:"h3"},"join")),(0,o.yg)(i.A,{mdxType:"Tabs"},(0,o.yg)(l.A,{value:"10",label:"SQL",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-sql"},'-- Joins "sales" with "countries" (using "store" as the join key) to get sales by country.\nSELECT\n  store_to_country.v AS country,\n  SUM(sales.revenue) AS country_revenue\nFROM\n  sales\n  INNER JOIN lookup.store_to_country ON sales.store = store_to_country.k\nGROUP BY\n  countries.v\n'))),(0,o.yg)(l.A,{value:"11",label:"Native",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-json"},'{\n  "queryType": "groupBy",\n  "dataSource": {\n    "type": "join",\n    "left": "sales",\n    "right": {\n      "type": "lookup",\n      "lookup": "store_to_country"\n    },\n    "rightPrefix": "r.",\n    "condition": "store == \\"r.k\\"",\n    "joinType": "INNER"\n  },\n  "intervals": ["0000/3000"],\n  "granularity": "all",\n  "dimensions": [\n    { "type": "default", "outputName": "country", "dimension": "r.v" }\n  ],\n  "aggregations": [\n    { "type": "longSum", "name": "country_revenue", "fieldName": "revenue" }\n  ]\n}\n')))),(0,o.yg)("p",null,"Join datasources allow you to do a SQL-style join of two datasources. Stacking joins on top of each other allows\nyou to join arbitrarily many datasources."),(0,o.yg)("p",null,'In Druid 29.0.0, joins in native queries are implemented with a broadcast hash-join algorithm. This means\nthat all datasources other than the leftmost "base" datasource must fit in memory. In native queries, the join condition\nmust be an equality. In SQL, any join condition is accepted, but only equalities of a certain form\n(see ',(0,o.yg)("a",{parentName:"p",href:"#joins-in-sql"},"Joins in SQL"),") execute efficiently as part of a native join. For other kinds of conditions, planner will try\nto re-arrange condition such that some of the sub-conditions are evaluated as a filter on top of join and other\nsub-conditions are left out in the join condition. In worst case scenario, SQL will execute the join condition as a\ncross join (cartesian product) plus a filter."),(0,o.yg)("p",null,"This feature is intended mainly to allow joining regular Druid tables with ",(0,o.yg)("a",{parentName:"p",href:"#lookup"},"lookup"),", ",(0,o.yg)("a",{parentName:"p",href:"#inline"},"inline"),", and\n",(0,o.yg)("a",{parentName:"p",href:"#query"},"query")," datasources. Refer to the ",(0,o.yg)("a",{parentName:"p",href:"/docs/latest/querying/query-execution#join"},"Query execution")," page for more details on how\nqueries are executed when you use join datasources."),(0,o.yg)("h4",{id:"joins-in-sql"},"Joins in SQL"),(0,o.yg)("p",null,"SQL joins take the form:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"<o1> [ INNER | LEFT [OUTER] ] JOIN <o2> ON <condition>\n")),(0,o.yg)("p",null,"Any condition is accepted, but only certain kinds of conditions execute efficiently\nas a native join. The condition must be a single clause like the following, or an ",(0,o.yg)("inlineCode",{parentName:"p"},"AND")," of clauses involving at\nleast one of the following:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Equality between fields of the same type on each side, like ",(0,o.yg)("inlineCode",{parentName:"li"},"t1 JOIN t2 ON t1.x = t2.x"),"."),(0,o.yg)("li",{parentName:"ul"},"Equality between a function call on one side, and a field on the other side, like ",(0,o.yg)("inlineCode",{parentName:"li"},"t1 JOIN t2 ON LOWER(t1.x) = t2.x"),"."),(0,o.yg)("li",{parentName:"ul"},"The equality operator may be ",(0,o.yg)("inlineCode",{parentName:"li"},"=")," (which does not match nulls) or ",(0,o.yg)("inlineCode",{parentName:"li"},"IS NOT DISTINCT FROM")," (which does match nulls).")),(0,o.yg)("p",null,"In other cases, Druid will either insert a subquery below the join, or will use a cross join (cartesian product)\nfollowed by a filter. Joins executed in these ways may run into resource or performance constraints. To determine\nif your query is using one of these execution paths, run ",(0,o.yg)("inlineCode",{parentName:"p"},"EXPLAIN PLAN FOR <query>")," and look for the following:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"query")," type datasources under the ",(0,o.yg)("inlineCode",{parentName:"li"},"left")," or ",(0,o.yg)("inlineCode",{parentName:"li"},"right")," key of your ",(0,o.yg)("inlineCode",{parentName:"li"},"join")," datasource."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"join")," type datasource with ",(0,o.yg)("inlineCode",{parentName:"li"},"condition")," set to ",(0,o.yg)("inlineCode",{parentName:"li"},'"1"')," (cartesian product) followed by a ",(0,o.yg)("inlineCode",{parentName:"li"},"filter")," that encodes the\ncondition you provided.")),(0,o.yg)("p",null,"In these cases, you may be able to improve the performance of your query by rewriting it."),(0,o.yg)("p",null,"For more information about how Druid translates SQL to native queries, refer to the\n",(0,o.yg)("a",{parentName:"p",href:"/docs/latest/querying/sql-translation"},"Druid SQL")," documentation."),(0,o.yg)("h4",{id:"joins-in-native-queries"},"Joins in native queries"),(0,o.yg)("p",null,"Native join datasources have the following properties. All are required."),(0,o.yg)("table",null,(0,o.yg)("thead",{parentName:"table"},(0,o.yg)("tr",{parentName:"thead"},(0,o.yg)("th",{parentName:"tr",align:null},"Field"),(0,o.yg)("th",{parentName:"tr",align:null},"Description"))),(0,o.yg)("tbody",{parentName:"table"},(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},(0,o.yg)("inlineCode",{parentName:"td"},"left")),(0,o.yg)("td",{parentName:"tr",align:null},"Left-hand datasource. Must be of type ",(0,o.yg)("inlineCode",{parentName:"td"},"table"),", ",(0,o.yg)("inlineCode",{parentName:"td"},"join"),", ",(0,o.yg)("inlineCode",{parentName:"td"},"lookup"),", ",(0,o.yg)("inlineCode",{parentName:"td"},"query"),", or ",(0,o.yg)("inlineCode",{parentName:"td"},"inline"),". Placing another join as the left datasource allows you to join arbitrarily many datasources.")),(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},(0,o.yg)("inlineCode",{parentName:"td"},"right")),(0,o.yg)("td",{parentName:"tr",align:null},"Right-hand datasource. Must be of type ",(0,o.yg)("inlineCode",{parentName:"td"},"lookup"),", ",(0,o.yg)("inlineCode",{parentName:"td"},"query"),", or ",(0,o.yg)("inlineCode",{parentName:"td"},"inline"),". Note that this is more rigid than what Druid SQL requires.")),(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},(0,o.yg)("inlineCode",{parentName:"td"},"rightPrefix")),(0,o.yg)("td",{parentName:"tr",align:null},"String prefix that will be applied to all columns from the right-hand datasource, to prevent them from colliding with columns from the left-hand datasource. Can be any string, so long as it is nonempty and is not be a prefix of the string ",(0,o.yg)("inlineCode",{parentName:"td"},"__time"),". Any columns from the left-hand side that start with your ",(0,o.yg)("inlineCode",{parentName:"td"},"rightPrefix")," will be shadowed. It is up to you to provide a prefix that will not shadow any important columns from the left side.")),(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},(0,o.yg)("inlineCode",{parentName:"td"},"condition")),(0,o.yg)("td",{parentName:"tr",align:null},(0,o.yg)("a",{parentName:"td",href:"/docs/latest/querying/math-expr"},"Expression")," that must be an equality where one side is an expression of the left-hand side, and the other side is a simple column reference to the right-hand side. Note that this is more rigid than what Druid SQL requires: here, the right-hand reference must be a simple column reference; in SQL it can be an expression.")),(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},(0,o.yg)("inlineCode",{parentName:"td"},"joinType")),(0,o.yg)("td",{parentName:"tr",align:null},(0,o.yg)("inlineCode",{parentName:"td"},"INNER")," or ",(0,o.yg)("inlineCode",{parentName:"td"},"LEFT"),".")))),(0,o.yg)("h4",{id:"join-performance"},"Join performance"),(0,o.yg)("p",null,"Joins are a feature that can significantly affect performance of your queries. Some performance tips and notes:"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},"Joins are especially useful with ",(0,o.yg)("a",{parentName:"li",href:"#lookup"},"lookup datasources"),", but in most cases, the\n",(0,o.yg)("a",{parentName:"li",href:"/docs/latest/querying/sql-scalar#string-functions"},(0,o.yg)("inlineCode",{parentName:"a"},"LOOKUP")," function")," performs better than a join. Consider using the ",(0,o.yg)("inlineCode",{parentName:"li"},"LOOKUP")," function if\nit is appropriate for your use case."),(0,o.yg)("li",{parentName:"ol"},"When using joins in Druid SQL, keep in mind that it can generate subqueries that you did not explicitly include in\nyour queries. Refer to the ",(0,o.yg)("a",{parentName:"li",href:"/docs/latest/querying/sql-translation"},"Druid SQL")," documentation for more details about when this happens\nand how to detect it."),(0,o.yg)("li",{parentName:"ol"},"One common reason for implicit subquery generation is if the types of the two halves of an equality do not match.\nFor example, since lookup keys are always strings, the condition ",(0,o.yg)("inlineCode",{parentName:"li"},"druid.d JOIN lookup.l ON d.field = l.field")," will\nperform best if ",(0,o.yg)("inlineCode",{parentName:"li"},"d.field")," is a string."),(0,o.yg)("li",{parentName:"ol"},"As of Druid 29.0.0, the join operator must evaluate the condition for each row. In the future, we expect\nto implement both early and deferred condition evaluation, which we expect to improve performance considerably for\ncommon use cases."),(0,o.yg)("li",{parentName:"ol"},"Currently, Druid does not support pushing down predicates (condition and filter) past a Join (i.e. into\nJoin's children). Druid only supports pushing predicates into the join if they originated from\nabove the join. Hence, the location of predicates and filters in your Druid SQL is very important.\nAlso, as a result of this, comma joins should be avoided.")),(0,o.yg)("h4",{id:"future-work-for-joins"},"Future work for joins"),(0,o.yg)("p",null,"Joins are an area of active development in Druid. The following features are missing today but may appear in\nfuture versions:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Reordering of join operations to get the most performant plan."),(0,o.yg)("li",{parentName:"ul"},"Preloaded dimension tables that are wider than lookups (i.e. supporting more than a single key and single value)."),(0,o.yg)("li",{parentName:"ul"},"RIGHT OUTER and FULL OUTER joins in the native query engine. Currently, they are partially implemented. Queries run\nbut results are not always correct."),(0,o.yg)("li",{parentName:"ul"},"Performance-related optimizations as mentioned in the ",(0,o.yg)("a",{parentName:"li",href:"#join-performance"},"previous section"),"."),(0,o.yg)("li",{parentName:"ul"},"Join conditions on a column containing a multi-value dimension.")),(0,o.yg)("h3",{id:"unnest"},(0,o.yg)("inlineCode",{parentName:"h3"},"unnest")),(0,o.yg)("p",null,"Use the ",(0,o.yg)("inlineCode",{parentName:"p"},"unnest")," datasource to unnest a column with multiple values in an array.\nFor example, you have a source column that looks like this:"),(0,o.yg)("table",null,(0,o.yg)("thead",{parentName:"table"},(0,o.yg)("tr",{parentName:"thead"},(0,o.yg)("th",{parentName:"tr",align:null},"Nested"))),(0,o.yg)("tbody",{parentName:"table"},(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},"[a, b]")),(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},"[c, d]")),(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},"[e, ","[f,g]","]")))),(0,o.yg)("p",null,"When you use the ",(0,o.yg)("inlineCode",{parentName:"p"},"unnest")," datasource, the unnested column looks like this:"),(0,o.yg)("table",null,(0,o.yg)("thead",{parentName:"table"},(0,o.yg)("tr",{parentName:"thead"},(0,o.yg)("th",{parentName:"tr",align:null},"Unnested"))),(0,o.yg)("tbody",{parentName:"table"},(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},"a")),(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},"b")),(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},"c")),(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},"d")),(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},"e")),(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},"[f, g]")))),(0,o.yg)("p",null,"When unnesting data, keep the following in mind:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"The total number of rows will grow to accommodate the new rows that the unnested data occupy."),(0,o.yg)("li",{parentName:"ul"},"You can unnest the values in more than one column in a single ",(0,o.yg)("inlineCode",{parentName:"li"},"unnest")," datasource, but this can lead to a very large number of new rows depending on your dataset.")),(0,o.yg)("p",null,"The ",(0,o.yg)("inlineCode",{parentName:"p"},"unnest")," datasource uses the following syntax:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-json"},'  "dataSource": {\n    "type": "unnest",\n    "base": {\n      "type": "table",\n      "name": "nested_data"\n    },\n    "virtualColumn": {\n      "type": "expression",\n      "name": "output_column",\n      "expression": "\\"column_reference\\""\n    },\n    "unnestFilter": "optional_filter"\n  }\n')),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"dataSource.type"),": Set this to ",(0,o.yg)("inlineCode",{parentName:"li"},"unnest"),"."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"dataSource.base"),": Defines the datasource you want to unnest.",(0,o.yg)("ul",{parentName:"li"},(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"dataSource.base.type"),": The type of datasource you want to unnest, such as a table."))),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"dataSource.virtualColumn"),": ",(0,o.yg)("a",{parentName:"li",href:"/docs/latest/querying/virtual-columns"},"Virtual column")," that references the nested values. The output name of this column is reused as the name of the column that contains unnested values. You can replace the source column with the unnested column by specifying the source column's name or a new column by specifying a different name. Outputting it to a new column can help you verify that you get the results that you expect but isn't required."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"unnestFilter"),": A filter only on the output column. You can omit this or set it to null if there are no filters.")),(0,o.yg)("p",null,"To learn more about how to use the ",(0,o.yg)("inlineCode",{parentName:"p"},"unnest")," datasource, see the ",(0,o.yg)("a",{parentName:"p",href:"/docs/latest/tutorials/tutorial-unnest-arrays"},"unnest tutorial"),"."))}h.isMDXComponent=!0}}]);