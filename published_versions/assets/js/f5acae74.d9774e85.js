"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[2909],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>g});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),m=p(n),u=i,g=m["".concat(l,".").concat(u)]||m[u]||c[u]||r;return n?a.createElement(g,o(o({ref:t},d),{},{components:n})):a.createElement(g,o({ref:t},d))}));function g(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[m]="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},18254:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>g,frontMatter:()=>s,metadata:()=>p,toc:()=>m});var a=n(87462),i=n(63366),r=(n(67294),n(3905)),o=["components"],s={id:"partitioning",title:"Partitioning",sidebar_label:"Partitioning",description:"Describes time chunk and secondary partitioning in Druid. Provides guidance to choose a secondary partition dimension."},l=void 0,p={unversionedId:"ingestion/partitioning",id:"ingestion/partitioning",title:"Partitioning",description:"Describes time chunk and secondary partitioning in Druid. Provides guidance to choose a secondary partition dimension.",source:"@site/docs/latest/ingestion/partitioning.md",sourceDirName:"ingestion",slug:"/ingestion/partitioning",permalink:"/docs/latest/ingestion/partitioning",draft:!1,tags:[],version:"current",frontMatter:{id:"partitioning",title:"Partitioning",sidebar_label:"Partitioning",description:"Describes time chunk and secondary partitioning in Druid. Provides guidance to choose a secondary partition dimension."},sidebar:"docs",previous:{title:"Rollup",permalink:"/docs/latest/ingestion/rollup"},next:{title:"Task reference",permalink:"/docs/latest/ingestion/tasks"}},d={},m=[{value:"Time chunk partitioning",id:"time-chunk-partitioning",level:2},{value:"Secondary partitioning",id:"secondary-partitioning",level:2},{value:"Sorting",id:"sorting",level:2},{value:"Learn more",id:"learn-more",level:2}],c={toc:m},u="wrapper";function g(e){var t=e.components,n=(0,i.Z)(e,o);return(0,r.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"You can use segment partitioning and sorting within your Druid datasources to reduce the size of your data and increase performance."),(0,r.kt)("p",null,"One way to partition is to load data into separate datasources. This is a perfectly viable approach that works very well when the number of datasources does not lead to excessive per-datasource overheads."),(0,r.kt)("p",null,"This topic describes how to set up partitions within a single datasource. It does not cover how to use multiple datasources. See ",(0,r.kt)("a",{parentName:"p",href:"/docs/latest/querying/multitenancy"},"Multitenancy considerations")," for more details on splitting data into separate datasources and potential operational considerations."),(0,r.kt)("h2",{id:"time-chunk-partitioning"},"Time chunk partitioning"),(0,r.kt)("p",null,"Druid always partitions datasources by time into ",(0,r.kt)("em",{parentName:"p"},"time chunks"),". Each time chunk contains one or more segments. This partitioning happens for all ingestion methods based on the ",(0,r.kt)("inlineCode",{parentName:"p"},"segmentGranularity")," parameter in your ingestion spec ",(0,r.kt)("inlineCode",{parentName:"p"},"dataSchema")," object."),(0,r.kt)("p",null,"Partitioning by time is important for two reasons:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Queries that filter by ",(0,r.kt)("inlineCode",{parentName:"li"},"__time")," (SQL) or ",(0,r.kt)("inlineCode",{parentName:"li"},"intervals")," (native) are able to use time partitioning to prune the set of segments to consider."),(0,r.kt)("li",{parentName:"ol"},"Certain data management operations, such as overwriting and compacting existing data, acquire exclusive write locks on time partitions."),(0,r.kt)("li",{parentName:"ol"},"Each segment file is wholly contained within a time partition. Too-fine-grained partitioning may cause a large number\nof small segments, which leads to poor performance.")),(0,r.kt)("p",null,"The most common choices to balance these considerations are ",(0,r.kt)("inlineCode",{parentName:"p"},"hour")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"day"),". For streaming ingestion, ",(0,r.kt)("inlineCode",{parentName:"p"},"hour")," is especially\ncommon, because it allows compaction to follow ingestion with less of a time delay."),(0,r.kt)("p",null,"The following table describes how to configure time chunk partitioning."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Method"),(0,r.kt)("th",{parentName:"tr",align:null},"Configuration"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/latest/multi-stage-query/"},"SQL")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/latest/multi-stage-query/concepts#partitioning"},(0,r.kt)("inlineCode",{parentName:"a"},"PARTITIONED BY")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/latest/ingestion/kafka-ingestion"},"Kafka")," or ",(0,r.kt)("a",{parentName:"td",href:"/docs/latest/ingestion/kinesis-ingestion"},"Kinesis")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"segmentGranularity")," inside the ",(0,r.kt)("a",{parentName:"td",href:"/docs/latest/ingestion/ingestion-spec#granularityspec"},(0,r.kt)("inlineCode",{parentName:"a"},"granularitySpec")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/latest/ingestion/native-batch"},"Native batch")," or ",(0,r.kt)("a",{parentName:"td",href:"/docs/latest/ingestion/hadoop"},"Hadoop")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"segmentGranularity")," inside the ",(0,r.kt)("a",{parentName:"td",href:"/docs/latest/ingestion/ingestion-spec#granularityspec"},(0,r.kt)("inlineCode",{parentName:"a"},"granularitySpec")))))),(0,r.kt)("h2",{id:"secondary-partitioning"},"Secondary partitioning"),(0,r.kt)("p",null,"Druid further partitions each time chunk into immutable segments. Secondary partitioning on a particular dimension improves locality. This means that rows with the same value for that dimension are stored together, decreasing access time."),(0,r.kt)("p",null,'To achieve the best performance and smallest overall footprint, partition your data on a "natural" dimension that\nyou often use as a filter, or that achieves some alignment within your data. Such partitioning can improve compression\nand query performance by significant multiples.'),(0,r.kt)("p",null,"The following table describes how to configure secondary partitioning."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Method"),(0,r.kt)("th",{parentName:"tr",align:null},"Configuration"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/latest/multi-stage-query/"},"SQL")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/latest/multi-stage-query/concepts#clustering"},(0,r.kt)("inlineCode",{parentName:"a"},"CLUSTERED BY")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/latest/ingestion/kafka-ingestion"},"Kafka")," or ",(0,r.kt)("a",{parentName:"td",href:"/docs/latest/ingestion/kinesis-ingestion"},"Kinesis")),(0,r.kt)("td",{parentName:"tr",align:null},"Upstream partitioning defines how Druid partitions the datasource. You can also alter clustering using ",(0,r.kt)("a",{parentName:"td",href:"/docs/latest/multi-stage-query/concepts#replace"},(0,r.kt)("inlineCode",{parentName:"a"},"REPLACE"))," (with ",(0,r.kt)("inlineCode",{parentName:"td"},"CLUSTERED BY"),") or ",(0,r.kt)("a",{parentName:"td",href:"/docs/latest/data-management/compaction"},"compaction")," after initial ingestion.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/latest/ingestion/native-batch"},"Native batch")," or ",(0,r.kt)("a",{parentName:"td",href:"/docs/latest/ingestion/hadoop"},"Hadoop")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/latest/ingestion/native-batch#partitionsspec"},(0,r.kt)("inlineCode",{parentName:"a"},"partitionsSpec"))," inside the ",(0,r.kt)("inlineCode",{parentName:"td"},"tuningConfig"))))),(0,r.kt)("h2",{id:"sorting"},"Sorting"),(0,r.kt)("p",null,"Each segment is internally sorted to promote compression and locality."),(0,r.kt)("p",null,'Partitioning and sorting work well together. If you do have a "natural" partitioning dimension, consider placing it\nfirst in your sort order as well. This way, Druid sorts rows within each segment by that column. This sorting configuration\nfrequently improves compression and performance more than using partitioning alone.'),(0,r.kt)("p",null,"The following table describes how to configure sorting."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Method"),(0,r.kt)("th",{parentName:"tr",align:null},"Configuration"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/latest/multi-stage-query/"},"SQL")),(0,r.kt)("td",{parentName:"tr",align:null},"Uses order of fields in ",(0,r.kt)("a",{parentName:"td",href:"/docs/latest/multi-stage-query/concepts#clustering"},(0,r.kt)("inlineCode",{parentName:"a"},"CLUSTERED BY"))," or ",(0,r.kt)("a",{parentName:"td",href:"/docs/latest/multi-stage-query/reference#context"},(0,r.kt)("inlineCode",{parentName:"a"},"segmentSortOrder"))," in the query context")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/latest/ingestion/kafka-ingestion"},"Kafka")," or ",(0,r.kt)("a",{parentName:"td",href:"/docs/latest/ingestion/kinesis-ingestion"},"Kinesis")),(0,r.kt)("td",{parentName:"tr",align:null},"Uses order of fields in ",(0,r.kt)("a",{parentName:"td",href:"/docs/latest/ingestion/ingestion-spec#dimensionsspec"},(0,r.kt)("inlineCode",{parentName:"a"},"dimensionsSpec")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/latest/ingestion/native-batch"},"Native batch")," or ",(0,r.kt)("a",{parentName:"td",href:"/docs/latest/ingestion/hadoop"},"Hadoop")),(0,r.kt)("td",{parentName:"tr",align:null},"Uses order of fields in ",(0,r.kt)("a",{parentName:"td",href:"/docs/latest/ingestion/ingestion-spec#dimensionsspec"},(0,r.kt)("inlineCode",{parentName:"a"},"dimensionsSpec")))))),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Druid implicitly sorts rows within a segment by ",(0,r.kt)("inlineCode",{parentName:"p"},"__time")," first before any ",(0,r.kt)("inlineCode",{parentName:"p"},"dimensions")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"CLUSTERED BY")," fields, unless\nyou set ",(0,r.kt)("inlineCode",{parentName:"p"},"forceSegmentSortByTime")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," in your\n",(0,r.kt)("a",{parentName:"p",href:"/docs/latest/multi-stage-query/reference#context-parameters"},"query context")," (for SQL) or in your\n",(0,r.kt)("a",{parentName:"p",href:"/docs/latest/ingestion/ingestion-spec#dimensionsspec"},(0,r.kt)("inlineCode",{parentName:"a"},"dimensionsSpec"))," (for other ingestion forms)."),(0,r.kt)("p",{parentName:"admonition"},"Setting ",(0,r.kt)("inlineCode",{parentName:"p"},"forceSegmentSortByTime")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," is an experimental feature. Segments created with sort orders that\ndo not start with ",(0,r.kt)("inlineCode",{parentName:"p"},"__time")," can only be read by Druid 31 or later. Additionally, at this time, certain queries are not\nsupported on such segments, including:"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"Native queries with ",(0,r.kt)("inlineCode",{parentName:"li"},"granularity")," other than ",(0,r.kt)("inlineCode",{parentName:"li"},"all"),"."),(0,r.kt)("li",{parentName:"ul"},"Native ",(0,r.kt)("inlineCode",{parentName:"li"},"scan")," query with ascending or descending time order."),(0,r.kt)("li",{parentName:"ul"},"SQL queries that plan into an unsupported native query."))),(0,r.kt)("h2",{id:"learn-more"},"Learn more"),(0,r.kt)("p",null,"See the following topics for more information:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/latest/ingestion/native-batch#partitionsspec"},(0,r.kt)("inlineCode",{parentName:"a"},"partitionsSpec"))," for more detail on partitioning with Native Batch ingestion."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/latest/data-management/update#reindex"},"Reindexing")," and ",(0,r.kt)("a",{parentName:"li",href:"/docs/latest/data-management/compaction"},"Compaction")," for information on how to repartition existing data in Druid.")))}g.isMDXComponent=!0}}]);