"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4113],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var s=t(96540);const i={},a=s.createContext(i);function o(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:n},e.children)}},60451:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"design/segments","title":"Segments","description":"\x3c!--","source":"@site/docs/latest/design/segments.md","sourceDirName":"design","slug":"/design/segments","permalink":"/docs/latest/design/segments","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"segments","title":"Segments"},"sidebar":"docs","previous":{"title":"Storage","permalink":"/docs/latest/design/storage"},"next":{"title":"Deep storage","permalink":"/docs/latest/design/deep-storage"}}');var i=t(74848),a=t(28453);const o={id:"segments",title:"Segments"},r=void 0,l={},c=[{value:"Segment file structure",id:"segment-file-structure",level:2},{value:"Handling null values",id:"handling-null-values",level:2},{value:"Segments with different schemas",id:"segments-with-different-schemas",level:2},{value:"Column format",id:"column-format",level:2},{value:"Multi-value columns",id:"multi-value-columns",level:3},{value:"Compression",id:"compression",level:2},{value:"Segment identification",id:"segment-identification",level:2},{value:"Segment ID examples",id:"segment-id-examples",level:3},{value:"Sharding",id:"sharding",level:2},{value:"Segment components",id:"segment-components",level:2},{value:"Implications of updating segments",id:"implications-of-updating-segments",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Apache Druid stores its data and indexes in ",(0,i.jsx)(n.em,{children:"segment files"})," partitioned by time. Druid creates a segment for each segment interval that contains data. If an interval is empty\u2014that is, containing no rows\u2014no segment exists for that time interval. Druid may create multiple segments for the same interval if you ingest data for that period via different ingestion jobs. ",(0,i.jsx)(n.a,{href:"/docs/latest/data-management/compaction",children:"Compaction"})," is the Druid process that attempts to combine these segments into a single segment per interval for optimal performance."]}),"\n",(0,i.jsxs)(n.p,{children:["The time interval is configurable in the ",(0,i.jsx)(n.code,{children:"segmentGranularity"})," parameter of the ",(0,i.jsx)(n.a,{href:"/docs/latest/ingestion/ingestion-spec#granularityspec",children:(0,i.jsx)(n.code,{children:"granularitySpec"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["For Druid to operate well under heavy query load, it is important for the segment\nfile size to be within the recommended range of 300-700 MB. If your\nsegment files are larger than this range, then consider either\nchanging the granularity of the segment time interval or partitioning your\ndata and/or adjusting the ",(0,i.jsx)(n.code,{children:"targetRowsPerSegment"})," in your ",(0,i.jsx)(n.code,{children:"partitionsSpec"}),'.\nA good starting point for this parameter is 5 million rows.\nSee the Sharding section below and the "Partitioning specification" section of\nthe ',(0,i.jsx)(n.a,{href:"/docs/latest/ingestion/hadoop#partitionsspec",children:"Batch ingestion"})," documentation\nfor more guidance."]}),"\n",(0,i.jsx)(n.h2,{id:"segment-file-structure",children:"Segment file structure"}),"\n",(0,i.jsxs)(n.p,{children:["Segment files are ",(0,i.jsx)(n.em,{children:"columnar"}),": the data for each column is laid out in\nseparate data structures. By storing each column separately, Druid decreases query latency by scanning only those columns actually needed for a query. There are three basic column types: timestamp, dimensions, and metrics:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Druid column types",src:t(97568).A+"",title:"Druid Column Types",width:"1936",height:"400"})}),"\n",(0,i.jsxs)(n.p,{children:["Timestamp and metrics type columns are arrays of integer or floating point values compressed with\n",(0,i.jsx)(n.a,{href:"https://github.com/lz4/lz4-java",children:"LZ4"}),". Once a query identifies which rows to select, it decompresses them, pulls out the relevant rows, and applies the\ndesired aggregation operator. If a query doesn\u2019t require a column, Druid skips over that column's data."]}),"\n",(0,i.jsx)(n.p,{children:"Dimension columns are different because they support filter and\ngroup-by operations, so each dimension requires the following\nthree data structures:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Dictionary"}),": Maps values (which are always treated as strings) to integer IDs, allowing compact representation of the list and bitmap values."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"List"}),": The column\u2019s values, encoded using the dictionary. Required for GroupBy and TopN queries. These operators allow queries that solely aggregate metrics based on filters to run without accessing the list of values."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Bitmap"}),": One bitmap for each distinct value in the column, to indicate which rows contain that value. Bitmaps allow for quick filtering operations because they are convenient for quickly applying AND and OR operators. Also known as inverted indexes."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:'To get a better sense of these data structures, consider the "Page" column from the example data above, represented by the following data structures:'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'1: Dictionary\n   {\n    "Justin Bieber": 0,\n    "Ke$ha":         1\n   }\n\n2: List of column data\n   [0,\n   0,\n   1,\n   1]\n\n3: Bitmaps\n   value="Justin Bieber": [1,1,0,0]\n   value="Ke$ha":         [0,0,1,1]\n'})}),"\n",(0,i.jsx)(n.p,{children:"Note that the bitmap is different from the dictionary and list data structures: the dictionary and list grow linearly with the size of the data, but the size of the bitmap section is the product of data size and column cardinality. That is, there is one bitmap per separate column value. Columns with the same value share the same bitmap."}),"\n",(0,i.jsxs)(n.p,{children:["For each row in the list of column data, there is only a single bitmap that has a non-zero entry. This means that high cardinality columns have extremely sparse, and therefore highly compressible, bitmaps. Druid exploits this using compression algorithms that are specially suited for bitmaps, such as ",(0,i.jsx)(n.a,{href:"https://github.com/RoaringBitmap/RoaringBitmap",children:"Roaring bitmap compression"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"handling-null-values",children:"Handling null values"}),"\n",(0,i.jsx)(n.p,{children:"String columns always store the null value if present in any row as id 0, the first position in the value dictionary and an associated entry in the bitmap value indexes used to filter null values. Numeric columns also store a null value bitmap index to indicate the null valued rows, which is used to null check aggregations and for filter matching null values."}),"\n",(0,i.jsx)(n.h2,{id:"segments-with-different-schemas",children:"Segments with different schemas"}),"\n",(0,i.jsx)(n.p,{children:"Druid segments for the same datasource may have different schemas. If a string column (dimension) exists in one segment but not another, queries that involve both segments still work. In default mode, queries for the segment without the dimension behave as if the dimension contains only blank values. In SQL-compatible mode, queries for the segment without the dimension behave as if the dimension contains only null values. Similarly, if one segment has a numeric column (metric) but another does not, queries on the segment without the metric generally operate as expected. Aggregations over the missing metric operate as if the metric doesn't exist."}),"\n",(0,i.jsx)(n.h2,{id:"column-format",children:"Column format"}),"\n",(0,i.jsx)(n.p,{children:"Each column is stored as two parts:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A Jackson-serialized ",(0,i.jsx)(n.code,{children:"ColumnDescriptor"}),"."]}),"\n",(0,i.jsx)(n.li,{children:"The binary data for the column."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"ColumnDescriptor"})," is  Jackson-serialized instance of the internal Druid ",(0,i.jsx)(n.code,{children:"ColumnDescriptor"})," class . It allows the use of Jackson's polymorphic deserialization to add new and interesting methods of serialization with minimal impact to the code. It consists of some metadata about the column (for example: type, whether it's multi-value) and a list of serialization/deserialization logic that can deserialize the rest of the binary."]}),"\n",(0,i.jsx)(n.h3,{id:"multi-value-columns",children:"Multi-value columns"}),"\n",(0,i.jsxs)(n.p,{children:["A multi-value column allows a single row to contain multiple strings for a column. You can think of it as an array of strings. If a datasource uses multi-value columns, then the data structures within the segment files look a bit different. Let's imagine that in the example above, the second row is tagged with both the ",(0,i.jsx)(n.code,{children:"Ke$ha"})," ",(0,i.jsx)(n.em,{children:"and"})," ",(0,i.jsx)(n.code,{children:"Justin Bieber"})," topics, as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'1: Dictionary\n   {\n    "Justin Bieber": 0,\n    "Ke$ha":         1\n   }\n\n2: List of column data\n   [0,\n   [0,1],  <--Row value in a multi-value column can contain an array of values\n   1,\n   1]\n\n3: Bitmaps\n   value="Justin Bieber": [1,1,0,0]\n   value="Ke$ha":         [0,1,1,1]\n                            ^\n                            |\n                            |\n   Multi-value column contains multiple non-zero entries\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Note the changes to the second row in the list of column data and the ",(0,i.jsx)(n.code,{children:"Ke$ha"}),"\nbitmap. If a row has more than one value for a column, its entry in\nthe list is an array of values. Additionally, a row with ",(0,i.jsx)(n.em,{children:"n"})," values in the list has ",(0,i.jsx)(n.em,{children:"n"})," non-zero valued entries in bitmaps."]}),"\n",(0,i.jsx)(n.h2,{id:"compression",children:"Compression"}),"\n",(0,i.jsx)(n.p,{children:"Druid uses LZ4 by default to compress blocks of values for string, long, float, and double columns. Druid uses Roaring to compress bitmaps for string columns and numeric null values. We recommend that you use these defaults unless you've experimented with your data and query patterns suggest that non-default options will perform better in your specific case."}),"\n",(0,i.jsxs)(n.p,{children:["Druid also supports Concise bitmap compression. For string column bitmaps, the differences between using Roaring and Concise are most pronounced for high cardinality columns. In this case, Roaring is substantially faster on filters that match many values, but in some cases Concise can have a lower footprint due to the overhead of the Roaring format (but is still slower when many values are matched). You configure compression at the segment level, not for individual columns. See ",(0,i.jsx)(n.a,{href:"/docs/latest/ingestion/ingestion-spec#indexspec",children:"IndexSpec"})," for more details."]}),"\n",(0,i.jsx)(n.h2,{id:"segment-identification",children:"Segment identification"}),"\n",(0,i.jsx)(n.p,{children:"Segment identifiers typically contain the segment datasource, interval start time (in ISO 8601 format), interval end time (in ISO 8601 format), and version information. If data is additionally sharded beyond a time range, the segment identifier also contains a partition number:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"datasource_intervalStart_intervalEnd_version_partitionNum"})}),"\n",(0,i.jsx)(n.h3,{id:"segment-id-examples",children:"Segment ID examples"}),"\n",(0,i.jsx)(n.p,{children:"The increasing partition numbers in the following segments indicate that multiple segments exist for the same interval:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"foo_2015-01-01/2015-01-02_v1_0\nfoo_2015-01-01/2015-01-02_v1_1\nfoo_2015-01-01/2015-01-02_v1_2\n"})}),"\n",(0,i.jsx)(n.p,{children:"If you reindex the data with a new schema, Druid allocates a new version ID to the newly created segments:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"foo_2015-01-01/2015-01-02_v2_0\nfoo_2015-01-01/2015-01-02_v2_1\nfoo_2015-01-01/2015-01-02_v2_2\n"})}),"\n",(0,i.jsx)(n.h2,{id:"sharding",children:"Sharding"}),"\n",(0,i.jsxs)(n.p,{children:["Multiple segments can exist for a single time interval and datasource. These segments form a ",(0,i.jsx)(n.code,{children:"block"})," for an interval. Depending on the type of ",(0,i.jsx)(n.code,{children:"shardSpec"})," used to shard the data, Druid queries may only complete if a ",(0,i.jsx)(n.code,{children:"block"})," is complete. For example, if a block consists of the following three segments:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"sampleData_2011-01-01T02:00:00:00Z_2011-01-01T03:00:00:00Z_v1_0\nsampleData_2011-01-01T02:00:00:00Z_2011-01-01T03:00:00:00Z_v1_1\nsampleData_2011-01-01T02:00:00:00Z_2011-01-01T03:00:00:00Z_v1_2\n"})}),"\n",(0,i.jsxs)(n.p,{children:["All three segments must load before a query for the interval ",(0,i.jsx)(n.code,{children:"2011-01-01T02:00:00:00Z_2011-01-01T03:00:00:00Z"})," can complete."]}),"\n",(0,i.jsx)(n.p,{children:'Linear shard specs are an exception to this rule. Linear shard specs do not enforce "completeness" so queries can complete even if shards are not completely loaded.'}),"\n",(0,i.jsx)(n.p,{children:"For example, if a real-time ingestion creates three segments that were sharded with linear shard spec, and only two of the segments are loaded, queries return results for those two segments."}),"\n",(0,i.jsx)(n.h2,{id:"segment-components",children:"Segment components"}),"\n",(0,i.jsx)(n.p,{children:"A segment contains several files:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"version.bin"})}),"\n",(0,i.jsx)(n.p,{children:"4 bytes representing the current segment version as an integer. For example, for v9 segments the version is 0x0, 0x0, 0x0, 0x9."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"meta.smoosh"})}),"\n",(0,i.jsxs)(n.p,{children:["A file containing metadata (filenames and offsets) about the contents of the other ",(0,i.jsx)(n.code,{children:"smoosh"})," files."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"XXXXX.smoosh"})}),"\n",(0,i.jsxs)(n.p,{children:["Smoosh (",(0,i.jsx)(n.code,{children:".smoosh"}),") files contain concatenated binary data. This file consolidation reduces the number of file descriptors that must be open when accessing data. The files are 2 GB or less in size to remain within the limit of a memory-mapped ",(0,i.jsx)(n.code,{children:"ByteBuffer"})," in Java.\nSmoosh files contain the following:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Individual files for each column in the data, including one for the ",(0,i.jsx)(n.code,{children:"__time"})," column that refers to the timestamp of the segment."]}),"\n",(0,i.jsxs)(n.li,{children:["An ",(0,i.jsx)(n.code,{children:"index.drd"})," file that contains additional segment metadata."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["In the codebase, segments have an internal format version. The current segment format version is ",(0,i.jsx)(n.code,{children:"v9"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"implications-of-updating-segments",children:"Implications of updating segments"}),"\n",(0,i.jsx)(n.p,{children:"Druid uses versioning to manage updates to create a form of multi-version concurrency control (MVCC). These MVCC versions are distinct from the segment format version discussed above."}),"\n",(0,i.jsx)(n.p,{children:"Note that updates that span multiple segment intervals are only atomic within each interval. They are not atomic across the entire update. For example, if you have the following segments:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"foo_2015-01-01/2015-01-02_v1_0\nfoo_2015-01-02/2015-01-03_v1_1\nfoo_2015-01-03/2015-01-04_v1_2\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"v2"})," segments are loaded into the cluster as soon as they are built and replace ",(0,i.jsx)(n.code,{children:"v1"})," segments for the period of time the segments overlap. Before ",(0,i.jsx)(n.code,{children:"v2"})," segments are completely loaded, the cluster may contain a mixture of ",(0,i.jsx)(n.code,{children:"v1"})," and ",(0,i.jsx)(n.code,{children:"v2"})," segments."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"foo_2015-01-01/2015-01-02_v1_0\nfoo_2015-01-02/2015-01-03_v2_1\nfoo_2015-01-03/2015-01-04_v1_2\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In this case, queries may hit a mixture of ",(0,i.jsx)(n.code,{children:"v1"})," and ",(0,i.jsx)(n.code,{children:"v2"})," segments."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},97568:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/druid-column-types-0cd9a011b4cc2b4d05f93b3b31a7e735.png"}}]);