"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1716],{28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var i=t(96540);const r={},a=i.createContext(r);function s(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:n},e.children)}},44518:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>s,metadata:()=>i,toc:()=>u});const i=JSON.parse('{"id":"querying/sql-translation","title":"SQL query translation","description":"\x3c!--","source":"@site/docs/33.0.0/querying/sql-translation.md","sourceDirName":"querying","slug":"/querying/sql-translation","permalink":"/docs/33.0.0/querying/sql-translation","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"sql-translation","title":"SQL query translation","sidebar_label":"SQL query translation"},"sidebar":"docs","previous":{"title":"SQL metadata tables","permalink":"/docs/33.0.0/querying/sql-metadata-tables"},"next":{"title":"Native queries","permalink":"/docs/33.0.0/querying/"}}');var r=t(74848),a=t(28453);const s={id:"sql-translation",title:"SQL query translation",sidebar_label:"SQL query translation"},o=void 0,l={},u=[{value:"Best practices",id:"best-practices",level:2},{value:"Interpreting EXPLAIN PLAN output",id:"interpreting-explain-plan-output",level:2},{value:"Query types",id:"query-types",level:2},{value:"Time filters",id:"time-filters",level:2},{value:"Joins",id:"joins",level:2},{value:"Subqueries",id:"subqueries",level:2},{value:"Approximations",id:"approximations",level:2},{value:"Unsupported features",id:"unsupported-features",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["Apache Druid supports two query languages: Druid SQL and ",(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/",children:"native queries"}),".\nThis document describes the Druid SQL language."]})}),"\n",(0,r.jsxs)(n.p,{children:["Druid uses ",(0,r.jsx)(n.a,{href:"https://calcite.apache.org/",children:"Apache Calcite"})," to parse and plan SQL queries.\nDruid translates SQL statements into its ",(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/",children:"native JSON-based query language"}),".\nIn general, the slight overhead of translating SQL on the Broker is the only minor performance penalty to using Druid SQL compared to native queries."]}),"\n",(0,r.jsx)(n.p,{children:"This topic includes best practices and tools to help you achieve good performance and minimize the impact of translation."}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best practices"}),"\n",(0,r.jsx)(n.p,{children:"Consider the following non-exhaustive list of best practices when looking into performance implications of\ntranslating Druid SQL queries to native queries."}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["If you wrote a filter on the primary time column ",(0,r.jsx)(n.code,{children:"__time"}),", make sure it is being correctly translated to an\n",(0,r.jsx)(n.code,{children:'"intervals"'})," filter, as described in the ",(0,r.jsx)(n.a,{href:"#time-filters",children:"Time filters"})," section below. If not, you may need to change\nthe way you write the filter."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Try to avoid subqueries underneath joins: they affect both performance and scalability. This includes implicit\nsubqueries generated by conditions on mismatched types, and implicit subqueries generated by conditions that use\nexpressions to refer to the right-hand side."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Currently, Druid does not support pushing down predicates (condition and filter) past a Join (i.e. into\nJoin's children). Druid only supports pushing predicates into the join if they originated from\nabove the join. Hence, the location of predicates and filters in your Druid SQL is very important.\nAlso, as a result of this, comma joins should be avoided."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Read through the ",(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/query-execution",children:"Query execution"})," page to understand how various types of native queries\nwill be executed."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Be careful when interpreting EXPLAIN PLAN output, and use request logging if in doubt. Request logs will show the\nexact native query that was run. See the ",(0,r.jsx)(n.a,{href:"#interpreting-explain-plan-output",children:"next section"})," for more details."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["If you encounter a query that could be planned better, feel free to\n",(0,r.jsx)(n.a,{href:"https://github.com/apache/druid/issues/new/choose",children:"raise an issue on GitHub"}),". A reproducible test case is always\nappreciated."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"interpreting-explain-plan-output",children:"Interpreting EXPLAIN PLAN output"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/sql#explain-plan",children:"EXPLAIN PLAN"})," functionality can help you understand how a given SQL query will\nbe translated to native.\nEXPLAIN PLAN statements return:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["a ",(0,r.jsx)(n.code,{children:"PLAN"})," column that contains a JSON array of native queries that Druid will run"]}),"\n",(0,r.jsxs)(n.li,{children:["a ",(0,r.jsx)(n.code,{children:"RESOURCES"})," column that describes the resources used in the query"]}),"\n",(0,r.jsxs)(n.li,{children:["an ",(0,r.jsx)(n.code,{children:"ATTRIBUTES"})," column that describes the attributes of the query, including:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"statementType"}),": the SQL statement type"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"targetDataSource"}),": the target datasource in an INSERT or REPLACE statement"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"partitionedBy"}),": the time-based partitioning granularity in an INSERT or REPLACE statement"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"clusteredBy"}),": the clustering columns in an INSERT or REPLACE statement"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"replaceTimeChunks"}),": the time chunks in a REPLACE statement"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Example 1: EXPLAIN PLAN for a ",(0,r.jsx)(n.code,{children:"SELECT"})," query on the ",(0,r.jsx)(n.code,{children:"wikipedia"})," datasource:"]}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:"Show the query"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"EXPLAIN PLAN FOR\nSELECT\n  channel,\n  COUNT(*)\nFROM wikipedia\nWHERE channel IN (SELECT page FROM wikipedia GROUP BY page ORDER BY COUNT(*) DESC LIMIT 10)\nGROUP BY channel\n"})})]}),"\n",(0,r.jsx)(n.p,{children:"The above EXPLAIN PLAN query returns the following result:"}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:"Show the result"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'[\n  [\n    {\n      "query": {\n        "queryType": "topN",\n        "dataSource": {\n          "type": "join",\n          "left": {\n            "type": "table",\n            "name": "wikipedia"\n          },\n          "right": {\n            "type": "query",\n            "query": {\n              "queryType": "groupBy",\n              "dataSource": {\n                "type": "table",\n                "name": "wikipedia"\n              },\n              "intervals": {\n                "type": "intervals",\n                "intervals": [\n                  "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z"\n                ]\n              },\n              "granularity": {\n                "type": "all"\n              },\n              "dimensions": [\n                {\n                  "type": "default",\n                  "dimension": "page",\n                  "outputName": "d0",\n                  "outputType": "STRING"\n                }\n              ],\n              "aggregations": [\n                {\n                  "type": "count",\n                  "name": "a0"\n                }\n              ],\n              "limitSpec": {\n                "type": "default",\n                "columns": [\n                  {\n                    "dimension": "a0",\n                    "direction": "descending",\n                    "dimensionOrder": {\n                      "type": "numeric"\n                    }\n                  }\n                ],\n                "limit": 10\n              },\n              "context": {\n                "sqlOuterLimit": 101,\n                "sqlQueryId": "ee616a36-c30c-4eae-af00-245127956e42",\n                "useApproximateCountDistinct": false,\n                "useApproximateTopN": false\n              }\n            }\n          },\n          "rightPrefix": "j0.",\n          "condition": "(\\"channel\\" == \\"j0.d0\\")",\n          "joinType": "INNER"\n        },\n        "dimension": {\n          "type": "default",\n          "dimension": "channel",\n          "outputName": "d0",\n          "outputType": "STRING"\n        },\n        "metric": {\n          "type": "dimension",\n          "ordering": {\n            "type": "lexicographic"\n          }\n        },\n        "threshold": 101,\n        "intervals": {\n          "type": "intervals",\n          "intervals": [\n            "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z"\n          ]\n        },\n        "granularity": {\n          "type": "all"\n        },\n        "aggregations": [\n          {\n            "type": "count",\n            "name": "a0"\n          }\n        ],\n        "context": {\n          "sqlOuterLimit": 101,\n          "sqlQueryId": "ee616a36-c30c-4eae-af00-245127956e42",\n          "useApproximateCountDistinct": false,\n          "useApproximateTopN": false\n        }\n      },\n      "signature": [\n        {\n          "name": "d0",\n          "type": "STRING"\n        },\n        {\n          "name": "a0",\n          "type": "LONG"\n        }\n      ],\n      "columnMappings": [\n        {\n          "queryColumn": "d0",\n          "outputColumn": "channel"\n        },\n        {\n          "queryColumn": "a0",\n          "outputColumn": "EXPR$1"\n        }\n      ]\n    }\n  ],\n  [\n    {\n      "name": "wikipedia",\n      "type": "DATASOURCE"\n    }\n  ],\n  {\n    "statementType": "SELECT"\n  }\n]\n'})})]}),"\n",(0,r.jsxs)(n.p,{children:["Example 2: EXPLAIN PLAN for an ",(0,r.jsx)(n.code,{children:"INSERT"})," query that inserts data into the ",(0,r.jsx)(n.code,{children:"wikipedia"})," datasource:"]}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:"Show the query"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:'EXPLAIN PLAN FOR\nINSERT INTO wikipedia2\nSELECT\n  TIME_PARSE("timestamp") AS __time,\n  namespace,\n  cityName,\n  countryName,\n  regionIsoCode,\n  metroCode,\n  countryIsoCode,\n  regionName\nFROM TABLE(\n    EXTERN(\n      \'{"type":"http","uris":["https://druid.apache.org/data/wikipedia.json.gz"]}\',\n      \'{"type":"json"}\',\n      \'[{"name":"timestamp","type":"string"},{"name":"namespace","type":"string"},{"name":"cityName","type":"string"},{"name":"countryName","type":"string"},{"name":"regionIsoCode","type":"string"},{"name":"metroCode","type":"long"},{"name":"countryIsoCode","type":"string"},{"name":"regionName","type":"string"}]\'\n    )\n  )\nPARTITIONED BY ALL\n'})})]}),"\n",(0,r.jsx)(n.p,{children:"The above EXPLAIN PLAN returns the following result:"}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:"Show the result"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'[\n  [\n    {\n      "query": {\n        "queryType": "scan",\n        "dataSource": {\n          "type": "external",\n          "inputSource": {\n            "type": "http",\n            "uris": [\n              "https://druid.apache.org/data/wikipedia.json.gz"\n            ]\n          },\n          "inputFormat": {\n            "type": "json"\n          },\n          "signature": [\n            {\n              "name": "timestamp",\n              "type": "STRING"\n            },\n            {\n              "name": "namespace",\n              "type": "STRING"\n            },\n            {\n              "name": "cityName",\n              "type": "STRING"\n            },\n            {\n              "name": "countryName",\n              "type": "STRING"\n            },\n            {\n              "name": "regionIsoCode",\n              "type": "STRING"\n            },\n            {\n              "name": "metroCode",\n              "type": "LONG"\n            },\n            {\n              "name": "countryIsoCode",\n              "type": "STRING"\n            },\n            {\n              "name": "regionName",\n              "type": "STRING"\n            }\n          ]\n        },\n        "intervals": {\n          "type": "intervals",\n          "intervals": [\n            "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z"\n          ]\n        },\n        "virtualColumns": [\n          {\n            "type": "expression",\n            "name": "v0",\n            "expression": "timestamp_parse(\\"timestamp\\",null,\'UTC\')",\n            "outputType": "LONG"\n          }\n        ],\n        "resultFormat": "compactedList",\n        "columns": [\n          "cityName",\n          "countryIsoCode",\n          "countryName",\n          "metroCode",\n          "namespace",\n          "regionIsoCode",\n          "regionName",\n          "v0"\n        ],\n        "context": {\n          "finalizeAggregations": false,\n          "forceExpressionVirtualColumns": true,\n          "groupByEnableMultiValueUnnesting": false,\n          "maxNumTasks": 5,\n          "multiStageQuery": true,\n          "queryId": "42e3de2b-daaf-40f9-a0e7-2c6184529ea3",\n          "scanSignature": "[{\\"name\\":\\"cityName\\",\\"type\\":\\"STRING\\"},{\\"name\\":\\"countryIsoCode\\",\\"type\\":\\"STRING\\"},{\\"name\\":\\"countryName\\",\\"type\\":\\"STRING\\"},{\\"name\\":\\"metroCode\\",\\"type\\":\\"LONG\\"},{\\"name\\":\\"namespace\\",\\"type\\":\\"STRING\\"},{\\"name\\":\\"regionIsoCode\\",\\"type\\":\\"STRING\\"},{\\"name\\":\\"regionName\\",\\"type\\":\\"STRING\\"},{\\"name\\":\\"v0\\",\\"type\\":\\"LONG\\"}]",\n          "sqlInsertSegmentGranularity": "{\\"type\\":\\"all\\"}",\n          "sqlQueryId": "42e3de2b-daaf-40f9-a0e7-2c6184529ea3",\n          "useNativeQueryExplain": true\n        },\n        "granularity": {\n          "type": "all"\n        }\n      },\n      "signature": [\n        {\n          "name": "v0",\n          "type": "LONG"\n        },\n        {\n          "name": "namespace",\n          "type": "STRING"\n        },\n        {\n          "name": "cityName",\n          "type": "STRING"\n        },\n        {\n          "name": "countryName",\n          "type": "STRING"\n        },\n        {\n          "name": "regionIsoCode",\n          "type": "STRING"\n        },\n        {\n          "name": "metroCode",\n          "type": "LONG"\n        },\n        {\n          "name": "countryIsoCode",\n          "type": "STRING"\n        },\n        {\n          "name": "regionName",\n          "type": "STRING"\n        }\n      ],\n      "columnMappings": [\n        {\n          "queryColumn": "v0",\n          "outputColumn": "__time"\n        },\n        {\n          "queryColumn": "namespace",\n          "outputColumn": "namespace"\n        },\n        {\n          "queryColumn": "cityName",\n          "outputColumn": "cityName"\n        },\n        {\n          "queryColumn": "countryName",\n          "outputColumn": "countryName"\n        },\n        {\n          "queryColumn": "regionIsoCode",\n          "outputColumn": "regionIsoCode"\n        },\n        {\n          "queryColumn": "metroCode",\n          "outputColumn": "metroCode"\n        },\n        {\n          "queryColumn": "countryIsoCode",\n          "outputColumn": "countryIsoCode"\n        },\n        {\n          "queryColumn": "regionName",\n          "outputColumn": "regionName"\n        }\n      ]\n    }\n  ],\n  [\n    {\n      "name": "EXTERNAL",\n      "type": "EXTERNAL"\n    },\n    {\n      "name": "wikipedia",\n      "type": "DATASOURCE"\n    }\n  ],\n  {\n    "statementType": "INSERT",\n    "targetDataSource": "wikipedia",\n    "partitionedBy": {\n      "type": "all"\n    }\n  }\n]\n'})})]}),"\n",(0,r.jsxs)(n.p,{children:["Example 3: EXPLAIN PLAN for a ",(0,r.jsx)(n.code,{children:"REPLACE"})," query that replaces all the data in the ",(0,r.jsx)(n.code,{children:"wikipedia"})," datasource with a ",(0,r.jsx)(n.code,{children:"DAY"}),"\ntime partitioning, and ",(0,r.jsx)(n.code,{children:"cityName"})," and ",(0,r.jsx)(n.code,{children:"countryName"})," as the clustering columns:"]}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:"Show the query"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:'EXPLAIN PLAN FOR\nREPLACE INTO wikipedia\nOVERWRITE ALL\nSELECT\n  TIME_PARSE("timestamp") AS __time,\n  namespace,\n  cityName,\n  countryName,\n  regionIsoCode,\n  metroCode,\n  countryIsoCode,\n  regionName\nFROM TABLE(\n    EXTERN(\n      \'{"type":"http","uris":["https://druid.apache.org/data/wikipedia.json.gz"]}\',\n      \'{"type":"json"}\',\n      \'[{"name":"timestamp","type":"string"},{"name":"namespace","type":"string"},{"name":"cityName","type":"string"},{"name":"countryName","type":"string"},{"name":"regionIsoCode","type":"string"},{"name":"metroCode","type":"long"},{"name":"countryIsoCode","type":"string"},{"name":"regionName","type":"string"}]\'\n    )\n  )\nPARTITIONED BY DAY\nCLUSTERED BY cityName, countryName\n'})})]}),"\n",(0,r.jsx)(n.p,{children:"The above EXPLAIN PLAN query returns the following result:"}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:"Show the result"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'[\n  [\n    {\n      "query": {\n        "queryType": "scan",\n        "dataSource": {\n          "type": "external",\n          "inputSource": {\n            "type": "http",\n            "uris": [\n              "https://druid.apache.org/data/wikipedia.json.gz"\n            ]\n          },\n          "inputFormat": {\n            "type": "json"\n          },\n          "signature": [\n            {\n              "name": "timestamp",\n              "type": "STRING"\n            },\n            {\n              "name": "namespace",\n              "type": "STRING"\n            },\n            {\n              "name": "cityName",\n              "type": "STRING"\n            },\n            {\n              "name": "countryName",\n              "type": "STRING"\n            },\n            {\n              "name": "regionIsoCode",\n              "type": "STRING"\n            },\n            {\n              "name": "metroCode",\n              "type": "LONG"\n            },\n            {\n              "name": "countryIsoCode",\n              "type": "STRING"\n            },\n            {\n              "name": "regionName",\n              "type": "STRING"\n            }\n          ]\n        },\n        "intervals": {\n          "type": "intervals",\n          "intervals": [\n            "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z"\n          ]\n        },\n        "virtualColumns": [\n          {\n            "type": "expression",\n            "name": "v0",\n            "expression": "timestamp_parse(\\"timestamp\\",null,\'UTC\')",\n            "outputType": "LONG"\n          }\n        ],\n        "resultFormat": "compactedList",\n        "columns": [\n          "cityName",\n          "countryIsoCode",\n          "countryName",\n          "metroCode",\n          "namespace",\n          "regionIsoCode",\n          "regionName",\n          "v0"\n        ],\n        "context": {\n          "finalizeAggregations": false,\n          "groupByEnableMultiValueUnnesting": false,\n          "maxNumTasks": 5,\n          "queryId": "d88e0823-76d4-40d9-a1a7-695c8577b79f",\n          "scanSignature": "[{\\"name\\":\\"cityName\\",\\"type\\":\\"STRING\\"},{\\"name\\":\\"countryIsoCode\\",\\"type\\":\\"STRING\\"},{\\"name\\":\\"countryName\\",\\"type\\":\\"STRING\\"},{\\"name\\":\\"metroCode\\",\\"type\\":\\"LONG\\"},{\\"name\\":\\"namespace\\",\\"type\\":\\"STRING\\"},{\\"name\\":\\"regionIsoCode\\",\\"type\\":\\"STRING\\"},{\\"name\\":\\"regionName\\",\\"type\\":\\"STRING\\"},{\\"name\\":\\"v0\\",\\"type\\":\\"LONG\\"}]",\n          "sqlInsertSegmentGranularity": "\\"DAY\\"",\n          "sqlQueryId": "d88e0823-76d4-40d9-a1a7-695c8577b79f",\n          "sqlReplaceTimeChunks": "all"\n        },\n        "granularity": {\n          "type": "all"\n        }\n      },\n      "signature": [\n        {\n          "name": "v0",\n          "type": "LONG"\n        },\n        {\n          "name": "namespace",\n          "type": "STRING"\n        },\n        {\n          "name": "cityName",\n          "type": "STRING"\n        },\n        {\n          "name": "countryName",\n          "type": "STRING"\n        },\n        {\n          "name": "regionIsoCode",\n          "type": "STRING"\n        },\n        {\n          "name": "metroCode",\n          "type": "LONG"\n        },\n        {\n          "name": "countryIsoCode",\n          "type": "STRING"\n        },\n        {\n          "name": "regionName",\n          "type": "STRING"\n        }\n      ],\n      "columnMappings": [\n        {\n          "queryColumn": "v0",\n          "outputColumn": "__time"\n        },\n        {\n          "queryColumn": "namespace",\n          "outputColumn": "namespace"\n        },\n        {\n          "queryColumn": "cityName",\n          "outputColumn": "cityName"\n        },\n        {\n          "queryColumn": "countryName",\n          "outputColumn": "countryName"\n        },\n        {\n          "queryColumn": "regionIsoCode",\n          "outputColumn": "regionIsoCode"\n        },\n        {\n          "queryColumn": "metroCode",\n          "outputColumn": "metroCode"\n        },\n        {\n          "queryColumn": "countryIsoCode",\n          "outputColumn": "countryIsoCode"\n        },\n        {\n          "queryColumn": "regionName",\n          "outputColumn": "regionName"\n        }\n      ]\n    }\n  ],\n  [\n    {\n      "name": "EXTERNAL",\n      "type": "EXTERNAL"\n    },\n    {\n      "name": "wikipedia",\n      "type": "DATASOURCE"\n    }\n  ],\n  {\n    "statementType": "REPLACE",\n    "targetDataSource": "wikipedia",\n    "partitionedBy": "DAY",\n    "clusteredBy": ["cityName","countryName"],\n    "replaceTimeChunks": "all"\n  }\n]\n'})})]}),"\n",(0,r.jsxs)(n.p,{children:["In this case the JOIN operator gets translated to a ",(0,r.jsx)(n.code,{children:"join"})," datasource. See the ",(0,r.jsx)(n.a,{href:"#joins",children:"Join translation"})," section\nfor more details about how this works."]}),"\n",(0,r.jsxs)(n.p,{children:["We can see this for ourselves using Druid's ",(0,r.jsx)(n.a,{href:"/docs/33.0.0/configuration/#request-logging",children:"request logging"})," feature. After\nenabling logging and running this query, we can see that it actually runs as the following native query."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "queryType": "groupBy",\n  "dataSource": {\n    "type": "join",\n    "left": "wikipedia",\n    "right": {\n      "type": "query",\n      "query": {\n        "queryType": "topN",\n        "dataSource": "wikipedia",\n        "dimension": {"type": "default", "dimension": "page", "outputName": "d0"},\n        "metric": {"type": "numeric", "metric": "a0"},\n        "threshold": 10,\n        "intervals": "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z",\n        "granularity": "all",\n        "aggregations": [\n          { "type": "count", "name": "a0"}\n        ]\n      }\n    },\n    "rightPrefix": "j0.",\n    "condition": "(\\"page\\" == \\"j0.d0\\")",\n    "joinType": "INNER"\n  },\n  "intervals": "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z",\n  "granularity": "all",\n  "dimensions": [\n    {"type": "default", "dimension": "channel", "outputName": "d0"}\n  ],\n  "aggregations": [\n    { "type": "count", "name": "a0"}\n  ]\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"query-types",children:"Query types"}),"\n",(0,r.jsx)(n.p,{children:"Druid SQL uses four different native query types."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/scan-query",children:"Scan"})," is used for queries that do not aggregate\u2014no GROUP BY, no DISTINCT."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/timeseriesquery",children:"Timeseries"})," is used for queries that GROUP BY ",(0,r.jsx)(n.code,{children:"FLOOR(__time TO unit)"})," or ",(0,r.jsx)(n.code,{children:"TIME_FLOOR(__time, period)"}),', have no other grouping expressions, no HAVING clause, no nesting, and either no ORDER BY, or an\nORDER BY that orders by same expression as present in GROUP BY. It also uses Timeseries for "grand total" queries that\nhave aggregation functions but no GROUP BY. This query type takes advantage of the fact that Druid segments are sorted\nby time.']}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/topnquery",children:"TopN"}),' is used by default for queries that group by a single expression, do have ORDER BY and LIMIT\nclauses, do not have HAVING clauses, and are not nested. However, the TopN query type will deliver approximate ranking\nand results in some cases; if you want to avoid this, set "useApproximateTopN" to "false". TopN results are always\ncomputed in memory. See the TopN documentation for more details.']}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/groupbyquery",children:"GroupBy"})," is used for all other aggregations, including any nested aggregation queries. Druid's\nGroupBy is a traditional aggregation engine: it delivers exact results and rankings and supports a wide variety of\nfeatures. GroupBy aggregates in memory if it can, but it may spill to disk if it doesn't have enough memory to complete\nyour query. Results are streamed back from data processes through the Broker if you ORDER BY the same expressions in your\nGROUP BY clause, or if you don't have an ORDER BY at all. If your query has an ORDER BY referencing expressions that\ndon't appear in the GROUP BY clause (like aggregation functions) then the Broker will materialize a list of results in\nmemory, up to a max of your LIMIT, if any. See the GroupBy documentation for details about tuning performance and memory\nuse."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"time-filters",children:"Time filters"}),"\n",(0,r.jsxs)(n.p,{children:["For all native query types, filters on the ",(0,r.jsx)(n.code,{children:"__time"}),' column will be translated into top-level query "intervals" whenever\npossible, which allows Druid to use its global time index to quickly prune the set of data that must be scanned.\nConsider this (non-exhaustive) list of time filters that will be recognized and translated to "intervals":']}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"__time >= TIMESTAMP '2000-01-01 00:00:00'"})," (comparison to absolute time)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"__time >= CURRENT_TIMESTAMP - INTERVAL '8' HOUR"})," (comparison to relative time)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"FLOOR(__time TO DAY) = TIMESTAMP '2000-01-01 00:00:00'"})," (specific day)"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Refer to the ",(0,r.jsx)(n.a,{href:"#interpreting-explain-plan-output",children:"Interpreting EXPLAIN PLAN output"})," section for details on confirming\nthat time filters are being translated as you expect."]}),"\n",(0,r.jsx)(n.h2,{id:"joins",children:"Joins"}),"\n",(0,r.jsx)(n.p,{children:"SQL join operators are translated to native join datasources as follows:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Joins that the native layer can handle directly are translated literally, to a ",(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/datasource#join",children:"join datasource"}),"\nwhose ",(0,r.jsx)(n.code,{children:"left"}),", ",(0,r.jsx)(n.code,{children:"right"}),", and ",(0,r.jsx)(n.code,{children:"condition"})," are faithful translations of the original SQL. This includes any SQL join where\nthe right-hand side is a lookup or subquery, and where the condition is an equality where one side is an expression based\non the left-hand table, the other side is a simple column reference to the right-hand table, and both sides of the\nequality are the same data type."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["If a join cannot be handled directly by a native ",(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/datasource#join",children:"join datasource"})," as written, Druid SQL\nwill insert subqueries to make it runnable. For example, ",(0,r.jsx)(n.code,{children:"foo INNER JOIN bar ON foo.abc = LOWER(bar.def)"})," cannot be\ndirectly translated, because there is an expression on the right-hand side instead of a simple column access. A subquery\nwill be inserted that effectively transforms this clause to\n",(0,r.jsx)(n.code,{children:"foo INNER JOIN (SELECT LOWER(def) AS def FROM bar) t ON foo.abc = t.def"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Druid SQL does not currently reorder joins to optimize queries."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Refer to the ",(0,r.jsx)(n.a,{href:"#interpreting-explain-plan-output",children:"Interpreting EXPLAIN PLAN output"})," section for details on confirming\nthat joins are being translated as you expect."]}),"\n",(0,r.jsxs)(n.p,{children:["Refer to the ",(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/query-execution#join",children:"Query execution"})," page for information about how joins are executed."]}),"\n",(0,r.jsx)(n.h2,{id:"subqueries",children:"Subqueries"}),"\n",(0,r.jsxs)(n.p,{children:["Subqueries in SQL are generally translated to native query datasources. Refer to the\n",(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/query-execution#query",children:"Query execution"})," page for information about how subqueries are executed."]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["Note: Subqueries in the WHERE clause, like ",(0,r.jsx)(n.code,{children:"WHERE col1 IN (SELECT foo FROM ...)"})," are translated to inner joins."]})}),"\n",(0,r.jsx)(n.h2,{id:"approximations",children:"Approximations"}),"\n",(0,r.jsx)(n.p,{children:"Druid SQL will use approximate algorithms in some situations:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"COUNT(DISTINCT col)"})," aggregation functions by default uses a variant of\n",(0,r.jsx)(n.a,{href:"http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf",children:"HyperLogLog"}),', a fast approximate distinct counting\nalgorithm. Druid SQL will switch to exact distinct counts if you set "useApproximateCountDistinct" to "false", either\nthrough query context or through Broker configuration.']}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:'GROUP BY queries over a single column with ORDER BY and LIMIT may be executed using the TopN engine, which uses an\napproximate algorithm. Druid SQL will switch to an exact grouping algorithm if you set "useApproximateTopN" to "false",\neither through query context or through Broker configuration.'}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Aggregation functions that are labeled as using sketches or approximations, such as APPROX_COUNT_DISTINCT, are always\napproximate, regardless of configuration."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"A known issue with approximate functions based on data sketches"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"APPROX_QUANTILE_DS"})," and ",(0,r.jsx)(n.code,{children:"DS_QUANTILES_SKETCH"})," functions can fail with an ",(0,r.jsx)(n.code,{children:"IllegalStateException"})," if one of the sketches for\nthe query hits ",(0,r.jsx)(n.code,{children:"maxStreamLength"}),": the maximum number of items to store in each sketch.\nSee ",(0,r.jsx)(n.a,{href:"https://github.com/apache/druid/issues/11544",children:"GitHub issue 11544"})," for more details.\nTo workaround the issue, increase value of the maximum string length with the ",(0,r.jsx)(n.code,{children:"approxQuantileDsMaxStreamLength"})," parameter\nin the query context. Since it is set to 1,000,000,000 by default, you don't need to override it in most cases.\nSee ",(0,r.jsx)(n.a,{href:"https://datasketches.apache.org/docs/Quantiles/ClassicQuantilesSketch.html",children:"accuracy information"})," in the DataSketches documentation for how many bytes are required per stream length.\nThis query context  parameter is a temporary solution to avoid the known issue. It may be removed in a future release after the bug is fixed."]}),"\n",(0,r.jsx)(n.h2,{id:"unsupported-features",children:"Unsupported features"}),"\n",(0,r.jsx)(n.p,{children:"Druid does not support all SQL features. In particular, the following features are not supported."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["JOIN between native datasources (table, lookup, subquery) and ",(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/sql-metadata-tables",children:"system tables"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"JOIN conditions that are not an equality between expressions from the left- and right-hand sides."}),"\n",(0,r.jsx)(n.li,{children:"JOIN conditions containing a constant value inside the condition."}),"\n",(0,r.jsx)(n.li,{children:"JOIN conditions on a column which contains a multi-value dimension."}),"\n",(0,r.jsxs)(n.li,{children:["ORDER BY for a non-aggregating query, except for ",(0,r.jsx)(n.code,{children:"ORDER BY __time"})," or ",(0,r.jsx)(n.code,{children:"ORDER BY __time DESC"}),", which are supported.\nThis restriction only applies to non-aggregating queries; you can ORDER BY any column in an aggregating query."]}),"\n",(0,r.jsx)(n.li,{children:"DDL and DML."}),"\n",(0,r.jsxs)(n.li,{children:["Using Druid-specific functions like ",(0,r.jsx)(n.code,{children:"TIME_PARSE"})," and ",(0,r.jsx)(n.code,{children:"APPROX_QUANTILE_DS"})," on ",(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/sql-metadata-tables",children:"system tables"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Additionally, some Druid native query features are not supported by the SQL language. Some unsupported Druid features\ninclude:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/datasource#inline",children:"Inline datasources"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/geo",children:"Spatial filters"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/33.0.0/querying/sql-data-types#multi-value-strings",children:"Multi-value dimensions"})," are only partially implemented in Druid SQL. There are known\ninconsistencies between their behavior in SQL queries and in native queries due to how they are currently treated by\nthe SQL planner."]}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);