"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9518],{22319:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>u,contentTitle:()=>a,default:()=>d,frontMatter:()=>t,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"querying/joins","title":"Joins","description":"\x3c!--","source":"@site/docs/33.0.0/querying/joins.md","sourceDirName":"querying","slug":"/querying/joins","permalink":"/docs/33.0.0/querying/joins","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"joins","title":"Joins"},"sidebar":"docs","previous":{"title":"Datasources","permalink":"/docs/33.0.0/querying/datasource"},"next":{"title":"Lookups","permalink":"/docs/33.0.0/querying/lookups"}}');var s=o(74848),r=o(28453);const t={id:"joins",title:"Joins"},a=void 0,u={},c=[];function l(e){const n={a:"a",li:"li",ol:"ol",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Apache Druid has two features related to joining of data:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/33.0.0/querying/datasource#join",children:"Join"})," operators. These are available using a ",(0,s.jsx)(n.a,{href:"/docs/33.0.0/querying/datasource#join",children:"join datasource"})," in native\nqueries, or using the ",(0,s.jsx)(n.a,{href:"/docs/33.0.0/querying/sql",children:"JOIN operator"})," in Druid SQL. Refer to the\n",(0,s.jsx)(n.a,{href:"/docs/33.0.0/querying/datasource#join",children:"join datasource"})," documentation for information about how joins work in Druid native queries,\nor the ",(0,s.jsx)(n.a,{href:"/docs/33.0.0/multi-stage-query/reference#joins",children:"multi-stage query join documentation"})," for information about how joins\nwork in multi-stage query tasks."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/33.0.0/querying/lookups",children:"Query-time lookups"}),", simple key-to-value mappings. These are preloaded on all servers that are involved\nin queries and can be accessed with or without an explicit join operator. Refer to the ",(0,s.jsx)(n.a,{href:"/docs/33.0.0/querying/lookups",children:"lookups"}),"\ndocumentation for more details."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Whenever possible, for best performance it is good to avoid joins at query time. Often this can be accomplished by\njoining data before it is loaded into Druid. However, there are situations where joins or lookups are the best solution\navailable despite the performance overhead, including:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The fact-to-dimension (star and snowflake schema) case: you need to change dimension values after initial ingestion,\nand aren't able to reingest to do this. In this case, you can use lookups for your dimension tables."}),"\n",(0,s.jsx)(n.li,{children:"Your workload requires joins or filters on subqueries."}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453:(e,n,o)=>{o.d(n,{R:()=>t,x:()=>a});var i=o(96540);const s={},r=i.createContext(s);function t(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);