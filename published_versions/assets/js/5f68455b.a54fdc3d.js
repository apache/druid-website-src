"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[955],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>k});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var u=r.createContext({}),d=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},s=function(e){var t=d(e.components);return r.createElement(u.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,u=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),p=d(n),c=a,k=p["".concat(u,".").concat(c)]||p[c]||m[c]||i;return n?r.createElement(k,l(l({ref:t},s),{},{components:n})):r.createElement(k,l({ref:t},s))}));function k(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,l=new Array(i);l[0]=c;var o={};for(var u in t)hasOwnProperty.call(t,u)&&(o[u]=t[u]);o.originalType=e,o[p]="string"==typeof e?e:a,l[1]=o;for(var d=2;d<i;d++)l[d]=n[d];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"},31515:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>u,default:()=>k,frontMatter:()=>o,metadata:()=>d,toc:()=>p});var r=n(87462),a=n(63366),i=(n(67294),n(3905)),l=["components"],o={id:"sql-query-context",title:"SQL query context",sidebar_label:"SQL query context"},u=void 0,d={unversionedId:"querying/sql-query-context",id:"querying/sql-query-context",title:"SQL query context",description:"\x3c!--",source:"@site/docs/29.0.1/querying/sql-query-context.md",sourceDirName:"querying",slug:"/querying/sql-query-context",permalink:"/docs/29.0.1/querying/sql-query-context",draft:!1,tags:[],version:"current",frontMatter:{id:"sql-query-context",title:"SQL query context",sidebar_label:"SQL query context"},sidebar:"docs",previous:{title:"All functions",permalink:"/docs/29.0.1/querying/sql-functions"},next:{title:"SQL metadata tables",permalink:"/docs/29.0.1/querying/sql-metadata-tables"}},s={},p=[{value:"SQL query context parameters",id:"sql-query-context-parameters",level:2},{value:"Setting the query context",id:"setting-the-query-context",level:2},{value:"Example using JSON API",id:"example-using-json-api",level:3},{value:"Example using JDBC",id:"example-using-jdbc",level:3}],m={toc:p},c="wrapper";function k(e){var t=e.components,n=(0,a.Z)(e,l);return(0,i.kt)(c,(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"}," Apache Druid supports two query languages: Druid SQL and ",(0,i.kt)("a",{parentName:"p",href:"/docs/29.0.1/querying/"},"native queries"),".\nThis document describes the SQL language.")),(0,i.kt)("p",null,"Druid supports query context parameters which affect ",(0,i.kt)("a",{parentName:"p",href:"/docs/29.0.1/querying/sql"},"SQL query")," planning.\nSee ",(0,i.kt)("a",{parentName:"p",href:"/docs/29.0.1/querying/query-context"},"Query context")," for general query context parameters for all query types."),(0,i.kt)("h2",{id:"sql-query-context-parameters"},"SQL query context parameters"),(0,i.kt)("p",null,"Configure Druid SQL query planning using the parameters in the table below."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"),(0,i.kt)("th",{parentName:"tr",align:null},"Default value"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"sqlQueryId")),(0,i.kt)("td",{parentName:"tr",align:null},"Unique identifier given to this SQL query. For HTTP client, it will be returned in ",(0,i.kt)("inlineCode",{parentName:"td"},"X-Druid-SQL-Query-Id")," header.",(0,i.kt)("br",null),(0,i.kt)("br",null),"To specify a unique identifier for SQL query, use ",(0,i.kt)("inlineCode",{parentName:"td"},"sqlQueryId")," instead of ",(0,i.kt)("a",{parentName:"td",href:"/docs/29.0.1/querying/query-context"},(0,i.kt)("inlineCode",{parentName:"a"},"queryId")),". Setting ",(0,i.kt)("inlineCode",{parentName:"td"},"queryId")," for a SQL request has no effect. All native queries underlying SQL use an auto-generated ",(0,i.kt)("inlineCode",{parentName:"td"},"queryId"),"."),(0,i.kt)("td",{parentName:"tr",align:null},"auto-generated")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"sqlTimeZone")),(0,i.kt)("td",{parentName:"tr",align:null},'Sets the time zone for this connection, which will affect how time functions and timestamp literals behave. Should be a time zone name like "America/Los_Angeles" or offset like "-08:00".'),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"druid.sql.planner.sqlTimeZone")," on the Broker (default: UTC)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"sqlStringifyArrays")),(0,i.kt)("td",{parentName:"tr",align:null},"When set to true, result columns which return array values will be serialized into a JSON string in the response instead of as an array"),(0,i.kt)("td",{parentName:"tr",align:null},"true, except for JDBC connections, where it is always false")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"useApproximateCountDistinct")),(0,i.kt)("td",{parentName:"tr",align:null},"Whether to use an approximate cardinality algorithm for ",(0,i.kt)("inlineCode",{parentName:"td"},"COUNT(DISTINCT foo)"),"."),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"druid.sql.planner.useApproximateCountDistinct")," on the Broker (default: true)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"useGroupingSetForExactDistinct")),(0,i.kt)("td",{parentName:"tr",align:null},"Whether to use grouping sets to execute queries with multiple exact distinct aggregations."),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"druid.sql.planner.useGroupingSetForExactDistinct")," on the Broker (default: false)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"useApproximateTopN")),(0,i.kt)("td",{parentName:"tr",align:null},"Whether to use approximate ",(0,i.kt)("a",{parentName:"td",href:"/docs/29.0.1/querying/topnquery"},"TopN queries")," when a SQL query could be expressed as such. If false, exact ",(0,i.kt)("a",{parentName:"td",href:"/docs/29.0.1/querying/groupbyquery"},"GroupBy queries")," will be used instead."),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"druid.sql.planner.useApproximateTopN")," on the Broker (default: true)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"enableTimeBoundaryPlanning")),(0,i.kt)("td",{parentName:"tr",align:null},"If true, SQL queries will get converted to TimeBoundary queries wherever possible. TimeBoundary queries are very efficient for min-max calculation on ",(0,i.kt)("inlineCode",{parentName:"td"},"__time")," column in a datasource"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"druid.query.default.context.enableTimeBoundaryPlanning")," on the Broker (default: false)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"useNativeQueryExplain")),(0,i.kt)("td",{parentName:"tr",align:null},"If true, ",(0,i.kt)("inlineCode",{parentName:"td"},"EXPLAIN PLAN FOR")," will return the explain plan as a JSON representation of equivalent native query(s), else it will return the original version of explain plan generated by Calcite.",(0,i.kt)("br",null),(0,i.kt)("br",null),"This property is provided for backwards compatibility. It is not recommended to use this parameter unless you were depending on the older behavior."),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"druid.sql.planner.useNativeQueryExplain")," on the Broker (default: true)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"sqlFinalizeOuterSketches")),(0,i.kt)("td",{parentName:"tr",align:null},"If false (default behavior in Druid 25.0.0 and later), ",(0,i.kt)("inlineCode",{parentName:"td"},"DS_HLL"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"DS_THETA"),", and ",(0,i.kt)("inlineCode",{parentName:"td"},"DS_QUANTILES_SKETCH")," return sketches in query results, as documented. If true (default behavior in Druid 24.0.1 and earlier), sketches from these functions are finalized when they appear in query results.",(0,i.kt)("br",null),(0,i.kt)("br",null),"This property is provided for backwards compatibility with behavior in Druid 24.0.1 and earlier. It is not recommended to use this parameter unless you were depending on the older behavior. Instead, use a function that does not return a sketch, such as ",(0,i.kt)("inlineCode",{parentName:"td"},"APPROX_COUNT_DISTINCT_DS_HLL"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"APPROX_COUNT_DISTINCT_DS_THETA"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"APPROX_QUANTILE_DS"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"DS_THETA_ESTIMATE"),", or ",(0,i.kt)("inlineCode",{parentName:"td"},"DS_GET_QUANTILE"),"."),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"druid.query.default.context.sqlFinalizeOuterSketches")," on the Broker (default: false)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"sqlUseBoundAndSelectors")),(0,i.kt)("td",{parentName:"tr",align:null},"If false (default behavior if ",(0,i.kt)("inlineCode",{parentName:"td"},"druid.generic.useDefaultValueForNull=false")," in Druid 27.0.0 and later), the SQL planner will use ",(0,i.kt)("a",{parentName:"td",href:"/docs/29.0.1/querying/filters#equality-filter"},"equality"),", ",(0,i.kt)("a",{parentName:"td",href:"/docs/29.0.1/querying/filters#null-filter"},"null"),", and ",(0,i.kt)("a",{parentName:"td",href:"/docs/29.0.1/querying/filters#range-filter"},"range")," filters instead of ",(0,i.kt)("a",{parentName:"td",href:"/docs/29.0.1/querying/filters#selector-filter"},"selector")," and ",(0,i.kt)("a",{parentName:"td",href:"/docs/29.0.1/querying/filters#bound-filter"},"bounds"),". This value must be set to ",(0,i.kt)("inlineCode",{parentName:"td"},"false")," for correct behavior for filtering ",(0,i.kt)("inlineCode",{parentName:"td"},"ARRAY")," typed values."),(0,i.kt)("td",{parentName:"tr",align:null},"Defaults to same value as ",(0,i.kt)("inlineCode",{parentName:"td"},"druid.generic.useDefaultValueForNull"),", which is ",(0,i.kt)("inlineCode",{parentName:"td"},"false"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"sqlReverseLookup")),(0,i.kt)("td",{parentName:"tr",align:null},"Whether to consider the ",(0,i.kt)("a",{parentName:"td",href:"/docs/29.0.1/querying/lookups#reverse-lookup"},"reverse-lookup rewrite")," of the ",(0,i.kt)("inlineCode",{parentName:"td"},"LOOKUP")," function during SQL planning.",(0,i.kt)("br",null),(0,i.kt)("br",null),"Calls to ",(0,i.kt)("inlineCode",{parentName:"td"},"LOOKUP")," are only reversed when the number of matching keys is lower than both ",(0,i.kt)("inlineCode",{parentName:"td"},"inSubQueryThreshold")," and ",(0,i.kt)("inlineCode",{parentName:"td"},"sqlReverseLookupThreshold"),"."),(0,i.kt)("td",{parentName:"tr",align:null},"true")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"sqlReverseLookupThreshold")),(0,i.kt)("td",{parentName:"tr",align:null},"Maximum size of ",(0,i.kt)("inlineCode",{parentName:"td"},"IN")," filter to create when applying a ",(0,i.kt)("a",{parentName:"td",href:"/docs/29.0.1/querying/lookups#reverse-lookup"},"reverse-lookup rewrite"),". If a ",(0,i.kt)("inlineCode",{parentName:"td"},"LOOKUP")," call matches more keys than this threshold, it is left as-is.",(0,i.kt)("br",null),(0,i.kt)("br",null),"If ",(0,i.kt)("inlineCode",{parentName:"td"},"inSubQueryThreshold")," is lower than ",(0,i.kt)("inlineCode",{parentName:"td"},"sqlReverseLookupThreshold"),", the ",(0,i.kt)("inlineCode",{parentName:"td"},"inSubQueryThreshold")," is used as the threshold instead."),(0,i.kt)("td",{parentName:"tr",align:null},"10000")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"sqlPullUpLookup")),(0,i.kt)("td",{parentName:"tr",align:null},"Whether to consider the ",(0,i.kt)("a",{parentName:"td",href:"/docs/29.0.1/querying/lookups#pull-up"},"pull-up rewrite")," of the ",(0,i.kt)("inlineCode",{parentName:"td"},"LOOKUP")," function during SQL planning."),(0,i.kt)("td",{parentName:"tr",align:null},"true")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"enableJoinLeftTableScanDirect")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"false")),(0,i.kt)("td",{parentName:"tr",align:null},"This flag applies to queries which have joins. For joins, where left child is a simple scan with a filter,  by default, druid will run the scan as a query and the join the results to the right child on broker. Setting this flag to true overrides that behavior and druid will attempt to push the join to data servers instead. Please note that the flag could be applicable to queries even if there is no explicit join. since queries can internally translated into a join by the SQL planner.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"maxNumericInFilters")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"-1")),(0,i.kt)("td",{parentName:"tr",align:null},"Max limit for the amount of numeric values that can be compared for a string type dimension when the entire SQL WHERE clause of a query translates only to an ",(0,i.kt)("a",{parentName:"td",href:"/docs/29.0.1/querying/filters#or"},"OR")," of ",(0,i.kt)("a",{parentName:"td",href:"/docs/29.0.1/querying/filters#bound-filter"},"Bound filter"),". By default, Druid does not restrict the amount of of numeric Bound Filters on String columns, although this situation may block other queries from running. Set this parameter to a smaller value to prevent Druid from running queries that have prohibitively long segment processing times. The optimal limit requires some trial and error; we recommend starting with 100.  Users who submit a query that exceeds the limit of ",(0,i.kt)("inlineCode",{parentName:"td"},"maxNumericInFilters")," should instead rewrite their queries to use strings in the ",(0,i.kt)("inlineCode",{parentName:"td"},"WHERE")," clause instead of numbers. For example, ",(0,i.kt)("inlineCode",{parentName:"td"},"WHERE someString IN (\u2018123\u2019, \u2018456\u2019)"),". This value cannot exceed the set system configuration ",(0,i.kt)("inlineCode",{parentName:"td"},"druid.sql.planner.maxNumericInFilters"),". This value is ignored if ",(0,i.kt)("inlineCode",{parentName:"td"},"druid.sql.planner.maxNumericInFilters")," is not set explicitly.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"inSubQueryThreshold")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"2147483647")),(0,i.kt)("td",{parentName:"tr",align:null},"Threshold for minimum number of values in an IN clause to convert the query to a JOIN operation on an inlined table rather than a predicate. A threshold of 0 forces usage of an inline table in all cases; a threshold of ","[Integer.MAX_VALUE]"," forces usage of OR in all cases.")))),(0,i.kt)("h2",{id:"setting-the-query-context"},"Setting the query context"),(0,i.kt)("p",null,'The query context parameters can be specified as a "context" object in the ',(0,i.kt)("a",{parentName:"p",href:"/docs/29.0.1/api-reference/sql-api"},"JSON API")," or as a ",(0,i.kt)("a",{parentName:"p",href:"/docs/29.0.1/api-reference/sql-jdbc"},"JDBC connection properties object"),".\nSee examples for each option below."),(0,i.kt)("h3",{id:"example-using-json-api"},"Example using JSON API"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'{\n  "query" : "SELECT COUNT(*) FROM data_source WHERE foo = \'bar\' AND __time > TIMESTAMP \'2000-01-01 00:00:00\'",\n  "context" : {\n    "sqlTimeZone" : "America/Los_Angeles"\n  }\n}\n')),(0,i.kt)("h3",{id:"example-using-jdbc"},"Example using JDBC"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'String url = "jdbc:avatica:remote:url=http://localhost:8082/druid/v2/sql/avatica/";\n\n// Set any query context parameters you need here.\nProperties connectionProperties = new Properties();\nconnectionProperties.setProperty("sqlTimeZone", "America/Los_Angeles");\nconnectionProperties.setProperty("useCache", "false");\n\ntry (Connection connection = DriverManager.getConnection(url, connectionProperties)) {\n  // create and execute statements, process result sets, etc\n}\n')))}k.isMDXComponent=!0}}]);