"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8882],{6620:(e,s,i)=>{i.d(s,{A:()=>t});const t=i.p+"assets/images/supervisor-actions-7ac02856cc2f02bfb04ffeacd1c0beeb.png"},28453:(e,s,i)=>{i.d(s,{R:()=>o,x:()=>d});var t=i(96540);const n={},r=t.createContext(n);function o(e){const s=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function d(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),t.createElement(r.Provider,{value:s},e.children)}},38662:(e,s,i)=>{i.d(s,{A:()=>t});const t=i.p+"assets/images/supervisor-view-83f761c82cf23094ae3d37c91371b655.png"},68137:(e,s,i)=>{i.r(s),i.d(s,{assets:()=>a,contentTitle:()=>d,default:()=>l,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"ingestion/supervisor","title":"Supervisor","description":"\x3c!--","source":"@site/docs/32.0.0/ingestion/supervisor.md","sourceDirName":"ingestion","slug":"/ingestion/supervisor","permalink":"/docs/32.0.0/ingestion/supervisor","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"supervisor","title":"Supervisor","sidebar_label":"Supervisor"},"sidebar":"docs","previous":{"title":"Streaming ingestion","permalink":"/docs/32.0.0/ingestion/streaming"},"next":{"title":"Apache Kafka ingestion","permalink":"/docs/32.0.0/ingestion/kafka-ingestion"}}');var n=i(74848),r=i(28453);const o={id:"supervisor",title:"Supervisor",sidebar_label:"Supervisor"},d=void 0,a={},c=[{value:"Supervisor spec",id:"supervisor-spec",level:2},{value:"I/O configuration",id:"io-configuration",level:3},{value:"Task autoscaler",id:"task-autoscaler",level:4},{value:"Autoscaler strategy",id:"autoscaler-strategy",level:5},{value:"Tuning configuration",id:"tuning-configuration",level:3},{value:"Start a supervisor",id:"start-a-supervisor",level:2},{value:"Schema and configuration changes",id:"schema-and-configuration-changes",level:3},{value:"Status report",id:"status-report",level:2},{value:"SUPERVISORS system table",id:"supervisors-system-table",level:2},{value:"Manage a supervisor",id:"manage-a-supervisor",level:2},{value:"Suspend",id:"suspend",level:3},{value:"Set offsets",id:"set-offsets",level:3},{value:"Hard reset",id:"hard-reset",level:3},{value:"Terminate",id:"terminate",level:3},{value:"Capacity planning",id:"capacity-planning",level:2},{value:"Learn more",id:"learn-more",level:2}];function h(e){const s={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",h5:"h5",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components},{Details:t}=s;return t||function(e,s){throw new Error("Expected "+(s?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(s.p,{children:["Apache Druid uses supervisors to manage streaming ingestion from external streaming sources into Druid.\nSupervisors oversee the state of indexing tasks to coordinate handoffs, manage failures, and ensure that the scalability and replication requirements are maintained. They can also be used to perform ",(0,n.jsx)(s.a,{href:"/docs/32.0.0/data-management/automatic-compaction",children:"automatic compaction"})," after data has been ingested."]}),"\n",(0,n.jsx)(s.p,{children:"This topic uses the Apache Kafka term offset to refer to the identifier for records in a partition. If you are using Amazon Kinesis, the equivalent is sequence number."}),"\n",(0,n.jsx)(s.h2,{id:"supervisor-spec",children:"Supervisor spec"}),"\n",(0,n.jsx)(s.p,{children:"Druid uses a JSON specification, often referred to as the supervisor spec, to define tasks used for streaming ingestion or auto-compaction.\nThe supervisor spec specifies how Druid should consume, process, and index data from an external stream or Druid itself."}),"\n",(0,n.jsx)(s.p,{children:"The following table outlines the high-level configuration options for a supervisor spec:"}),"\n",(0,n.jsxs)(s.table,{children:[(0,n.jsx)(s.thead,{children:(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.th,{children:"Property"}),(0,n.jsx)(s.th,{children:"Type"}),(0,n.jsx)(s.th,{children:"Description"}),(0,n.jsx)(s.th,{children:"Required"})]})}),(0,n.jsxs)(s.tbody,{children:[(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"type"})}),(0,n.jsx)(s.td,{children:"String"}),(0,n.jsxs)(s.td,{children:["The supervisor type. For streaming ingestion, this can be either ",(0,n.jsx)(s.code,{children:"kafka"}),", ",(0,n.jsx)(s.code,{children:"kinesis"}),", or ",(0,n.jsx)(s.code,{children:"rabbit"}),". For automatic compaction, set the type to ",(0,n.jsx)(s.code,{children:"autocompact"}),"."]}),(0,n.jsx)(s.td,{children:"Yes"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"spec"})}),(0,n.jsx)(s.td,{children:"Object"}),(0,n.jsx)(s.td,{children:"The container object for the supervisor configuration. For automatic compaction, this is the same as the compaction configuration."}),(0,n.jsx)(s.td,{children:"Yes"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"spec.dataSchema"})}),(0,n.jsx)(s.td,{children:"Object"}),(0,n.jsxs)(s.td,{children:["The schema for the indexing task to use during ingestion. See ",(0,n.jsx)(s.a,{href:"/docs/32.0.0/ingestion/ingestion-spec#dataschema",children:(0,n.jsx)(s.code,{children:"dataSchema"})})," for more information."]}),(0,n.jsx)(s.td,{children:"Yes"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"spec.ioConfig"})}),(0,n.jsx)(s.td,{children:"Object"}),(0,n.jsx)(s.td,{children:"The I/O configuration object to define the connection and I/O-related settings for the supervisor and indexing tasks."}),(0,n.jsx)(s.td,{children:"Yes"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"spec.tuningConfig"})}),(0,n.jsx)(s.td,{children:"Object"}),(0,n.jsx)(s.td,{children:"The tuning configuration object to define performance-related settings for the supervisor and indexing tasks."}),(0,n.jsx)(s.td,{children:"No"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"suspended"})}),(0,n.jsx)(s.td,{children:"Boolean"}),(0,n.jsx)(s.td,{children:"Puts the supervisor in a suspended state"}),(0,n.jsx)(s.td,{children:"No"})]})]})]}),"\n",(0,n.jsx)(s.h3,{id:"io-configuration",children:"I/O configuration"}),"\n",(0,n.jsxs)(s.p,{children:["The following table outlines the ",(0,n.jsx)(s.code,{children:"ioConfig"})," configuration properties that apply to both Apache Kafka and Amazon Kinesis ingestion methods.\nFor configuration properties specific to Kafka and Kinesis, see ",(0,n.jsx)(s.a,{href:"/docs/32.0.0/ingestion/kafka-ingestion#io-configuration",children:"Kafka I/O configuration"})," and ",(0,n.jsx)(s.a,{href:"/docs/32.0.0/ingestion/kinesis-ingestion#io-configuration",children:"Kinesis I/O configuration"})," respectively."]}),"\n",(0,n.jsxs)(s.table,{children:[(0,n.jsx)(s.thead,{children:(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.th,{children:"Property"}),(0,n.jsx)(s.th,{children:"Type"}),(0,n.jsx)(s.th,{children:"Description"}),(0,n.jsx)(s.th,{children:"Required"}),(0,n.jsx)(s.th,{children:"Default"})]})}),(0,n.jsxs)(s.tbody,{children:[(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"inputFormat"})}),(0,n.jsx)(s.td,{children:"Object"}),(0,n.jsxs)(s.td,{children:["The ",(0,n.jsx)(s.a,{href:"/docs/32.0.0/ingestion/data-formats#input-format",children:"input format"})," to define input data parsing."]}),(0,n.jsx)(s.td,{children:"Yes"}),(0,n.jsx)(s.td,{})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"autoScalerConfig"})}),(0,n.jsx)(s.td,{children:"Object"}),(0,n.jsxs)(s.td,{children:["Defines auto scaling behavior for ingestion tasks. See ",(0,n.jsx)(s.a,{href:"#task-autoscaler",children:"Task autoscaler"})," for more information."]}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:"null"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"taskCount"})}),(0,n.jsx)(s.td,{children:"Integer"}),(0,n.jsxs)(s.td,{children:["The maximum number of reading tasks in a replica set. Multiply ",(0,n.jsx)(s.code,{children:"taskCount"})," and replicas to measure the maximum number of reading tasks. The total number of tasks, reading and publishing, is higher than the maximum number of reading tasks. See ",(0,n.jsx)(s.a,{href:"/docs/32.0.0/ingestion/supervisor#capacity-planning",children:"Capacity planning"})," for more details. When ",(0,n.jsx)(s.code,{children:"taskCount"})," is greater than the number of Kafka partitions or Kinesis shards, the actual number of reading tasks is less than the ",(0,n.jsx)(s.code,{children:"taskCount"})," value."]}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:"1"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"replicas"})}),(0,n.jsx)(s.td,{children:"Integer"}),(0,n.jsx)(s.td,{children:"The number of replica sets, where 1 is a single set of tasks (no replication). Druid always assigns replicate tasks to different workers to provide resiliency against process failure."}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:"1"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"taskDuration"})}),(0,n.jsx)(s.td,{children:"ISO 8601 period"}),(0,n.jsx)(s.td,{children:"The length of time before tasks stop reading and begin publishing segments."}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"PT1H"})})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"startDelay"})}),(0,n.jsx)(s.td,{children:"ISO 8601 period"}),(0,n.jsx)(s.td,{children:"The period to wait before the supervisor starts managing tasks."}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"PT5S"})})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"period"})}),(0,n.jsx)(s.td,{children:"ISO 8601 period"}),(0,n.jsxs)(s.td,{children:["Determines how often the supervisor executes its management logic. Note that the supervisor also runs in response to certain events, such as tasks succeeding, failing, and reaching their task duration. The ",(0,n.jsx)(s.code,{children:"period"})," value specifies the maximum time between iterations."]}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"PT30S"})})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"completionTimeout"})}),(0,n.jsx)(s.td,{children:"ISO 8601 period"}),(0,n.jsxs)(s.td,{children:["The length of time to wait before declaring a publishing task as failed and terminating it. If the value is too low, tasks may never publish. The publishing clock for a task begins roughly after ",(0,n.jsx)(s.code,{children:"taskDuration"})," elapses."]}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"PT30M"})})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"lateMessageRejectionStartDateTime"})}),(0,n.jsx)(s.td,{children:"ISO 8601 date time"}),(0,n.jsxs)(s.td,{children:["Configures tasks to reject messages with timestamps earlier than this date time. For example, if this property is set to ",(0,n.jsx)(s.code,{children:"2016-01-01T11:00Z"})," and the supervisor creates a task at ",(0,n.jsx)(s.code,{children:"2016-01-01T12:00Z"}),", Druid drops messages with timestamps earlier than ",(0,n.jsx)(s.code,{children:"2016-01-01T11:00Z"}),". This can prevent concurrency issues if your data stream has late messages and you have multiple pipelines that need to operate on the same segments, such as a realtime and a nightly batch ingestion pipeline."]}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"lateMessageRejectionPeriod"})}),(0,n.jsx)(s.td,{children:"ISO 8601 period"}),(0,n.jsxs)(s.td,{children:["Configures tasks to reject messages with timestamps earlier than this period before the task was created. For example, if this property is set to ",(0,n.jsx)(s.code,{children:"PT1H"})," and the supervisor creates a task at ",(0,n.jsx)(s.code,{children:"2016-01-01T12:00Z"}),", Druid drops messages with timestamps earlier than ",(0,n.jsx)(s.code,{children:"2016-01-01T11:00Z"}),". This may help prevent concurrency issues if your data stream has late messages and you have multiple pipelines that need to operate on the same segments, such as a streaming and a nightly batch ingestion pipeline. You can specify only one of the late message rejection properties."]}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"earlyMessageRejectionPeriod"})}),(0,n.jsx)(s.td,{children:"ISO 8601 period"}),(0,n.jsxs)(s.td,{children:["Configures tasks to reject messages with timestamps later than this period after the task reached its task duration. For example, if this property is set to ",(0,n.jsx)(s.code,{children:"PT1H"}),", the task duration is set to ",(0,n.jsx)(s.code,{children:"PT1H"})," and the supervisor creates a task at ",(0,n.jsx)(s.code,{children:"2016-01-01T12:00Z"}),", Druid drops messages with timestamps later than ",(0,n.jsx)(s.code,{children:"2016-01-01T14:00Z"}),". Tasks sometimes run past their task duration, such as in cases of supervisor failover."]}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{})]})]})]}),"\n",(0,n.jsx)(s.h4,{id:"task-autoscaler",children:"Task autoscaler"}),"\n",(0,n.jsxs)(s.p,{children:["You can optionally configure autoscaling behavior for ingestion tasks using the ",(0,n.jsx)(s.code,{children:"autoScalerConfig"})," property of the ",(0,n.jsx)(s.code,{children:"ioConfig"})," object."]}),"\n",(0,n.jsxs)(s.p,{children:["The following table outlines the configuration properties for ",(0,n.jsx)(s.code,{children:"autoScalerConfig"}),":"]}),"\n",(0,n.jsxs)(s.table,{children:[(0,n.jsx)(s.thead,{children:(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.th,{children:"Property"}),(0,n.jsx)(s.th,{children:"Description"}),(0,n.jsx)(s.th,{children:"Required"}),(0,n.jsx)(s.th,{children:"Default"})]})}),(0,n.jsxs)(s.tbody,{children:[(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"enableTaskAutoScaler"})}),(0,n.jsxs)(s.td,{children:["Enables the autoscaler. If not specified, Druid disables the autoscaler even when ",(0,n.jsx)(s.code,{children:"autoScalerConfig"})," is not null."]}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"false"})})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"taskCountMax"})}),(0,n.jsxs)(s.td,{children:["The maximum number of ingestion tasks. Must be greater than or equal to ",(0,n.jsx)(s.code,{children:"taskCountMin"}),". If ",(0,n.jsx)(s.code,{children:"taskCountMax"})," is greater than the number of Kafka partitions or Kinesis shards, Druid sets the maximum number of reading tasks to the number of Kafka partitions or Kinesis shards and ignores ",(0,n.jsx)(s.code,{children:"taskCountMax"}),"."]}),(0,n.jsx)(s.td,{children:"Yes"}),(0,n.jsx)(s.td,{})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"taskCountMin"})}),(0,n.jsxs)(s.td,{children:["The minimum number of ingestion tasks. When you enable the autoscaler, Druid ignores the value of ",(0,n.jsx)(s.code,{children:"taskCount"})," in ",(0,n.jsx)(s.code,{children:"ioConfig"})," and starts with the ",(0,n.jsx)(s.code,{children:"taskCountMin"})," number of tasks to launch."]}),(0,n.jsx)(s.td,{children:"Yes"}),(0,n.jsx)(s.td,{})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"minTriggerScaleActionFrequencyMillis"})}),(0,n.jsx)(s.td,{children:"The minimum time interval between two scale actions."}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:"600000"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"autoScalerStrategy"})}),(0,n.jsxs)(s.td,{children:["The algorithm of autoscaler. Druid only supports the ",(0,n.jsx)(s.code,{children:"lagBased"})," strategy. See ",(0,n.jsx)(s.a,{href:"#autoscaler-strategy",children:"Autoscaler strategy"})," for more information."]}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"lagBased"})})]})]})]}),"\n",(0,n.jsx)(s.h5,{id:"autoscaler-strategy",children:"Autoscaler strategy"}),"\n",(0,n.jsx)(s.admonition,{type:"info",children:(0,n.jsx)(s.p,{children:"Unlike the Kafka indexing service, Kinesis reports lag metrics as the time difference in milliseconds between the current sequence number and the latest sequence number, rather than message count."})}),"\n",(0,n.jsxs)(s.p,{children:["The following table outlines the configuration properties related to the ",(0,n.jsx)(s.code,{children:"lagBased"})," autoscaler strategy:"]}),"\n",(0,n.jsxs)(s.table,{children:[(0,n.jsx)(s.thead,{children:(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.th,{children:"Property"}),(0,n.jsx)(s.th,{children:"Description"}),(0,n.jsx)(s.th,{children:"Required"}),(0,n.jsx)(s.th,{children:"Default"})]})}),(0,n.jsxs)(s.tbody,{children:[(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"lagCollectionIntervalMillis"})}),(0,n.jsx)(s.td,{children:"The time period during which Druid collects lag metric points."}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:"30000"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"lagCollectionRangeMillis"})}),(0,n.jsxs)(s.td,{children:["The total time window of lag collection. Use with ",(0,n.jsx)(s.code,{children:"lagCollectionIntervalMillis"})," to specify the intervals at which to collect lag metric points."]}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:"600000"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"scaleOutThreshold"})}),(0,n.jsx)(s.td,{children:"The threshold of scale out action."}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:"6000000"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"triggerScaleOutFractionThreshold"})}),(0,n.jsxs)(s.td,{children:["Enables scale out action if ",(0,n.jsx)(s.code,{children:"triggerScaleOutFractionThreshold"})," percent of lag points is higher than ",(0,n.jsx)(s.code,{children:"scaleOutThreshold"}),"."]}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:"0.3"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"scaleInThreshold"})}),(0,n.jsx)(s.td,{children:"The threshold of scale in action."}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:"1000000"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"triggerScaleInFractionThreshold"})}),(0,n.jsxs)(s.td,{children:["Enables scale in action if ",(0,n.jsx)(s.code,{children:"triggerScaleInFractionThreshold"})," percent of lag points is lower than ",(0,n.jsx)(s.code,{children:"scaleOutThreshold"}),"."]}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:"0.9"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"scaleActionStartDelayMillis"})}),(0,n.jsx)(s.td,{children:"The number of milliseconds to delay after the supervisor starts before the first scale logic check."}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:"300000"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"scaleActionPeriodMillis"})}),(0,n.jsx)(s.td,{children:"The frequency in milliseconds to check if a scale action is triggered."}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:"60000"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"scaleInStep"})}),(0,n.jsx)(s.td,{children:"The number of tasks to reduce at once when scaling down."}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:"1"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"scaleOutStep"})}),(0,n.jsx)(s.td,{children:"The number of tasks to add at once when scaling out."}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:"2"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"lagAggregate"})}),(0,n.jsxs)(s.td,{children:["The aggregate function used to compute the lag metric for scaling decisions. Possible values are ",(0,n.jsx)(s.code,{children:"MAX"}),", ",(0,n.jsx)(s.code,{children:"SUM"})," and ",(0,n.jsx)(s.code,{children:"AVERAGE"}),"."]}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"SUM"})})]})]})]}),"\n",(0,n.jsxs)(s.p,{children:["The following example shows a supervisor spec with ",(0,n.jsx)(s.code,{children:"lagBased"})," autoscaler:"]}),"\n",(0,n.jsxs)(t,{children:[(0,n.jsx)("summary",{children:"Click to view the example"}),(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-json",children:'{\n  "type": "kinesis",\n  "dataSchema": {\n    "dataSource": "metrics-kinesis",\n    "timestampSpec": {\n      "column": "timestamp",\n      "format": "auto"\n    },\n    "dimensionsSpec": {\n      "dimensions": [],\n      "dimensionExclusions": [\n        "timestamp",\n        "value"\n      ]\n    },\n    "metricsSpec": [\n      {\n        "name": "count",\n        "type": "count"\n      },\n      {\n        "name": "value_sum",\n        "fieldName": "value",\n        "type": "doubleSum"\n      },\n      {\n        "name": "value_min",\n        "fieldName": "value",\n        "type": "doubleMin"\n      },\n      {\n        "name": "value_max",\n        "fieldName": "value",\n        "type": "doubleMax"\n      }\n    ],\n    "granularitySpec": {\n      "type": "uniform",\n      "segmentGranularity": "HOUR",\n      "queryGranularity": "NONE"\n    }\n  },\n  "ioConfig": {\n    "stream": "metrics",\n    "autoScalerConfig": {\n      "enableTaskAutoScaler": true,\n      "taskCountMax": 6,\n      "taskCountMin": 2,\n      "minTriggerScaleActionFrequencyMillis": 600000,\n      "autoScalerStrategy": "lagBased",\n      "lagCollectionIntervalMillis": 30000,\n      "lagCollectionRangeMillis": 600000,\n      "scaleOutThreshold": 600000,\n      "triggerScaleOutFractionThreshold": 0.3,\n      "scaleInThreshold": 100000,\n      "triggerScaleInFractionThreshold": 0.9,\n      "scaleActionStartDelayMillis": 300000,\n      "scaleActionPeriodMillis": 60000,\n      "scaleInStep": 1,\n      "scaleOutStep": 2\n    },\n    "inputFormat": {\n      "type": "json"\n    },\n    "endpoint": "kinesis.us-east-1.amazonaws.com",\n    "taskCount": 1,\n    "replicas": 1,\n    "taskDuration": "PT1H"\n  },\n  "tuningConfig": {\n    "type": "kinesis",\n    "maxRowsPerSegment": 5000000\n  }\n}\n'})})]}),"\n",(0,n.jsx)(s.h3,{id:"tuning-configuration",children:"Tuning configuration"}),"\n",(0,n.jsxs)(s.p,{children:["The ",(0,n.jsx)(s.code,{children:"tuningConfig"})," object is optional. If you don't specify the ",(0,n.jsx)(s.code,{children:"tuningConfig"})," object, Druid uses the default configuration settings."]}),"\n",(0,n.jsxs)(s.p,{children:["The following table outlines the ",(0,n.jsx)(s.code,{children:"tuningConfig"})," configuration properties that apply to both Kafka and Kinesis ingestion methods.\nFor configuration properties specific to Kafka and Kinesis, see ",(0,n.jsx)(s.a,{href:"/docs/32.0.0/ingestion/kafka-ingestion#tuning-configuration",children:"Kafka tuning configuration"})," and ",(0,n.jsx)(s.a,{href:"/docs/32.0.0/ingestion/kinesis-ingestion#tuning-configuration",children:"Kinesis tuning configuration"})," respectively."]}),"\n",(0,n.jsxs)(s.table,{children:[(0,n.jsx)(s.thead,{children:(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.th,{children:"Property"}),(0,n.jsx)(s.th,{children:"Type"}),(0,n.jsx)(s.th,{children:"Description"}),(0,n.jsx)(s.th,{children:"Required"}),(0,n.jsx)(s.th,{children:"Default"})]})}),(0,n.jsxs)(s.tbody,{children:[(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"type"})}),(0,n.jsx)(s.td,{children:"String"}),(0,n.jsxs)(s.td,{children:["The tuning type code for the ingestion method. One of ",(0,n.jsx)(s.code,{children:"kafka"})," or ",(0,n.jsx)(s.code,{children:"kinesis"}),"."]}),(0,n.jsx)(s.td,{children:"Yes"}),(0,n.jsx)(s.td,{})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"maxRowsInMemory"})}),(0,n.jsx)(s.td,{children:"Integer"}),(0,n.jsxs)(s.td,{children:["The number of rows to accumulate before persisting. This number represents the post-aggregation rows. It is not equivalent to the number of input events, but the resulting number of aggregated rows. Druid uses ",(0,n.jsx)(s.code,{children:"maxRowsInMemory"})," to manage the required JVM heap size. The maximum heap memory usage for indexing scales is ",(0,n.jsx)(s.code,{children:"maxRowsInMemory * (2 + maxPendingPersists)"}),". Normally, you don't need to set this, but depending on the nature of data, if rows are short in terms of bytes, you may not want to store a million rows in memory and this value should be set."]}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:"150000"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"maxBytesInMemory"})}),(0,n.jsx)(s.td,{children:"Long"}),(0,n.jsxs)(s.td,{children:["The number of bytes to accumulate in heap memory before persisting. The value is based on a rough estimate of memory usage and not actual usage. Normally, Druid computes the value internally. The maximum heap memory usage for indexing is ",(0,n.jsx)(s.code,{children:"maxBytesInMemory * (2 + maxPendingPersists)"}),"."]}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:"One-sixth of max JVM memory"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"skipBytesInMemoryOverheadCheck"})}),(0,n.jsx)(s.td,{children:"Boolean"}),(0,n.jsxs)(s.td,{children:["The calculation of ",(0,n.jsx)(s.code,{children:"maxBytesInMemory"})," takes into account overhead objects created during ingestion and each intermediate persist. To exclude the bytes of these overhead objects from the ",(0,n.jsx)(s.code,{children:"maxBytesInMemory"})," check, set ",(0,n.jsx)(s.code,{children:"skipBytesInMemoryOverheadCheck"})," to ",(0,n.jsx)(s.code,{children:"true"}),"."]}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"false"})})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"maxRowsPerSegment"})}),(0,n.jsx)(s.td,{children:"Integer"}),(0,n.jsxs)(s.td,{children:["The number of rows to store in a segment. This number is post-aggregation rows. Handoff occurs when ",(0,n.jsx)(s.code,{children:"maxRowsPerSegment"})," or ",(0,n.jsx)(s.code,{children:"maxTotalRows"})," is reached or every ",(0,n.jsx)(s.code,{children:"intermediateHandoffPeriod"}),", whichever happens first."]}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:"5000000"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"maxTotalRows"})}),(0,n.jsx)(s.td,{children:"Long"}),(0,n.jsxs)(s.td,{children:["The number of rows to aggregate across all segments; this number is post-aggregation rows. Handoff happens either if ",(0,n.jsx)(s.code,{children:"maxRowsPerSegment"})," or ",(0,n.jsx)(s.code,{children:"maxTotalRows"})," is reached or every ",(0,n.jsx)(s.code,{children:"intermediateHandoffPeriod"}),", whichever happens earlier."]}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:"20000000"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"intermediateHandoffPeriod"})}),(0,n.jsx)(s.td,{children:"ISO 8601 period"}),(0,n.jsxs)(s.td,{children:["The period that determines how often tasks hand off segments. Handoff occurs if ",(0,n.jsx)(s.code,{children:"maxRowsPerSegment"})," or ",(0,n.jsx)(s.code,{children:"maxTotalRows"})," is reached or every ",(0,n.jsx)(s.code,{children:"intermediateHandoffPeriod"}),", whichever happens first."]}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"P2147483647D"})})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"intermediatePersistPeriod"})}),(0,n.jsx)(s.td,{children:"ISO 8601 period"}),(0,n.jsx)(s.td,{children:"The period that determines the rate at which intermediate persists occur."}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"PT10M"})})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"maxPendingPersists"})}),(0,n.jsx)(s.td,{children:"Integer"}),(0,n.jsxs)(s.td,{children:["Maximum number of persists that can be pending but not started. If a new intermediate persist exceeds this limit, Druid blocks ingestion until the currently running persist finishes. One persist can be running concurrently with ingestion, and none can be queued up. The maximum heap memory usage for indexing scales is ",(0,n.jsx)(s.code,{children:"maxRowsInMemory * (2 + maxPendingPersists)"}),"."]}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:"0"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"indexSpec"})}),(0,n.jsx)(s.td,{children:"Object"}),(0,n.jsxs)(s.td,{children:["Defines segment storage format options to use at indexing time. See ",(0,n.jsx)(s.a,{href:"/docs/32.0.0/ingestion/ingestion-spec#indexspec",children:"IndexSpec"})," for more information."]}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"indexSpecForIntermediatePersists"})}),(0,n.jsx)(s.td,{children:"Object"}),(0,n.jsxs)(s.td,{children:["Defines segment storage format options to use at indexing time for intermediate persisted temporary segments. You can use ",(0,n.jsx)(s.code,{children:"indexSpecForIntermediatePersists"})," to disable dimension/metric compression on intermediate segments to reduce memory required for final merging. However, disabling compression on intermediate segments might increase page cache use while they are used before getting merged into final segment published."]}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"reportParseExceptions"})}),(0,n.jsx)(s.td,{children:"Boolean"}),(0,n.jsxs)(s.td,{children:["DEPRECATED. If ",(0,n.jsx)(s.code,{children:"true"}),", Druid throws exceptions encountered during parsing causing ingestion to halt. If ",(0,n.jsx)(s.code,{children:"false"}),", Druid skips unparseable rows and fields. Setting ",(0,n.jsx)(s.code,{children:"reportParseExceptions"})," to ",(0,n.jsx)(s.code,{children:"true"})," overrides existing configurations for ",(0,n.jsx)(s.code,{children:"maxParseExceptions"})," and ",(0,n.jsx)(s.code,{children:"maxSavedParseExceptions"}),", setting ",(0,n.jsx)(s.code,{children:"maxParseExceptions"})," to 0 and limiting ",(0,n.jsx)(s.code,{children:"maxSavedParseExceptions"})," to not more than 1."]}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"false"})})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"handoffConditionTimeout"})}),(0,n.jsx)(s.td,{children:"Long"}),(0,n.jsx)(s.td,{children:"Number of milliseconds to wait for segment handoff. Set to a value >= 0, where 0 means to wait indefinitely."}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:"900000 (15 minutes) for Kafka. 0 for Kinesis."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"resetOffsetAutomatically"})}),(0,n.jsx)(s.td,{children:"Boolean"}),(0,n.jsxs)(s.td,{children:["Resets partitions when the offset is unavailable. If set to ",(0,n.jsx)(s.code,{children:"true"}),", Druid resets partitions to the earliest or latest offset, based on the value of ",(0,n.jsx)(s.code,{children:"useEarliestOffset"})," or ",(0,n.jsx)(s.code,{children:"useEarliestSequenceNumber"})," (earliest if ",(0,n.jsx)(s.code,{children:"true"}),", latest if ",(0,n.jsx)(s.code,{children:"false"}),"). If set to ",(0,n.jsx)(s.code,{children:"false"}),", Druid surfaces the exception causing tasks to fail and ingestion to halt. If this occurs, manual intervention is required to correct the situation, potentially through ",(0,n.jsx)(s.a,{href:"/docs/32.0.0/api-reference/supervisor-api#reset-a-supervisor",children:"resetting the supervisor"}),"."]}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"false"})})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"workerThreads"})}),(0,n.jsx)(s.td,{children:"Integer"}),(0,n.jsx)(s.td,{children:"The number of threads that the supervisor uses to handle requests/responses for worker tasks, along with any other internal asynchronous operation."}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"min(10, taskCount)"})})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"chatRetries"})}),(0,n.jsx)(s.td,{children:"Integer"}),(0,n.jsx)(s.td,{children:"The number of times Druid retries HTTP requests to indexing tasks before considering tasks unresponsive."}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:"8"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"httpTimeout"})}),(0,n.jsx)(s.td,{children:"ISO 8601 period"}),(0,n.jsx)(s.td,{children:"The period of time to wait for a HTTP response from an indexing task."}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"PT10S"})})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"shutdownTimeout"})}),(0,n.jsx)(s.td,{children:"ISO 8601 period"}),(0,n.jsx)(s.td,{children:"The period of time to wait for the supervisor to attempt a graceful shutdown of tasks before exiting."}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"PT80S"})})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"offsetFetchPeriod"})}),(0,n.jsx)(s.td,{children:"ISO 8601 period"}),(0,n.jsxs)(s.td,{children:["Determines how often the supervisor queries the streaming source and the indexing tasks to fetch current offsets and calculate lag. If the user-specified value is below the minimum value of ",(0,n.jsx)(s.code,{children:"PT5S"}),", the supervisor ignores the value and uses the minimum value instead."]}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"PT30S"})})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"segmentWriteOutMediumFactory"})}),(0,n.jsx)(s.td,{children:"Object"}),(0,n.jsxs)(s.td,{children:["The segment write-out medium to use when creating segments. See ",(0,n.jsx)(s.a,{href:"/docs/32.0.0/configuration/#segmentwriteoutmediumfactory",children:"Additional Peon configuration: SegmentWriteOutMediumFactory"})," for explanation and available options."]}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsxs)(s.td,{children:["If not specified, Druid uses the value from ",(0,n.jsx)(s.code,{children:"druid.peon.defaultSegmentWriteOutMediumFactory.type"}),"."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"logParseExceptions"})}),(0,n.jsx)(s.td,{children:"Boolean"}),(0,n.jsxs)(s.td,{children:["If ",(0,n.jsx)(s.code,{children:"true"}),", Druid logs an error message when a parsing exception occurs, containing information about the row where the error occurred."]}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"false"})})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"maxParseExceptions"})}),(0,n.jsx)(s.td,{children:"Integer"}),(0,n.jsxs)(s.td,{children:["The maximum number of parse exceptions that can occur before the task halts ingestion and fails. Setting ",(0,n.jsx)(s.code,{children:"reportParseExceptions"})," overrides this limit."]}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:"unlimited"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"maxSavedParseExceptions"})}),(0,n.jsx)(s.td,{children:"Integer"}),(0,n.jsxs)(s.td,{children:["When a parse exception occurs, Druid keeps track of the most recent parse exceptions. ",(0,n.jsx)(s.code,{children:"maxSavedParseExceptions"})," limits the number of saved exception instances. These saved exceptions are available after the task finishes in the ",(0,n.jsx)(s.a,{href:"/docs/32.0.0/ingestion/tasks#task-reports",children:"task completion report"}),". Setting ",(0,n.jsx)(s.code,{children:"reportParseExceptions"})," overrides this limit."]}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:"0"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"maxColumnsToMerge"})}),(0,n.jsx)(s.td,{children:"Integer"}),(0,n.jsx)(s.td,{children:"Limit of the number of segments to merge in a single phase when merging segments for publishing. This limit affects the total number of columns present in a set of segments to merge. If the limit is exceeded, segment merging occurs in multiple phases. Druid merges at least 2 segments per phase, regardless of this setting."}),(0,n.jsx)(s.td,{children:"No"}),(0,n.jsx)(s.td,{children:"-1"})]})]})]}),"\n",(0,n.jsx)(s.h2,{id:"start-a-supervisor",children:"Start a supervisor"}),"\n",(0,n.jsxs)(s.p,{children:["Druid starts a new supervisor when you submit a supervisor spec.\nYou can submit the supervisor spec in the Druid web console ",(0,n.jsx)(s.a,{href:"/docs/32.0.0/operations/web-console#data-loader",children:"data loader"})," or with the ",(0,n.jsx)(s.a,{href:"/docs/32.0.0/api-reference/supervisor-api",children:"Supervisor API"}),"."]}),"\n",(0,n.jsxs)(s.p,{children:["The following screenshot shows the ",(0,n.jsx)(s.a,{href:"/docs/32.0.0/operations/web-console#supervisors",children:"Supervisors"})," view of the web console for a cluster with two supervisors:"]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{alt:"Supervisors view",src:i(38662).A+"",width:"1250",height:"640"})}),"\n",(0,n.jsx)(s.p,{children:"Once started, the supervisor persists in the configured metadata database. There can only be one supervisor per datasource. Submitting a second supervisor spec for the same datasource overwrites the previous one."}),"\n",(0,n.jsx)(s.p,{children:"When an Overlord gains leadership, either by being started or as a result of another Overlord failing, it spawns a supervisor for each supervisor spec in the metadata database. The supervisor then discovers running indexing tasks and attempts to adopt them if they are compatible with the supervisor's configuration. If they are not compatible, the tasks are terminated and the supervisor creates a new set of tasks. This way, the supervisor ingestion tasks persist across Overlord restarts and failovers."}),"\n",(0,n.jsx)(s.h3,{id:"schema-and-configuration-changes",children:"Schema and configuration changes"}),"\n",(0,n.jsx)(s.p,{children:"To make schema or configuration changes, you must submit a new supervisor spec. The Overlord initiates a graceful shutdown of the existing supervisor. The running supervisor signals its tasks to stop reading and begin publishing, exiting itself. Druid then uses the new configuration to create a new supervisor. Druid submits the updated schema while retaining existing publishing tasks. It also starts new tasks at the previous task offsets.\nThis way, configuration changes can be applied without requiring any pause in ingestion."}),"\n",(0,n.jsx)(s.h2,{id:"status-report",children:"Status report"}),"\n",(0,n.jsxs)(s.p,{children:["The supervisor status report contains the state of the supervisor tasks and an array of recently thrown exceptions reported as ",(0,n.jsx)(s.code,{children:"recentErrors"}),".\nYou can control the maximum size of the exceptions using the ",(0,n.jsx)(s.code,{children:"druid.supervisor.maxStoredExceptionEvents"})," configuration."]}),"\n",(0,n.jsxs)(s.p,{children:["To view the supervisor status in the web console, navigate to the ",(0,n.jsx)(s.strong,{children:"Supervisors"})," view and click the supervisor ID to open the ",(0,n.jsx)(s.strong,{children:"Supervisor"})," dialog.\nClick ",(0,n.jsx)(s.strong,{children:"Status"})," in the left navigation pane to display the status:"]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{alt:"Supervisors info dialog",src:i(98668).A+"",width:"1250",height:"640"})}),"\n",(0,n.jsxs)(s.p,{children:["The following example shows the status of a supervisor with the name ",(0,n.jsx)(s.code,{children:"social_media"}),":"]}),"\n",(0,n.jsxs)(t,{children:[(0,n.jsx)("summary",{children:"Click to view the example"}),(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-json",children:'{\n  "dataSource": "social_media",\n  "stream": "social_media",\n  "partitions": 1,\n  "replicas": 1,\n  "durationSeconds": 3600,\n  "activeTasks": [\n    {\n      "id": "index_kafka_social_media_8ff3096f21fe448_jajnddno",\n      "startingOffsets": {\n        "0": 0\n      },\n      "startTime": "2024-01-30T21:21:41.696Z",\n      "remainingSeconds": 479,\n      "type": "ACTIVE",\n      "currentOffsets": {\n        "0": 50000\n      },\n      "lag": {\n        "0": 0\n      }\n    }\n  ],\n  "publishingTasks": [],\n  "latestOffsets": {\n    "0": 50000\n  },\n  "minimumLag": {\n    "0": 0\n  },\n  "aggregateLag": 0,\n  "offsetsLastUpdated": "2024-01-30T22:13:19.335Z",\n  "suspended": false,\n  "healthy": true,\n  "state": "RUNNING",\n  "detailedState": "RUNNING",\n  "recentErrors": []\n}\n'})})]}),"\n",(0,n.jsxs)(s.p,{children:["The status report contains two properties that correspond to the state of the supervisor: ",(0,n.jsx)(s.code,{children:"state"})," and ",(0,n.jsx)(s.code,{children:"detailedState"}),". The ",(0,n.jsx)(s.code,{children:"state"})," property contains a small number of generic states that apply to any type of supervisor. The ",(0,n.jsx)(s.code,{children:"detailedState"})," property contains a more descriptive, implementation-specific state that may provide more insight into the supervisor's activities."]}),"\n",(0,n.jsxs)(s.p,{children:["Possible ",(0,n.jsx)(s.code,{children:"state"})," values are ",(0,n.jsx)(s.code,{children:"PENDING"}),", ",(0,n.jsx)(s.code,{children:"RUNNING"}),", ",(0,n.jsx)(s.code,{children:"SUSPENDED"}),", ",(0,n.jsx)(s.code,{children:"STOPPING"}),", ",(0,n.jsx)(s.code,{children:"UNHEALTHY_SUPERVISOR"}),", and ",(0,n.jsx)(s.code,{children:"UNHEALTHY_TASKS"}),"."]}),"\n",(0,n.jsxs)(s.p,{children:["The following table lists ",(0,n.jsx)(s.code,{children:"detailedState"})," values and their corresponding ",(0,n.jsx)(s.code,{children:"state"})," mapping:"]}),"\n",(0,n.jsxs)(s.table,{children:[(0,n.jsx)(s.thead,{children:(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.th,{children:(0,n.jsx)(s.code,{children:"detailedState"})}),(0,n.jsx)(s.th,{children:(0,n.jsx)(s.code,{children:"state"})}),(0,n.jsx)(s.th,{children:"Description"})]})}),(0,n.jsxs)(s.tbody,{children:[(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"UNHEALTHY_SUPERVISOR"})}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"UNHEALTHY_SUPERVISOR"})}),(0,n.jsxs)(s.td,{children:["The supervisor encountered errors on previous ",(0,n.jsx)(s.code,{children:"druid.supervisor.unhealthinessThreshold"})," iterations."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"UNHEALTHY_TASKS"})}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"UNHEALTHY_TASKS"})}),(0,n.jsxs)(s.td,{children:["The last ",(0,n.jsx)(s.code,{children:"druid.supervisor.taskUnhealthinessThreshold"})," tasks all failed."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"UNABLE_TO_CONNECT_TO_STREAM"})}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"UNHEALTHY_SUPERVISOR"})}),(0,n.jsx)(s.td,{children:"The supervisor is encountering connectivity issues with the stream and hasn't successfully connected in the past."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"LOST_CONTACT_WITH_STREAM"})}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"UNHEALTHY_SUPERVISOR"})}),(0,n.jsx)(s.td,{children:"The supervisor is encountering connectivity issues with the stream but has successfully connected in the past."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.code,{children:"PENDING"})," (first iteration only)"]}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"PENDING"})}),(0,n.jsx)(s.td,{children:"The supervisor has been initialized but hasn't started connecting to the stream."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.code,{children:"CONNECTING_TO_STREAM"})," (first iteration only)"]}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"RUNNING"})}),(0,n.jsx)(s.td,{children:"The supervisor is trying to connect to the stream and update partition data."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.code,{children:"DISCOVERING_INITIAL_TASKS"})," (first iteration only)"]}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"RUNNING"})}),(0,n.jsx)(s.td,{children:"The supervisor is discovering already-running tasks."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.code,{children:"CREATING_TASKS"})," (first iteration only)"]}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"RUNNING"})}),(0,n.jsx)(s.td,{children:"The supervisor is creating tasks and discovering state."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"RUNNING"})}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"RUNNING"})}),(0,n.jsxs)(s.td,{children:["The supervisor has started tasks and is waiting for ",(0,n.jsx)(s.code,{children:"taskDuration"})," to elapse."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"IDLE"})}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"IDLE"})}),(0,n.jsx)(s.td,{children:"The supervisor is not creating tasks since the input stream has not received any new data and all the existing data is read."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"SUSPENDED"})}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"SUSPENDED"})}),(0,n.jsx)(s.td,{children:"The supervisor is suspended."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"STOPPING"})}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"STOPPING"})}),(0,n.jsx)(s.td,{children:"The supervisor is stopping."})]})]})]}),"\n",(0,n.jsx)(s.p,{children:"On each iteration of the supervisor's run loop, the supervisor completes the following tasks in sequence:"}),"\n",(0,n.jsxs)(s.ol,{children:["\n",(0,n.jsxs)(s.li,{children:["Retrieve the list of partitions and determine the starting offset for each partition. If continuing, Druid uses the last processed offset. For new streams, Druid starts from either the beginning or end of the stream, depending on the ",(0,n.jsx)(s.code,{children:"useEarliestOffset"})," property."]}),"\n",(0,n.jsx)(s.li,{children:"Discover any running indexing tasks that are writing to the supervisor's datasource and adopt them if they match the supervisor's configuration, else signal them to stop."}),"\n",(0,n.jsx)(s.li,{children:"Send a status request to each supervised task to update the view of the state of the tasks under supervision."}),"\n",(0,n.jsxs)(s.li,{children:["Handle tasks that have exceeded ",(0,n.jsx)(s.code,{children:"taskDuration"})," and should transition from reading to publishing."]}),"\n",(0,n.jsx)(s.li,{children:"Handle tasks that have finished publishing and signal redundant replica tasks to stop."}),"\n",(0,n.jsx)(s.li,{children:"Handle tasks that have failed and clean up the supervisor's internal state."}),"\n",(0,n.jsxs)(s.li,{children:["Compare the list of healthy tasks to the requested ",(0,n.jsx)(s.code,{children:"taskCount"})," and ",(0,n.jsx)(s.code,{children:"replicas"})," configurations and create additional tasks if required."]}),"\n"]}),"\n",(0,n.jsxs)(s.p,{children:["The ",(0,n.jsx)(s.code,{children:"detailedState"})," property shows additional values (marked with \"first iteration only\" in the preceding table) the first time the\nsupervisor executes this run loop after startup or after resuming from a suspension. This is intended to surface\ninitialization-type issues, where the supervisor is unable to reach a stable state. For example, if the supervisor can't connect to\nthe stream, if it's unable to read from the stream, or if it can't communicate with existing tasks. Once the supervisor is stable;\nthat is, once it has completed a full execution without encountering any issues, ",(0,n.jsx)(s.code,{children:"detailedState"})," will show a ",(0,n.jsx)(s.code,{children:"RUNNING"}),"\nstate until it is stopped, suspended, or hits a failure threshold and transitions to an unhealthy state."]}),"\n",(0,n.jsx)(s.admonition,{type:"info",children:(0,n.jsx)(s.p,{children:"For the Kafka indexing service, Druid may report the consumer lag per partition as a negative value if the supervisor hasn't received the latest offset response from Kafka. The aggregate lag value is always >= 0."})}),"\n",(0,n.jsx)(s.h2,{id:"supervisors-system-table",children:"SUPERVISORS system table"}),"\n",(0,n.jsxs)(s.p,{children:["Druid exposes system information through special system schemas. You can query the ",(0,n.jsx)(s.code,{children:"sys.supervisors"})," table to retrieve information about the supervisor internals.\nThe following example shows how to retrieve supervisor tasks information filtered by health status:"]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-sql",children:"SELECT * FROM sys.supervisors WHERE healthy=0;\n"})}),"\n",(0,n.jsxs)(s.p,{children:["For more information on the supervisors system table, see ",(0,n.jsx)(s.a,{href:"/docs/32.0.0/querying/sql-metadata-tables#supervisors-table",children:"SUPERVISORS table"}),"."]}),"\n",(0,n.jsx)(s.h2,{id:"manage-a-supervisor",children:"Manage a supervisor"}),"\n",(0,n.jsxs)(s.p,{children:["You can manage a supervisor from the web console or with the ",(0,n.jsx)(s.a,{href:"/docs/32.0.0/api-reference/supervisor-api",children:"Supervisor API"}),".\nIn the web console, navigate to the ",(0,n.jsx)(s.strong,{children:"Supervisors"})," view and click the ellipsis in the ",(0,n.jsx)(s.strong,{children:"Actions"})," column. Select the desired action from the menu that appears."]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{alt:"Actions menu",src:i(6620).A+"",width:"1250",height:"640"})}),"\n",(0,n.jsx)(s.p,{children:"The supervisor must be running for some of these actions to be available."}),"\n",(0,n.jsx)(s.h3,{id:"suspend",children:"Suspend"}),"\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.strong,{children:"Suspend"})," pauses a running supervisor.\nThe suspended supervisor continues to emit logs and metrics.\nIndexing tasks remain suspended until you resume the supervisor.\nFor information on how to suspend a supervisor by API, see ",(0,n.jsx)(s.a,{href:"/docs/32.0.0/api-reference/supervisor-api#suspend-a-running-supervisor",children:"Supervisors: Suspend a running supervisor"}),"."]}),"\n",(0,n.jsx)(s.h3,{id:"set-offsets",children:"Set offsets"}),"\n",(0,n.jsx)(s.admonition,{type:"info",children:(0,n.jsx)(s.p,{children:"Perform this action with caution as it may result in skipped messages and lead to data loss or duplicate data."})}),"\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.strong,{children:"Set offsets"})," resets the offsets for supervisor partitions.\nThis action clears the stored offsets and instructs the supervisor to resume reading data from the specified offsets. If there are no stored offsets, Druid saves the specified offsets in the metadata store.\n",(0,n.jsx)(s.strong,{children:"Set offsets"})," terminates and recreates active tasks for the specified partitions to begin reading from the reset offsets.\nFor partitions not specified in this operation, the supervisor resumes from the last stored offset."]}),"\n",(0,n.jsxs)(s.p,{children:["For information on how to reset offsets by API, see ",(0,n.jsx)(s.a,{href:"/docs/32.0.0/api-reference/supervisor-api#reset-offsets-for-a-supervisor",children:"Supervisors: Reset offsets for a supervisor"}),"."]}),"\n",(0,n.jsx)(s.h3,{id:"hard-reset",children:"Hard reset"}),"\n",(0,n.jsx)(s.admonition,{type:"info",children:(0,n.jsx)(s.p,{children:"Perform this action with caution as it may result in skipped messages and lead to data loss or duplicate data."})}),"\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.strong,{children:"Hard reset"})," clears supervisor metadata, causing the supervisor to resume data reading from either the earliest or latest available position, depending on the ",(0,n.jsx)(s.code,{children:"useEarliestOffset"})," setting. ",(0,n.jsx)(s.strong,{children:"Hard reset"})," terminates and recreates active tasks, so that tasks begin reading from valid positions."]}),"\n",(0,n.jsx)(s.p,{children:"Use this action to recover from a stopped state due to missing offsets."}),"\n",(0,n.jsxs)(s.p,{children:["For information on how to reset a supervisor by API, see ",(0,n.jsx)(s.a,{href:"/docs/32.0.0/api-reference/supervisor-api#reset-a-supervisor",children:"Supervisors: Reset a supervisor"}),"."]}),"\n",(0,n.jsx)(s.h3,{id:"terminate",children:"Terminate"}),"\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.strong,{children:"Terminate"})," stops a supervisor and its indexing tasks, triggering the publishing of their segments. When you terminate a supervisor, Druid places a tombstone marker in the metadata store to prevent reloading on restart.\nThe terminated supervisor still exists in the metadata store and its history can be retrieved."]}),"\n",(0,n.jsxs)(s.p,{children:["For information on how to terminate a supervisor by API, see ",(0,n.jsx)(s.a,{href:"/docs/32.0.0/api-reference/supervisor-api#terminate-a-supervisor",children:"Supervisors: Terminate a supervisor"}),"."]}),"\n",(0,n.jsx)(s.h2,{id:"capacity-planning",children:"Capacity planning"}),"\n",(0,n.jsxs)(s.p,{children:["Indexing tasks run on Middle Managers and are limited by the resources available in the Middle Manager cluster. In particular, you should make sure that you have sufficient worker capacity, configured using the\n",(0,n.jsx)(s.code,{children:"druid.worker.capacity"})," property, to handle the configuration in the supervisor spec. Note that worker capacity is\nshared across all types of indexing tasks, so you should plan your worker capacity to handle your total indexing load, such as batch processing, streaming tasks, and merging tasks. If your workers run out of capacity, indexing tasks queue and wait for the next available worker. This may cause queries to return partial results but will not result in data loss, assuming the tasks run before the stream purges those offsets."]}),"\n",(0,n.jsxs)(s.p,{children:["A running task can be in one of two states: reading or publishing. A task remains in reading state for the period defined in ",(0,n.jsx)(s.code,{children:"taskDuration"}),", at which point it transitions to publishing state. A task remains in publishing state for as long as it takes to generate segments, push segments to deep storage, and have them loaded and served by a Historical service or until ",(0,n.jsx)(s.code,{children:"completionTimeout"})," elapses."]}),"\n",(0,n.jsxs)(s.p,{children:["The number of reading tasks is controlled by ",(0,n.jsx)(s.code,{children:"replicas"})," and ",(0,n.jsx)(s.code,{children:"taskCount"}),". In general, there are ",(0,n.jsx)(s.code,{children:"replicas * taskCount"})," reading tasks. An exception occurs if ",(0,n.jsx)(s.code,{children:"taskCount"})," is over the number of shards in Kinesis or partitions in Kafka, in which case Druid uses the number of shards or partitions. When ",(0,n.jsx)(s.code,{children:"taskDuration"})," elapses, these tasks transition to publishing state and ",(0,n.jsx)(s.code,{children:"replicas * taskCount"})," new reading tasks are created. To allow for reading tasks and publishing tasks to run concurrently, there should be a minimum capacity of:"]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-text",children:"workerCapacity = 2 * replicas * taskCount\n"})}),"\n",(0,n.jsxs)(s.p,{children:["This value is for the ideal situation in which there is at most one set of tasks publishing while another set is reading.\nIn some circumstances, it is possible to have multiple sets of tasks publishing simultaneously. This would happen if the\ntime-to-publish (generate segment, push to deep storage, load on Historical) is greater than ",(0,n.jsx)(s.code,{children:"taskDuration"}),". This is a valid and correct scenario but requires additional worker capacity to support. In general, it is a good idea to have ",(0,n.jsx)(s.code,{children:"taskDuration"})," be large enough that the previous set of tasks finishes publishing before the current set begins."]}),"\n",(0,n.jsx)(s.h2,{id:"learn-more",children:"Learn more"}),"\n",(0,n.jsx)(s.p,{children:"See the following topics for more information:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.a,{href:"/docs/32.0.0/api-reference/supervisor-api",children:"Supervisor API"})," for how to manage and monitor supervisors using the API."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.a,{href:"/docs/32.0.0/ingestion/kafka-ingestion",children:"Apache Kafka ingestion"})," to learn about ingesting data from an Apache Kafka stream."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.a,{href:"/docs/32.0.0/ingestion/kinesis-ingestion",children:"Amazon Kinesis ingestion"})," to learn about ingesting data from an Amazon Kinesis stream."]}),"\n"]})]})}function l(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},98668:(e,s,i)=>{i.d(s,{A:()=>t});const t=i.p+"assets/images/supervisor-info-dialog-300a1e58533b10622fd945eca74911e4.png"}}]);