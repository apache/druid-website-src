"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4579],{28453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>t});var a=r(96540);const i={},s=a.createContext(i);function l(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),a.createElement(s.Provider,{value:n},e.children)}},55805:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>t,default:()=>d,frontMatter:()=>l,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"querying/having","title":"Having filters (groupBy)","description":"\x3c!--","source":"@site/docs/33.0.0/querying/having.md","sourceDirName":"querying","slug":"/querying/having","permalink":"/docs/33.0.0/querying/having","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"having","title":"Having filters (groupBy)"},"sidebar":"docs","previous":{"title":"Expressions","permalink":"/docs/33.0.0/querying/math-expr"},"next":{"title":"Sorting and limiting (groupBy)","permalink":"/docs/33.0.0/querying/limitspec"}}');var i=r(74848),s=r(28453);const l={id:"having",title:"Having filters (groupBy)"},t=void 0,o={},c=[{value:"Query filters",id:"query-filters",level:3},{value:"Numeric filters",id:"numeric-filters",level:3},{value:"Equal To",id:"equal-to",level:4},{value:"Greater Than",id:"greater-than",level:4},{value:"Less Than",id:"less-than",level:4},{value:"Dimension Selector Filter",id:"dimension-selector-filter",level:3},{value:"dimSelector",id:"dimselector",level:4},{value:"Logical expression filters",id:"logical-expression-filters",level:3},{value:"AND",id:"and",level:4},{value:"OR",id:"or",level:4},{value:"NOT",id:"not",level:4}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h3:"h3",h4:"h4",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["Apache Druid supports two query languages: ",(0,i.jsx)(n.a,{href:"/docs/33.0.0/querying/sql",children:"Druid SQL"})," and ",(0,i.jsx)(n.a,{href:"/docs/33.0.0/querying/",children:"native queries"}),".\nThis document describes the native\nlanguage. For information about functions available in SQL, refer to the\n",(0,i.jsx)(n.a,{href:"/docs/33.0.0/querying/sql-scalar",children:"SQL documentation"}),"."]})}),"\n",(0,i.jsx)(n.p,{children:"A having clause is a JSON object identifying which rows from a groupBy query should be returned, by specifying conditions on aggregated values."}),"\n",(0,i.jsx)(n.p,{children:"It is essentially the equivalent of the HAVING clause in SQL."}),"\n",(0,i.jsx)(n.p,{children:"Apache Druid supports the following types of having clauses."}),"\n",(0,i.jsx)(n.h3,{id:"query-filters",children:"Query filters"}),"\n",(0,i.jsxs)(n.p,{children:["Query filter HavingSpecs allow all ",(0,i.jsx)(n.a,{href:"/docs/33.0.0/querying/filters",children:"Druid query filters"})," to be used in the Having part of the query."]}),"\n",(0,i.jsx)(n.p,{children:"The grammar for a query filter HavingSpec is:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n    "queryType": "groupBy",\n    "dataSource": "sample_datasource",\n    ...\n    "having":\n        {\n            "type" : "filter",\n            "filter" : <any Druid query filter>\n        }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"For example, to use a selector filter:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n    "queryType": "groupBy",\n    "dataSource": "sample_datasource",\n    ...\n    "having":\n        {\n            "type" : "filter",\n            "filter" : {\n              "type": "selector",\n              "dimension" : "<dimension>",\n              "value" : "<dimension_value>"\n            }\n        }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:'You can use "filter" HavingSpecs to filter on the timestamp of result rows by applying a filter to the "__time"\ncolumn.'}),"\n",(0,i.jsx)(n.h3,{id:"numeric-filters",children:"Numeric filters"}),"\n",(0,i.jsx)(n.p,{children:"The simplest having clause is a numeric filter.\nNumeric filters can be used as the base filters for more complex boolean expressions of filters."}),"\n",(0,i.jsx)(n.p,{children:"Here's an example of a having-clause numeric filter:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n    "queryType": "groupBy",\n    "dataSource": "sample_datasource",\n    ...\n    "having":\n        {\n            "type": "greaterThan",\n            "aggregation": "<aggregate_metric>",\n            "value": <numeric_value>\n        }\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"equal-to",children:"Equal To"}),"\n",(0,i.jsxs)(n.p,{children:["The equalTo filter will match rows with a specific aggregate value.\nThe grammar for an ",(0,i.jsx)(n.code,{children:"equalTo"})," filter is as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n    "queryType": "groupBy",\n    "dataSource": "sample_datasource",\n    ...\n    "having":\n        {\n            "type": "equalTo",\n            "aggregation": "<aggregate_metric>",\n            "value": <numeric_value>\n        }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This is the equivalent of ",(0,i.jsx)(n.code,{children:"HAVING <aggregate> = <value>"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"greater-than",children:"Greater Than"}),"\n",(0,i.jsxs)(n.p,{children:["The greaterThan filter will match rows with aggregate values greater than the given value.\nThe grammar for a ",(0,i.jsx)(n.code,{children:"greaterThan"})," filter is as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n    "queryType": "groupBy",\n    "dataSource": "sample_datasource",\n    ...\n    "having":\n        {\n            "type": "greaterThan",\n            "aggregation": "<aggregate_metric>",\n            "value": <numeric_value>\n        }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This is the equivalent of ",(0,i.jsx)(n.code,{children:"HAVING <aggregate> > <value>"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"less-than",children:"Less Than"}),"\n",(0,i.jsxs)(n.p,{children:["The lessThan filter will match rows with aggregate values less than the specified value.\nThe grammar for a ",(0,i.jsx)(n.code,{children:"greaterThan"})," filter is as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n    "queryType": "groupBy",\n    "dataSource": "sample_datasource",\n    ...\n    "having":\n        {\n            "type": "lessThan",\n            "aggregation": "<aggregate_metric>",\n            "value": <numeric_value>\n        }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This is the equivalent of ",(0,i.jsx)(n.code,{children:"HAVING <aggregate> < <value>"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"dimension-selector-filter",children:"Dimension Selector Filter"}),"\n",(0,i.jsx)(n.h4,{id:"dimselector",children:"dimSelector"}),"\n",(0,i.jsxs)(n.p,{children:["The dimSelector filter will match rows with dimension values equal to the specified value.\nThe grammar for a ",(0,i.jsx)(n.code,{children:"dimSelector"})," filter is as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n    "queryType": "groupBy",\n    "dataSource": "sample_datasource",\n    ...\n    "having":\n       {\n            "type": "dimSelector",\n            "dimension": "<dimension>",\n            "value": <dimension_value>\n        }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"logical-expression-filters",children:"Logical expression filters"}),"\n",(0,i.jsx)(n.h4,{id:"and",children:"AND"}),"\n",(0,i.jsx)(n.p,{children:"The grammar for an AND filter is as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n    "queryType": "groupBy",\n    "dataSource": "sample_datasource",\n    ...\n    "having":\n        {\n            "type": "and",\n            "havingSpecs": [\n                {\n                    "type": "greaterThan",\n                    "aggregation": "<aggregate_metric>",\n                    "value": <numeric_value>\n                },\n                {\n                    "type": "lessThan",\n                    "aggregation": "<aggregate_metric>",\n                    "value": <numeric_value>\n                }\n            ]\n        }\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"or",children:"OR"}),"\n",(0,i.jsx)(n.p,{children:"The grammar for an OR filter is as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n    "queryType": "groupBy",\n    "dataSource": "sample_datasource",\n    ...\n    "having":\n        {\n            "type": "or",\n            "havingSpecs": [\n                {\n                    "type": "greaterThan",\n                    "aggregation": "<aggregate_metric>",\n                    "value": <numeric_value>\n                },\n                {\n                    "type": "equalTo",\n                    "aggregation": "<aggregate_metric>",\n                    "value": <numeric_value>\n                }\n            ]\n        }\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"not",children:"NOT"}),"\n",(0,i.jsx)(n.p,{children:"The grammar for a NOT filter is as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n    "queryType": "groupBy",\n    "dataSource": "sample_datasource",\n    ...\n    "having":\n        {\n        "type": "not",\n        "havingSpec":\n            {\n                "type": "equalTo",\n                "aggregation": "<aggregate_metric>",\n                "value": <numeric_value>\n            }\n        }\n}\n'})})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}}}]);