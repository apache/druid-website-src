"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[2052],{28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var r=s(96540);const i={},t=r.createContext(i);function a(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(t.Provider,{value:n},e.children)}},34271:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"design/indexer","title":"Indexer service","description":"\x3c!--","source":"@site/docs/33.0.0/design/indexer.md","sourceDirName":"design","slug":"/design/indexer","permalink":"/docs/33.0.0/design/indexer","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"layout":"doc_page","title":"Indexer service","sidebar_label":"Indexer"},"sidebar":"docs","previous":{"title":"Peon","permalink":"/docs/33.0.0/design/peons"},"next":{"title":"Storage","permalink":"/docs/33.0.0/design/storage"}}');var i=s(74848),t=s(28453);const a={layout:"doc_page",title:"Indexer service",sidebar_label:"Indexer"},o=void 0,d={},l=[{value:"Configuration",id:"configuration",level:2},{value:"HTTP endpoints",id:"http-endpoints",level:2},{value:"Running",id:"running",level:2},{value:"Task resource sharing",id:"task-resource-sharing",level:2},{value:"Query resources",id:"query-resources",level:3},{value:"Server HTTP threads",id:"server-http-threads",level:3},{value:"Memory sharing",id:"memory-sharing",level:3},{value:"Concurrent segment persist/merge limits",id:"concurrent-segment-persistmerge-limits",level:3},{value:"Current limitations",id:"current-limitations",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["The Indexer is an optional and experimental feature. If you're primarily performing batch ingestion, we recommend you use either the MiddleManager and Peon task execution system or ",(0,i.jsx)(n.a,{href:"/docs/33.0.0/development/extensions-core/k8s-jobs",children:"MiddleManager-less ingestion using Kubernetes"}),". If you're primarily doing streaming ingestion, you may want to try either ",(0,i.jsx)(n.a,{href:"/docs/33.0.0/development/extensions-core/k8s-jobs",children:"MiddleManager-less ingestion using Kubernetes"})," or the Indexer service."]})}),"\n",(0,i.jsx)(n.p,{children:"The Apache Druid Indexer service is an alternative to the Middle Manager + Peon task execution system. Instead of forking a separate JVM process per-task, the Indexer runs tasks as separate threads within a single JVM process."}),"\n",(0,i.jsx)(n.p,{children:"The Indexer is designed to be easier to configure and deploy compared to the Middle Manager + Peon system and to better enable resource sharing across tasks."}),"\n",(0,i.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,i.jsxs)(n.p,{children:["For Apache Druid Indexer service configuration, see ",(0,i.jsx)(n.a,{href:"/docs/33.0.0/configuration/#indexer",children:"Indexer Configuration"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"http-endpoints",children:"HTTP endpoints"}),"\n",(0,i.jsxs)(n.p,{children:["The Indexer service shares the same HTTP endpoints as the ",(0,i.jsx)(n.a,{href:"/docs/33.0.0/api-reference/service-status-api#middle-manager",children:"Middle Manager"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"running",children:"Running"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"org.apache.druid.cli.Main server indexer\n"})}),"\n",(0,i.jsx)(n.h2,{id:"task-resource-sharing",children:"Task resource sharing"}),"\n",(0,i.jsx)(n.p,{children:"The following resources are shared across all tasks running inside the Indexer service."}),"\n",(0,i.jsx)(n.h3,{id:"query-resources",children:"Query resources"}),"\n",(0,i.jsx)(n.p,{children:"The query processing threads and buffers are shared across all tasks. The Indexer serves queries from a single endpoint shared by all tasks."}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.a,{href:"/docs/33.0.0/configuration/#indexer-caching",children:"query caching"})," is enabled, the query cache is also shared across all tasks."]}),"\n",(0,i.jsx)(n.h3,{id:"server-http-threads",children:"Server HTTP threads"}),"\n",(0,i.jsx)(n.p,{children:'The Indexer maintains two equally sized pools of HTTP threads.\nOne pool is exclusively used for task control messages between the Overlord and the Indexer ("chat handler threads"). The other pool is used for handling all other HTTP requests.'}),"\n",(0,i.jsxs)(n.p,{children:["To configure the number of threads, use the ",(0,i.jsx)(n.code,{children:"druid.server.http.numThreads"})," property. For example, if ",(0,i.jsx)(n.code,{children:"druid.server.http.numThreads"})," is set to 10, there will be 10 chat handler threads and 10 non-chat handler threads."]}),"\n",(0,i.jsx)(n.p,{children:"In addition to these two pools, the Indexer allocates two separate threads for lookup handling. If lookups are not used, these threads will not be used."}),"\n",(0,i.jsx)(n.h3,{id:"memory-sharing",children:"Memory sharing"}),"\n",(0,i.jsxs)(n.p,{children:["The Indexer uses the ",(0,i.jsx)(n.code,{children:"druid.worker.globalIngestionHeapLimitBytes"})," property to impose a global heap limit across all of the tasks it is running."]}),"\n",(0,i.jsxs)(n.p,{children:["This global limit is evenly divided across the number of task slots configured by ",(0,i.jsx)(n.code,{children:"druid.worker.capacity"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["To apply the per-task heap limit, the Indexer overrides ",(0,i.jsx)(n.code,{children:"maxBytesInMemory"})," in task tuning configurations, that is ignoring the default value or any user configured value. It also overrides ",(0,i.jsx)(n.code,{children:"maxRowsInMemory"})," to an essentially unlimited value: the Indexer does not support row limits."]}),"\n",(0,i.jsxs)(n.p,{children:["By default, ",(0,i.jsx)(n.code,{children:"druid.worker.globalIngestionHeapLimitBytes"})," is set to 1/6th of the available JVM heap. This default is chosen to align with the default value of ",(0,i.jsx)(n.code,{children:"maxBytesInMemory"})," in task tuning configs when using the Middle Manager + Peon system, which is also 1/6th of the JVM heap."]}),"\n",(0,i.jsxs)(n.p,{children:["The peak usage for rows held in heap memory relates to the interaction between the ",(0,i.jsx)(n.code,{children:"maxBytesInMemory"})," and ",(0,i.jsx)(n.code,{children:"maxPendingPersists"})," properties in the task tuning configs. When the amount of row data held in-heap by a task reaches the limit specified by ",(0,i.jsx)(n.code,{children:"maxBytesInMemory"}),", a task will persist the in-heap row data. After the persist has been started, the task can again ingest up to ",(0,i.jsx)(n.code,{children:"maxBytesInMemory"})," bytes worth of row data while the persist is running."]}),"\n",(0,i.jsxs)(n.p,{children:["This means that the peak in-heap usage for row data can be up to approximately ",(0,i.jsx)(n.code,{children:"maxBytesInMemory * (2 + maxPendingPersists)"}),". The default value of ",(0,i.jsx)(n.code,{children:"maxPendingPersists"})," is 0, which allows for 1 persist to run concurrently with ingestion work."]}),"\n",(0,i.jsx)(n.p,{children:"The remaining portion of the heap is reserved for query processing and segment persist/merge operations, and miscellaneous heap usage."}),"\n",(0,i.jsx)(n.h3,{id:"concurrent-segment-persistmerge-limits",children:"Concurrent segment persist/merge limits"}),"\n",(0,i.jsx)(n.p,{children:"To help reduce peak memory usage, the Indexer imposes a limit on the number of concurrent segment persist/merge operations across all running tasks."}),"\n",(0,i.jsxs)(n.p,{children:["By default, the number of concurrent persist/merge operations is limited to ",(0,i.jsx)(n.code,{children:"(druid.worker.capacity / 2)"}),", rounded down. This limit can be configured with the ",(0,i.jsx)(n.code,{children:"druid.worker.numConcurrentMerges"})," property."]}),"\n",(0,i.jsx)(n.h2,{id:"current-limitations",children:"Current limitations"}),"\n",(0,i.jsx)(n.p,{children:"Separate task logs are not currently supported when using the Indexer; all task log messages will instead be logged in the Indexer service log."}),"\n",(0,i.jsx)(n.p,{children:"The Indexer currently imposes an identical memory limit on each task. In later releases, the per-task memory limit will be removed and only the global limit will apply. The limit on concurrent merges will also be removed."}),"\n",(0,i.jsxs)(n.p,{children:["In later releases, per-task memory usage will be dynamically managed. Please see ",(0,i.jsx)(n.a,{href:"https://github.com/apache/druid/issues/7900",children:"https://github.com/apache/druid/issues/7900"})," for details on future enhancements to the Indexer."]})]})}function c(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);