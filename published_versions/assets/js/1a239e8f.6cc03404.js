"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[3324],{28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var s=n(96540);const o={},i=s.createContext(o);function a(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(i.Provider,{value:t},e.children)}},83916:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>m});const s=JSON.parse('{"id":"operations/segment-optimization","title":"Segment size optimization","description":"\x3c!--","source":"@site/docs/latest/operations/segment-optimization.md","sourceDirName":"operations","slug":"/operations/segment-optimization","permalink":"/docs/latest/operations/segment-optimization","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"segment-optimization","title":"Segment size optimization"},"sidebar":"docs","previous":{"title":"Basic cluster tuning","permalink":"/docs/latest/operations/basic-cluster-tuning"},"next":{"title":"Mixed workloads","permalink":"/docs/latest/operations/mixed-workloads"}}');var o=n(74848),i=n(28453);const a={id:"segment-optimization",title:"Segment size optimization"},r=void 0,c={},m=[{value:"Learn more",id:"learn-more",level:2}];function l(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"In Apache Druid, it's important to optimize the segment size because"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["Druid stores data in segments. If you're using the ",(0,o.jsx)(t.a,{href:"/docs/latest/ingestion/rollup",children:"best-effort roll-up"})," mode,\nincreasing the segment size might introduce further aggregation which reduces the dataSource size."]}),"\n",(0,o.jsx)(t.li,{children:"When a query is submitted, that query is distributed to all Historicals and realtime tasks\nwhich hold the input segments of the query. Each process and task picks a thread from its own processing thread pool\nto process a single segment. If segment sizes are too large, data might not be well distributed between data\nservers, decreasing the degree of parallelism possible during query processing.\nAt the other extreme where segment sizes are too small, the scheduling\noverhead of processing a larger number of segments per query can reduce\nperformance, as the threads that process each segment compete for the fixed\nslots of the processing pool."}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["It would be best if you can optimize the segment size at ingestion time, but sometimes it's not easy\nespecially when it comes to stream ingestion because the amount of data ingested might vary over time. In this case,\nyou can create segments with a sub-optimized size first and optimize them later using ",(0,o.jsx)(t.a,{href:"/docs/latest/data-management/compaction",children:"compaction"}),"."]}),"\n",(0,o.jsx)(t.p,{children:"You may need to consider the followings to optimize your segments."}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["Number of rows per segment: it's generally recommended for each segment to have around 5 million rows.\nThis setting is usually ",(0,o.jsx)(t.em,{children:"more"}),' important than the below "segment byte size".\nThis is because Druid uses a single thread to process each segment,\nand thus this setting can directly control how many rows each thread processes,\nwhich in turn means how well the query execution is parallelized.']}),"\n",(0,o.jsx)(t.li,{children:"Segment byte size: it's recommended to set 300 ~ 700MB. If this value\ndoesn't match with the \"number of rows per segment\", please consider optimizing\nnumber of rows per segment rather than this value. Note that certain deep storage\nimplementations also impose an upper limit on segment size. For example, S3 deep\nstorage imposes an upper limit of 5 GB."}),"\n"]}),"\n",(0,o.jsx)(t.admonition,{type:"info",children:(0,o.jsx)(t.p,{children:"The above recommendation works in general, but the optimal setting can\nvary based on your workload. For example, if most of your queries\nare heavy and take a long time to process each row, you may want to make\nsegments smaller so that the query processing can be more parallelized.\nIf you still see some performance issue after optimizing segment size,\nyou may need to find the optimal settings for your workload."})}),"\n",(0,o.jsxs)(t.p,{children:["There might be several ways to check if the compaction is necessary. One way\nis using the ",(0,o.jsx)(t.a,{href:"/docs/latest/querying/sql-metadata-tables#system-schema",children:"System Schema"}),". The\nsystem schema provides several tables about the current system status including the ",(0,o.jsx)(t.code,{children:"segments"})," table.\nBy running the below query, you can get the average number of rows and average size for published segments."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-sql",children:'SELECT\n  "start",\n  "end",\n  version,\n  COUNT(*) AS num_segments,\n  AVG("num_rows") AS avg_num_rows,\n  SUM("num_rows") AS total_num_rows,\n  AVG("size") AS avg_size,\n  SUM("size") AS total_size\nFROM\n  sys.segments A\nWHERE\n  datasource = \'your_dataSource\' AND\n  is_published = 1\nGROUP BY 1, 2, 3\nORDER BY 1, 2, 3 DESC\n'})}),"\n",(0,o.jsxs)(t.p,{children:["Please note that the query result might include overshadowed segments.\nIn this case, you may want to see only rows of the max version per interval (pair of ",(0,o.jsx)(t.code,{children:"start"})," and ",(0,o.jsx)(t.code,{children:"end"}),")."]}),"\n",(0,o.jsx)(t.p,{children:"Once you find your segments need compaction, you can consider the below two options:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["Turning on the ",(0,o.jsx)(t.a,{href:"/docs/latest/design/coordinator#automatic-compaction",children:"automatic compaction of Coordinators"}),".\nThe Coordinator periodically submits ",(0,o.jsx)(t.a,{href:"/docs/latest/ingestion/tasks#compact",children:"compaction tasks"})," to re-index small segments.\nTo enable the automatic compaction, you need to configure it for each dataSource via Coordinator's dynamic configuration.\nFor more information, see ",(0,o.jsx)(t.a,{href:"/docs/latest/data-management/automatic-compaction",children:"Automatic compaction"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:["Running periodic Hadoop batch ingestion jobs and using a ",(0,o.jsx)(t.code,{children:"dataSource"}),"\ninputSpec to read from the segments generated by the Kafka indexing tasks. This might be helpful if you want to compact a lot of segments in parallel.\nDetails on how to do this can be found on the ",(0,o.jsx)(t.a,{href:"/docs/latest/data-management/update",children:"Updating existing data"})," section\nof the data management page."]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"learn-more",children:"Learn more"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["For an overview of compaction and how to submit a manual compaction task, see ",(0,o.jsx)(t.a,{href:"/docs/latest/data-management/compaction",children:"Compaction"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:["To learn how to enable and configure automatic compaction, see ",(0,o.jsx)(t.a,{href:"/docs/latest/data-management/automatic-compaction",children:"Automatic compaction"}),"."]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}}}]);